// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: UserBitShared.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_UserBitShared_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_UserBitShared_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4022000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4022002 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "Types.pb.h"
#include "Coordination.pb.h"
#include "SchemaDef.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_UserBitShared_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_UserBitShared_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_UserBitShared_2eproto;
namespace exec {
namespace shared {
class DrillPBError;
struct DrillPBErrorDefaultTypeInternal;
extern DrillPBErrorDefaultTypeInternal _DrillPBError_default_instance_;
class ExceptionWrapper;
struct ExceptionWrapperDefaultTypeInternal;
extern ExceptionWrapperDefaultTypeInternal _ExceptionWrapper_default_instance_;
class Jar;
struct JarDefaultTypeInternal;
extern JarDefaultTypeInternal _Jar_default_instance_;
class MajorFragmentProfile;
struct MajorFragmentProfileDefaultTypeInternal;
extern MajorFragmentProfileDefaultTypeInternal _MajorFragmentProfile_default_instance_;
class MetricValue;
struct MetricValueDefaultTypeInternal;
extern MetricValueDefaultTypeInternal _MetricValue_default_instance_;
class MinorFragmentProfile;
struct MinorFragmentProfileDefaultTypeInternal;
extern MinorFragmentProfileDefaultTypeInternal _MinorFragmentProfile_default_instance_;
class NamePart;
struct NamePartDefaultTypeInternal;
extern NamePartDefaultTypeInternal _NamePart_default_instance_;
class NodeStatus;
struct NodeStatusDefaultTypeInternal;
extern NodeStatusDefaultTypeInternal _NodeStatus_default_instance_;
class OperatorProfile;
struct OperatorProfileDefaultTypeInternal;
extern OperatorProfileDefaultTypeInternal _OperatorProfile_default_instance_;
class ParsingError;
struct ParsingErrorDefaultTypeInternal;
extern ParsingErrorDefaultTypeInternal _ParsingError_default_instance_;
class QueryData;
struct QueryDataDefaultTypeInternal;
extern QueryDataDefaultTypeInternal _QueryData_default_instance_;
class QueryId;
struct QueryIdDefaultTypeInternal;
extern QueryIdDefaultTypeInternal _QueryId_default_instance_;
class QueryInfo;
struct QueryInfoDefaultTypeInternal;
extern QueryInfoDefaultTypeInternal _QueryInfo_default_instance_;
class QueryProfile;
struct QueryProfileDefaultTypeInternal;
extern QueryProfileDefaultTypeInternal _QueryProfile_default_instance_;
class QueryResult;
struct QueryResultDefaultTypeInternal;
extern QueryResultDefaultTypeInternal _QueryResult_default_instance_;
class RecordBatchDef;
struct RecordBatchDefDefaultTypeInternal;
extern RecordBatchDefDefaultTypeInternal _RecordBatchDef_default_instance_;
class Registry;
struct RegistryDefaultTypeInternal;
extern RegistryDefaultTypeInternal _Registry_default_instance_;
class SaslMessage;
struct SaslMessageDefaultTypeInternal;
extern SaslMessageDefaultTypeInternal _SaslMessage_default_instance_;
class SerializedField;
struct SerializedFieldDefaultTypeInternal;
extern SerializedFieldDefaultTypeInternal _SerializedField_default_instance_;
class StackTraceElementWrapper;
struct StackTraceElementWrapperDefaultTypeInternal;
extern StackTraceElementWrapperDefaultTypeInternal _StackTraceElementWrapper_default_instance_;
class StreamProfile;
struct StreamProfileDefaultTypeInternal;
extern StreamProfileDefaultTypeInternal _StreamProfile_default_instance_;
class UserCredentials;
struct UserCredentialsDefaultTypeInternal;
extern UserCredentialsDefaultTypeInternal _UserCredentials_default_instance_;
}  // namespace shared
}  // namespace exec
PROTOBUF_NAMESPACE_OPEN
template <>
::exec::shared::DrillPBError* Arena::CreateMaybeMessage<::exec::shared::DrillPBError>(Arena*);
template <>
::exec::shared::ExceptionWrapper* Arena::CreateMaybeMessage<::exec::shared::ExceptionWrapper>(Arena*);
template <>
::exec::shared::Jar* Arena::CreateMaybeMessage<::exec::shared::Jar>(Arena*);
template <>
::exec::shared::MajorFragmentProfile* Arena::CreateMaybeMessage<::exec::shared::MajorFragmentProfile>(Arena*);
template <>
::exec::shared::MetricValue* Arena::CreateMaybeMessage<::exec::shared::MetricValue>(Arena*);
template <>
::exec::shared::MinorFragmentProfile* Arena::CreateMaybeMessage<::exec::shared::MinorFragmentProfile>(Arena*);
template <>
::exec::shared::NamePart* Arena::CreateMaybeMessage<::exec::shared::NamePart>(Arena*);
template <>
::exec::shared::NodeStatus* Arena::CreateMaybeMessage<::exec::shared::NodeStatus>(Arena*);
template <>
::exec::shared::OperatorProfile* Arena::CreateMaybeMessage<::exec::shared::OperatorProfile>(Arena*);
template <>
::exec::shared::ParsingError* Arena::CreateMaybeMessage<::exec::shared::ParsingError>(Arena*);
template <>
::exec::shared::QueryData* Arena::CreateMaybeMessage<::exec::shared::QueryData>(Arena*);
template <>
::exec::shared::QueryId* Arena::CreateMaybeMessage<::exec::shared::QueryId>(Arena*);
template <>
::exec::shared::QueryInfo* Arena::CreateMaybeMessage<::exec::shared::QueryInfo>(Arena*);
template <>
::exec::shared::QueryProfile* Arena::CreateMaybeMessage<::exec::shared::QueryProfile>(Arena*);
template <>
::exec::shared::QueryResult* Arena::CreateMaybeMessage<::exec::shared::QueryResult>(Arena*);
template <>
::exec::shared::RecordBatchDef* Arena::CreateMaybeMessage<::exec::shared::RecordBatchDef>(Arena*);
template <>
::exec::shared::Registry* Arena::CreateMaybeMessage<::exec::shared::Registry>(Arena*);
template <>
::exec::shared::SaslMessage* Arena::CreateMaybeMessage<::exec::shared::SaslMessage>(Arena*);
template <>
::exec::shared::SerializedField* Arena::CreateMaybeMessage<::exec::shared::SerializedField>(Arena*);
template <>
::exec::shared::StackTraceElementWrapper* Arena::CreateMaybeMessage<::exec::shared::StackTraceElementWrapper>(Arena*);
template <>
::exec::shared::StreamProfile* Arena::CreateMaybeMessage<::exec::shared::StreamProfile>(Arena*);
template <>
::exec::shared::UserCredentials* Arena::CreateMaybeMessage<::exec::shared::UserCredentials>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace exec {
namespace shared {
enum DrillPBError_ErrorType : int {
  DrillPBError_ErrorType_CONNECTION = 0,
  DrillPBError_ErrorType_DATA_READ = 1,
  DrillPBError_ErrorType_DATA_WRITE = 2,
  DrillPBError_ErrorType_FUNCTION = 3,
  DrillPBError_ErrorType_PARSE = 4,
  DrillPBError_ErrorType_PERMISSION = 5,
  DrillPBError_ErrorType_PLAN = 6,
  DrillPBError_ErrorType_RESOURCE = 7,
  DrillPBError_ErrorType_SYSTEM = 8,
  DrillPBError_ErrorType_UNSUPPORTED_OPERATION = 9,
  DrillPBError_ErrorType_VALIDATION = 10,
  DrillPBError_ErrorType_EXECUTION_ERROR = 11,
  DrillPBError_ErrorType_INTERNAL_ERROR = 12,
  DrillPBError_ErrorType_UNSPECIFIED_ERROR = 13,
};

bool DrillPBError_ErrorType_IsValid(int value);
constexpr DrillPBError_ErrorType DrillPBError_ErrorType_ErrorType_MIN = static_cast<DrillPBError_ErrorType>(0);
constexpr DrillPBError_ErrorType DrillPBError_ErrorType_ErrorType_MAX = static_cast<DrillPBError_ErrorType>(13);
constexpr int DrillPBError_ErrorType_ErrorType_ARRAYSIZE = 13 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
DrillPBError_ErrorType_descriptor();
template <typename T>
const std::string& DrillPBError_ErrorType_Name(T value) {
  static_assert(std::is_same<T, DrillPBError_ErrorType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ErrorType_Name().");
  return DrillPBError_ErrorType_Name(static_cast<DrillPBError_ErrorType>(value));
}
template <>
inline const std::string& DrillPBError_ErrorType_Name(DrillPBError_ErrorType value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<DrillPBError_ErrorType_descriptor,
                                                 0, 13>(
      static_cast<int>(value));
}
inline bool DrillPBError_ErrorType_Parse(absl::string_view name, DrillPBError_ErrorType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DrillPBError_ErrorType>(
      DrillPBError_ErrorType_descriptor(), name, value);
}
enum NamePart_Type : int {
  NamePart_Type_NAME = 0,
  NamePart_Type_ARRAY = 1,
};

bool NamePart_Type_IsValid(int value);
constexpr NamePart_Type NamePart_Type_Type_MIN = static_cast<NamePart_Type>(0);
constexpr NamePart_Type NamePart_Type_Type_MAX = static_cast<NamePart_Type>(1);
constexpr int NamePart_Type_Type_ARRAYSIZE = 1 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
NamePart_Type_descriptor();
template <typename T>
const std::string& NamePart_Type_Name(T value) {
  static_assert(std::is_same<T, NamePart_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return NamePart_Type_Name(static_cast<NamePart_Type>(value));
}
template <>
inline const std::string& NamePart_Type_Name(NamePart_Type value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<NamePart_Type_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool NamePart_Type_Parse(absl::string_view name, NamePart_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NamePart_Type>(
      NamePart_Type_descriptor(), name, value);
}
enum QueryResult_QueryState : int {
  QueryResult_QueryState_STARTING = 0,
  QueryResult_QueryState_RUNNING = 1,
  QueryResult_QueryState_COMPLETED = 2,
  QueryResult_QueryState_CANCELED = 3,
  QueryResult_QueryState_FAILED = 4,
  QueryResult_QueryState_CANCELLATION_REQUESTED = 5,
  QueryResult_QueryState_ENQUEUED = 6,
  QueryResult_QueryState_PREPARING = 7,
  QueryResult_QueryState_PLANNING = 8,
};

bool QueryResult_QueryState_IsValid(int value);
constexpr QueryResult_QueryState QueryResult_QueryState_QueryState_MIN = static_cast<QueryResult_QueryState>(0);
constexpr QueryResult_QueryState QueryResult_QueryState_QueryState_MAX = static_cast<QueryResult_QueryState>(8);
constexpr int QueryResult_QueryState_QueryState_ARRAYSIZE = 8 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
QueryResult_QueryState_descriptor();
template <typename T>
const std::string& QueryResult_QueryState_Name(T value) {
  static_assert(std::is_same<T, QueryResult_QueryState>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to QueryState_Name().");
  return QueryResult_QueryState_Name(static_cast<QueryResult_QueryState>(value));
}
template <>
inline const std::string& QueryResult_QueryState_Name(QueryResult_QueryState value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<QueryResult_QueryState_descriptor,
                                                 0, 8>(
      static_cast<int>(value));
}
inline bool QueryResult_QueryState_Parse(absl::string_view name, QueryResult_QueryState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<QueryResult_QueryState>(
      QueryResult_QueryState_descriptor(), name, value);
}
enum RpcChannel : int {
  BIT_CONTROL = 0,
  BIT_DATA = 1,
  USER = 2,
};

bool RpcChannel_IsValid(int value);
constexpr RpcChannel RpcChannel_MIN = static_cast<RpcChannel>(0);
constexpr RpcChannel RpcChannel_MAX = static_cast<RpcChannel>(2);
constexpr int RpcChannel_ARRAYSIZE = 2 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
RpcChannel_descriptor();
template <typename T>
const std::string& RpcChannel_Name(T value) {
  static_assert(std::is_same<T, RpcChannel>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to RpcChannel_Name().");
  return RpcChannel_Name(static_cast<RpcChannel>(value));
}
template <>
inline const std::string& RpcChannel_Name(RpcChannel value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<RpcChannel_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool RpcChannel_Parse(absl::string_view name, RpcChannel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RpcChannel>(
      RpcChannel_descriptor(), name, value);
}
enum QueryType : int {
  SQL = 1,
  LOGICAL = 2,
  PHYSICAL = 3,
  EXECUTION = 4,
  PREPARED_STATEMENT = 5,
};

bool QueryType_IsValid(int value);
constexpr QueryType QueryType_MIN = static_cast<QueryType>(1);
constexpr QueryType QueryType_MAX = static_cast<QueryType>(5);
constexpr int QueryType_ARRAYSIZE = 5 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
QueryType_descriptor();
template <typename T>
const std::string& QueryType_Name(T value) {
  static_assert(std::is_same<T, QueryType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to QueryType_Name().");
  return QueryType_Name(static_cast<QueryType>(value));
}
template <>
inline const std::string& QueryType_Name(QueryType value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<QueryType_descriptor,
                                                 1, 5>(
      static_cast<int>(value));
}
inline bool QueryType_Parse(absl::string_view name, QueryType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<QueryType>(
      QueryType_descriptor(), name, value);
}
enum FragmentState : int {
  SENDING = 0,
  AWAITING_ALLOCATION = 1,
  RUNNING = 2,
  FINISHED = 3,
  CANCELLED = 4,
  FAILED = 5,
  CANCELLATION_REQUESTED = 6,
};

bool FragmentState_IsValid(int value);
constexpr FragmentState FragmentState_MIN = static_cast<FragmentState>(0);
constexpr FragmentState FragmentState_MAX = static_cast<FragmentState>(6);
constexpr int FragmentState_ARRAYSIZE = 6 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
FragmentState_descriptor();
template <typename T>
const std::string& FragmentState_Name(T value) {
  static_assert(std::is_same<T, FragmentState>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to FragmentState_Name().");
  return FragmentState_Name(static_cast<FragmentState>(value));
}
template <>
inline const std::string& FragmentState_Name(FragmentState value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<FragmentState_descriptor,
                                                 0, 6>(
      static_cast<int>(value));
}
inline bool FragmentState_Parse(absl::string_view name, FragmentState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FragmentState>(
      FragmentState_descriptor(), name, value);
}
enum SaslStatus : int {
  SASL_UNKNOWN = 0,
  SASL_START = 1,
  SASL_IN_PROGRESS = 2,
  SASL_SUCCESS = 3,
  SASL_FAILED = 4,
};

bool SaslStatus_IsValid(int value);
constexpr SaslStatus SaslStatus_MIN = static_cast<SaslStatus>(0);
constexpr SaslStatus SaslStatus_MAX = static_cast<SaslStatus>(4);
constexpr int SaslStatus_ARRAYSIZE = 4 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
SaslStatus_descriptor();
template <typename T>
const std::string& SaslStatus_Name(T value) {
  static_assert(std::is_same<T, SaslStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SaslStatus_Name().");
  return SaslStatus_Name(static_cast<SaslStatus>(value));
}
template <>
inline const std::string& SaslStatus_Name(SaslStatus value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<SaslStatus_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool SaslStatus_Parse(absl::string_view name, SaslStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SaslStatus>(
      SaslStatus_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class UserCredentials final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.shared.UserCredentials) */ {
 public:
  inline UserCredentials() : UserCredentials(nullptr) {}
  ~UserCredentials() override;
  explicit PROTOBUF_CONSTEXPR UserCredentials(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserCredentials(const UserCredentials& from);
  UserCredentials(UserCredentials&& from) noexcept
    : UserCredentials() {
    *this = ::std::move(from);
  }

  inline UserCredentials& operator=(const UserCredentials& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserCredentials& operator=(UserCredentials&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserCredentials& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserCredentials* internal_default_instance() {
    return reinterpret_cast<const UserCredentials*>(
               &_UserCredentials_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(UserCredentials& a, UserCredentials& b) {
    a.Swap(&b);
  }
  inline void Swap(UserCredentials* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserCredentials* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserCredentials* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserCredentials>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserCredentials& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserCredentials& from) {
    UserCredentials::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserCredentials* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.shared.UserCredentials";
  }
  protected:
  explicit UserCredentials(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserNameFieldNumber = 1,
  };
  // optional string user_name = 1;
  bool has_user_name() const;
  void clear_user_name() ;
  const std::string& user_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_user_name(Arg_&& arg, Args_... args);
  std::string* mutable_user_name();
  PROTOBUF_NODISCARD std::string* release_user_name();
  void set_allocated_user_name(std::string* ptr);

  private:
  const std::string& _internal_user_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_name(
      const std::string& value);
  std::string* _internal_mutable_user_name();

  public:
  // @@protoc_insertion_point(class_scope:exec.shared.UserCredentials)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_name_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_UserBitShared_2eproto;
};// -------------------------------------------------------------------

class QueryId final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.shared.QueryId) */ {
 public:
  inline QueryId() : QueryId(nullptr) {}
  ~QueryId() override;
  explicit PROTOBUF_CONSTEXPR QueryId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryId(const QueryId& from);
  QueryId(QueryId&& from) noexcept
    : QueryId() {
    *this = ::std::move(from);
  }

  inline QueryId& operator=(const QueryId& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryId& operator=(QueryId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryId& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryId* internal_default_instance() {
    return reinterpret_cast<const QueryId*>(
               &_QueryId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(QueryId& a, QueryId& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryId* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryId>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryId& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryId& from) {
    QueryId::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryId* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.shared.QueryId";
  }
  protected:
  explicit QueryId(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPart1FieldNumber = 1,
    kPart2FieldNumber = 2,
  };
  // optional sfixed64 part1 = 1;
  bool has_part1() const;
  void clear_part1() ;
  ::int64_t part1() const;
  void set_part1(::int64_t value);

  private:
  ::int64_t _internal_part1() const;
  void _internal_set_part1(::int64_t value);

  public:
  // optional sfixed64 part2 = 2;
  bool has_part2() const;
  void clear_part2() ;
  ::int64_t part2() const;
  void set_part2(::int64_t value);

  private:
  ::int64_t _internal_part2() const;
  void _internal_set_part2(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:exec.shared.QueryId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::int64_t part1_;
    ::int64_t part2_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_UserBitShared_2eproto;
};// -------------------------------------------------------------------

class DrillPBError final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.shared.DrillPBError) */ {
 public:
  inline DrillPBError() : DrillPBError(nullptr) {}
  ~DrillPBError() override;
  explicit PROTOBUF_CONSTEXPR DrillPBError(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DrillPBError(const DrillPBError& from);
  DrillPBError(DrillPBError&& from) noexcept
    : DrillPBError() {
    *this = ::std::move(from);
  }

  inline DrillPBError& operator=(const DrillPBError& from) {
    CopyFrom(from);
    return *this;
  }
  inline DrillPBError& operator=(DrillPBError&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DrillPBError& default_instance() {
    return *internal_default_instance();
  }
  static inline const DrillPBError* internal_default_instance() {
    return reinterpret_cast<const DrillPBError*>(
               &_DrillPBError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DrillPBError& a, DrillPBError& b) {
    a.Swap(&b);
  }
  inline void Swap(DrillPBError* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DrillPBError* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DrillPBError* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DrillPBError>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DrillPBError& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DrillPBError& from) {
    DrillPBError::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DrillPBError* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.shared.DrillPBError";
  }
  protected:
  explicit DrillPBError(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using ErrorType = DrillPBError_ErrorType;
  static constexpr ErrorType CONNECTION = DrillPBError_ErrorType_CONNECTION;
  static constexpr ErrorType DATA_READ = DrillPBError_ErrorType_DATA_READ;
  static constexpr ErrorType DATA_WRITE = DrillPBError_ErrorType_DATA_WRITE;
  static constexpr ErrorType FUNCTION = DrillPBError_ErrorType_FUNCTION;
  static constexpr ErrorType PARSE = DrillPBError_ErrorType_PARSE;
  static constexpr ErrorType PERMISSION = DrillPBError_ErrorType_PERMISSION;
  static constexpr ErrorType PLAN = DrillPBError_ErrorType_PLAN;
  static constexpr ErrorType RESOURCE = DrillPBError_ErrorType_RESOURCE;
  static constexpr ErrorType SYSTEM = DrillPBError_ErrorType_SYSTEM;
  static constexpr ErrorType UNSUPPORTED_OPERATION = DrillPBError_ErrorType_UNSUPPORTED_OPERATION;
  static constexpr ErrorType VALIDATION = DrillPBError_ErrorType_VALIDATION;
  static constexpr ErrorType EXECUTION_ERROR = DrillPBError_ErrorType_EXECUTION_ERROR;
  static constexpr ErrorType INTERNAL_ERROR = DrillPBError_ErrorType_INTERNAL_ERROR;
  static constexpr ErrorType UNSPECIFIED_ERROR = DrillPBError_ErrorType_UNSPECIFIED_ERROR;
  static inline bool ErrorType_IsValid(int value) {
    return DrillPBError_ErrorType_IsValid(value);
  }
  static constexpr ErrorType ErrorType_MIN = DrillPBError_ErrorType_ErrorType_MIN;
  static constexpr ErrorType ErrorType_MAX = DrillPBError_ErrorType_ErrorType_MAX;
  static constexpr int ErrorType_ARRAYSIZE = DrillPBError_ErrorType_ErrorType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ErrorType_descriptor() {
    return DrillPBError_ErrorType_descriptor();
  }
  template <typename T>
  static inline const std::string& ErrorType_Name(T value) {
    return DrillPBError_ErrorType_Name(value);
  }
  static inline bool ErrorType_Parse(absl::string_view name, ErrorType* value) {
    return DrillPBError_ErrorType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kParsingErrorFieldNumber = 6,
    kErrorIdFieldNumber = 1,
    kMessageFieldNumber = 4,
    kEndpointFieldNumber = 2,
    kExceptionFieldNumber = 5,
    kErrorTypeFieldNumber = 3,
  };
  // repeated .exec.shared.ParsingError parsing_error = 6;
  int parsing_error_size() const;
  private:
  int _internal_parsing_error_size() const;

  public:
  void clear_parsing_error() ;
  ::exec::shared::ParsingError* mutable_parsing_error(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::shared::ParsingError >*
      mutable_parsing_error();
  private:
  const ::exec::shared::ParsingError& _internal_parsing_error(int index) const;
  ::exec::shared::ParsingError* _internal_add_parsing_error();
  public:
  const ::exec::shared::ParsingError& parsing_error(int index) const;
  ::exec::shared::ParsingError* add_parsing_error();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::shared::ParsingError >&
      parsing_error() const;
  // optional string error_id = 1;
  bool has_error_id() const;
  void clear_error_id() ;
  const std::string& error_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error_id(Arg_&& arg, Args_... args);
  std::string* mutable_error_id();
  PROTOBUF_NODISCARD std::string* release_error_id();
  void set_allocated_error_id(std::string* ptr);

  private:
  const std::string& _internal_error_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_id(
      const std::string& value);
  std::string* _internal_mutable_error_id();

  public:
  // optional string message = 4;
  bool has_message() const;
  void clear_message() ;
  const std::string& message() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* ptr);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // optional .exec.DrillbitEndpoint endpoint = 2;
  bool has_endpoint() const;
  void clear_endpoint() ;
  const ::exec::DrillbitEndpoint& endpoint() const;
  PROTOBUF_NODISCARD ::exec::DrillbitEndpoint* release_endpoint();
  ::exec::DrillbitEndpoint* mutable_endpoint();
  void set_allocated_endpoint(::exec::DrillbitEndpoint* endpoint);
  private:
  const ::exec::DrillbitEndpoint& _internal_endpoint() const;
  ::exec::DrillbitEndpoint* _internal_mutable_endpoint();
  public:
  void unsafe_arena_set_allocated_endpoint(
      ::exec::DrillbitEndpoint* endpoint);
  ::exec::DrillbitEndpoint* unsafe_arena_release_endpoint();
  // optional .exec.shared.ExceptionWrapper exception = 5;
  bool has_exception() const;
  void clear_exception() ;
  const ::exec::shared::ExceptionWrapper& exception() const;
  PROTOBUF_NODISCARD ::exec::shared::ExceptionWrapper* release_exception();
  ::exec::shared::ExceptionWrapper* mutable_exception();
  void set_allocated_exception(::exec::shared::ExceptionWrapper* exception);
  private:
  const ::exec::shared::ExceptionWrapper& _internal_exception() const;
  ::exec::shared::ExceptionWrapper* _internal_mutable_exception();
  public:
  void unsafe_arena_set_allocated_exception(
      ::exec::shared::ExceptionWrapper* exception);
  ::exec::shared::ExceptionWrapper* unsafe_arena_release_exception();
  // optional .exec.shared.DrillPBError.ErrorType error_type = 3;
  bool has_error_type() const;
  void clear_error_type() ;
  ::exec::shared::DrillPBError_ErrorType error_type() const;
  void set_error_type(::exec::shared::DrillPBError_ErrorType value);

  private:
  ::exec::shared::DrillPBError_ErrorType _internal_error_type() const;
  void _internal_set_error_type(::exec::shared::DrillPBError_ErrorType value);

  public:
  // @@protoc_insertion_point(class_scope:exec.shared.DrillPBError)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::shared::ParsingError > parsing_error_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::exec::DrillbitEndpoint* endpoint_;
    ::exec::shared::ExceptionWrapper* exception_;
    int error_type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_UserBitShared_2eproto;
};// -------------------------------------------------------------------

class ExceptionWrapper final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.shared.ExceptionWrapper) */ {
 public:
  inline ExceptionWrapper() : ExceptionWrapper(nullptr) {}
  ~ExceptionWrapper() override;
  explicit PROTOBUF_CONSTEXPR ExceptionWrapper(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExceptionWrapper(const ExceptionWrapper& from);
  ExceptionWrapper(ExceptionWrapper&& from) noexcept
    : ExceptionWrapper() {
    *this = ::std::move(from);
  }

  inline ExceptionWrapper& operator=(const ExceptionWrapper& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExceptionWrapper& operator=(ExceptionWrapper&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExceptionWrapper& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExceptionWrapper* internal_default_instance() {
    return reinterpret_cast<const ExceptionWrapper*>(
               &_ExceptionWrapper_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ExceptionWrapper& a, ExceptionWrapper& b) {
    a.Swap(&b);
  }
  inline void Swap(ExceptionWrapper* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExceptionWrapper* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExceptionWrapper* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExceptionWrapper>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExceptionWrapper& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExceptionWrapper& from) {
    ExceptionWrapper::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExceptionWrapper* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.shared.ExceptionWrapper";
  }
  protected:
  explicit ExceptionWrapper(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStackTraceFieldNumber = 3,
    kExceptionClassFieldNumber = 1,
    kMessageFieldNumber = 2,
    kCauseFieldNumber = 4,
  };
  // repeated .exec.shared.StackTraceElementWrapper stack_trace = 3;
  int stack_trace_size() const;
  private:
  int _internal_stack_trace_size() const;

  public:
  void clear_stack_trace() ;
  ::exec::shared::StackTraceElementWrapper* mutable_stack_trace(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::shared::StackTraceElementWrapper >*
      mutable_stack_trace();
  private:
  const ::exec::shared::StackTraceElementWrapper& _internal_stack_trace(int index) const;
  ::exec::shared::StackTraceElementWrapper* _internal_add_stack_trace();
  public:
  const ::exec::shared::StackTraceElementWrapper& stack_trace(int index) const;
  ::exec::shared::StackTraceElementWrapper* add_stack_trace();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::shared::StackTraceElementWrapper >&
      stack_trace() const;
  // optional string exception_class = 1;
  bool has_exception_class() const;
  void clear_exception_class() ;
  const std::string& exception_class() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_exception_class(Arg_&& arg, Args_... args);
  std::string* mutable_exception_class();
  PROTOBUF_NODISCARD std::string* release_exception_class();
  void set_allocated_exception_class(std::string* ptr);

  private:
  const std::string& _internal_exception_class() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_exception_class(
      const std::string& value);
  std::string* _internal_mutable_exception_class();

  public:
  // optional string message = 2;
  bool has_message() const;
  void clear_message() ;
  const std::string& message() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* ptr);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // optional .exec.shared.ExceptionWrapper cause = 4;
  bool has_cause() const;
  void clear_cause() ;
  const ::exec::shared::ExceptionWrapper& cause() const;
  PROTOBUF_NODISCARD ::exec::shared::ExceptionWrapper* release_cause();
  ::exec::shared::ExceptionWrapper* mutable_cause();
  void set_allocated_cause(::exec::shared::ExceptionWrapper* cause);
  private:
  const ::exec::shared::ExceptionWrapper& _internal_cause() const;
  ::exec::shared::ExceptionWrapper* _internal_mutable_cause();
  public:
  void unsafe_arena_set_allocated_cause(
      ::exec::shared::ExceptionWrapper* cause);
  ::exec::shared::ExceptionWrapper* unsafe_arena_release_cause();
  // @@protoc_insertion_point(class_scope:exec.shared.ExceptionWrapper)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::shared::StackTraceElementWrapper > stack_trace_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr exception_class_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::exec::shared::ExceptionWrapper* cause_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_UserBitShared_2eproto;
};// -------------------------------------------------------------------

class StackTraceElementWrapper final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.shared.StackTraceElementWrapper) */ {
 public:
  inline StackTraceElementWrapper() : StackTraceElementWrapper(nullptr) {}
  ~StackTraceElementWrapper() override;
  explicit PROTOBUF_CONSTEXPR StackTraceElementWrapper(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StackTraceElementWrapper(const StackTraceElementWrapper& from);
  StackTraceElementWrapper(StackTraceElementWrapper&& from) noexcept
    : StackTraceElementWrapper() {
    *this = ::std::move(from);
  }

  inline StackTraceElementWrapper& operator=(const StackTraceElementWrapper& from) {
    CopyFrom(from);
    return *this;
  }
  inline StackTraceElementWrapper& operator=(StackTraceElementWrapper&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StackTraceElementWrapper& default_instance() {
    return *internal_default_instance();
  }
  static inline const StackTraceElementWrapper* internal_default_instance() {
    return reinterpret_cast<const StackTraceElementWrapper*>(
               &_StackTraceElementWrapper_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(StackTraceElementWrapper& a, StackTraceElementWrapper& b) {
    a.Swap(&b);
  }
  inline void Swap(StackTraceElementWrapper* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StackTraceElementWrapper* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StackTraceElementWrapper* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StackTraceElementWrapper>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StackTraceElementWrapper& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StackTraceElementWrapper& from) {
    StackTraceElementWrapper::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StackTraceElementWrapper* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.shared.StackTraceElementWrapper";
  }
  protected:
  explicit StackTraceElementWrapper(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClassNameFieldNumber = 1,
    kFileNameFieldNumber = 2,
    kMethodNameFieldNumber = 4,
    kLineNumberFieldNumber = 3,
    kIsNativeMethodFieldNumber = 5,
  };
  // optional string class_name = 1;
  bool has_class_name() const;
  void clear_class_name() ;
  const std::string& class_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_class_name(Arg_&& arg, Args_... args);
  std::string* mutable_class_name();
  PROTOBUF_NODISCARD std::string* release_class_name();
  void set_allocated_class_name(std::string* ptr);

  private:
  const std::string& _internal_class_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_class_name(
      const std::string& value);
  std::string* _internal_mutable_class_name();

  public:
  // optional string file_name = 2;
  bool has_file_name() const;
  void clear_file_name() ;
  const std::string& file_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_file_name(Arg_&& arg, Args_... args);
  std::string* mutable_file_name();
  PROTOBUF_NODISCARD std::string* release_file_name();
  void set_allocated_file_name(std::string* ptr);

  private:
  const std::string& _internal_file_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_name(
      const std::string& value);
  std::string* _internal_mutable_file_name();

  public:
  // optional string method_name = 4;
  bool has_method_name() const;
  void clear_method_name() ;
  const std::string& method_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_method_name(Arg_&& arg, Args_... args);
  std::string* mutable_method_name();
  PROTOBUF_NODISCARD std::string* release_method_name();
  void set_allocated_method_name(std::string* ptr);

  private:
  const std::string& _internal_method_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_method_name(
      const std::string& value);
  std::string* _internal_mutable_method_name();

  public:
  // optional int32 line_number = 3;
  bool has_line_number() const;
  void clear_line_number() ;
  ::int32_t line_number() const;
  void set_line_number(::int32_t value);

  private:
  ::int32_t _internal_line_number() const;
  void _internal_set_line_number(::int32_t value);

  public:
  // optional bool is_native_method = 5;
  bool has_is_native_method() const;
  void clear_is_native_method() ;
  bool is_native_method() const;
  void set_is_native_method(bool value);

  private:
  bool _internal_is_native_method() const;
  void _internal_set_is_native_method(bool value);

  public:
  // @@protoc_insertion_point(class_scope:exec.shared.StackTraceElementWrapper)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr class_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr method_name_;
    ::int32_t line_number_;
    bool is_native_method_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_UserBitShared_2eproto;
};// -------------------------------------------------------------------

class ParsingError final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.shared.ParsingError) */ {
 public:
  inline ParsingError() : ParsingError(nullptr) {}
  ~ParsingError() override;
  explicit PROTOBUF_CONSTEXPR ParsingError(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ParsingError(const ParsingError& from);
  ParsingError(ParsingError&& from) noexcept
    : ParsingError() {
    *this = ::std::move(from);
  }

  inline ParsingError& operator=(const ParsingError& from) {
    CopyFrom(from);
    return *this;
  }
  inline ParsingError& operator=(ParsingError&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ParsingError& default_instance() {
    return *internal_default_instance();
  }
  static inline const ParsingError* internal_default_instance() {
    return reinterpret_cast<const ParsingError*>(
               &_ParsingError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ParsingError& a, ParsingError& b) {
    a.Swap(&b);
  }
  inline void Swap(ParsingError* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ParsingError* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ParsingError* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ParsingError>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ParsingError& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ParsingError& from) {
    ParsingError::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ParsingError* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.shared.ParsingError";
  }
  protected:
  explicit ParsingError(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartColumnFieldNumber = 2,
    kStartRowFieldNumber = 3,
    kEndColumnFieldNumber = 4,
    kEndRowFieldNumber = 5,
  };
  // optional int32 start_column = 2;
  bool has_start_column() const;
  void clear_start_column() ;
  ::int32_t start_column() const;
  void set_start_column(::int32_t value);

  private:
  ::int32_t _internal_start_column() const;
  void _internal_set_start_column(::int32_t value);

  public:
  // optional int32 start_row = 3;
  bool has_start_row() const;
  void clear_start_row() ;
  ::int32_t start_row() const;
  void set_start_row(::int32_t value);

  private:
  ::int32_t _internal_start_row() const;
  void _internal_set_start_row(::int32_t value);

  public:
  // optional int32 end_column = 4;
  bool has_end_column() const;
  void clear_end_column() ;
  ::int32_t end_column() const;
  void set_end_column(::int32_t value);

  private:
  ::int32_t _internal_end_column() const;
  void _internal_set_end_column(::int32_t value);

  public:
  // optional int32 end_row = 5;
  bool has_end_row() const;
  void clear_end_row() ;
  ::int32_t end_row() const;
  void set_end_row(::int32_t value);

  private:
  ::int32_t _internal_end_row() const;
  void _internal_set_end_row(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:exec.shared.ParsingError)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::int32_t start_column_;
    ::int32_t start_row_;
    ::int32_t end_column_;
    ::int32_t end_row_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_UserBitShared_2eproto;
};// -------------------------------------------------------------------

class RecordBatchDef final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.shared.RecordBatchDef) */ {
 public:
  inline RecordBatchDef() : RecordBatchDef(nullptr) {}
  ~RecordBatchDef() override;
  explicit PROTOBUF_CONSTEXPR RecordBatchDef(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RecordBatchDef(const RecordBatchDef& from);
  RecordBatchDef(RecordBatchDef&& from) noexcept
    : RecordBatchDef() {
    *this = ::std::move(from);
  }

  inline RecordBatchDef& operator=(const RecordBatchDef& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecordBatchDef& operator=(RecordBatchDef&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecordBatchDef& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecordBatchDef* internal_default_instance() {
    return reinterpret_cast<const RecordBatchDef*>(
               &_RecordBatchDef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RecordBatchDef& a, RecordBatchDef& b) {
    a.Swap(&b);
  }
  inline void Swap(RecordBatchDef* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecordBatchDef* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecordBatchDef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecordBatchDef>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RecordBatchDef& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RecordBatchDef& from) {
    RecordBatchDef::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecordBatchDef* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.shared.RecordBatchDef";
  }
  protected:
  explicit RecordBatchDef(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldFieldNumber = 2,
    kRecordCountFieldNumber = 1,
    kCarriesTwoByteSelectionVectorFieldNumber = 3,
    kAffectedRowsCountFieldNumber = 4,
  };
  // repeated .exec.shared.SerializedField field = 2;
  int field_size() const;
  private:
  int _internal_field_size() const;

  public:
  void clear_field() ;
  ::exec::shared::SerializedField* mutable_field(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::shared::SerializedField >*
      mutable_field();
  private:
  const ::exec::shared::SerializedField& _internal_field(int index) const;
  ::exec::shared::SerializedField* _internal_add_field();
  public:
  const ::exec::shared::SerializedField& field(int index) const;
  ::exec::shared::SerializedField* add_field();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::shared::SerializedField >&
      field() const;
  // optional int32 record_count = 1;
  bool has_record_count() const;
  void clear_record_count() ;
  ::int32_t record_count() const;
  void set_record_count(::int32_t value);

  private:
  ::int32_t _internal_record_count() const;
  void _internal_set_record_count(::int32_t value);

  public:
  // optional bool carries_two_byte_selection_vector = 3;
  bool has_carries_two_byte_selection_vector() const;
  void clear_carries_two_byte_selection_vector() ;
  bool carries_two_byte_selection_vector() const;
  void set_carries_two_byte_selection_vector(bool value);

  private:
  bool _internal_carries_two_byte_selection_vector() const;
  void _internal_set_carries_two_byte_selection_vector(bool value);

  public:
  // optional int32 affected_rows_count = 4;
  bool has_affected_rows_count() const;
  void clear_affected_rows_count() ;
  ::int32_t affected_rows_count() const;
  void set_affected_rows_count(::int32_t value);

  private:
  ::int32_t _internal_affected_rows_count() const;
  void _internal_set_affected_rows_count(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:exec.shared.RecordBatchDef)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::shared::SerializedField > field_;
    ::int32_t record_count_;
    bool carries_two_byte_selection_vector_;
    ::int32_t affected_rows_count_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_UserBitShared_2eproto;
};// -------------------------------------------------------------------

class NamePart final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.shared.NamePart) */ {
 public:
  inline NamePart() : NamePart(nullptr) {}
  ~NamePart() override;
  explicit PROTOBUF_CONSTEXPR NamePart(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NamePart(const NamePart& from);
  NamePart(NamePart&& from) noexcept
    : NamePart() {
    *this = ::std::move(from);
  }

  inline NamePart& operator=(const NamePart& from) {
    CopyFrom(from);
    return *this;
  }
  inline NamePart& operator=(NamePart&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NamePart& default_instance() {
    return *internal_default_instance();
  }
  static inline const NamePart* internal_default_instance() {
    return reinterpret_cast<const NamePart*>(
               &_NamePart_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(NamePart& a, NamePart& b) {
    a.Swap(&b);
  }
  inline void Swap(NamePart* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NamePart* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NamePart* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NamePart>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NamePart& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NamePart& from) {
    NamePart::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NamePart* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.shared.NamePart";
  }
  protected:
  explicit NamePart(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Type = NamePart_Type;
  static constexpr Type NAME = NamePart_Type_NAME;
  static constexpr Type ARRAY = NamePart_Type_ARRAY;
  static inline bool Type_IsValid(int value) {
    return NamePart_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = NamePart_Type_Type_MIN;
  static constexpr Type Type_MAX = NamePart_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = NamePart_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Type_descriptor() {
    return NamePart_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return NamePart_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return NamePart_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kChildFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // optional string name = 2;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // optional .exec.shared.NamePart child = 3;
  bool has_child() const;
  void clear_child() ;
  const ::exec::shared::NamePart& child() const;
  PROTOBUF_NODISCARD ::exec::shared::NamePart* release_child();
  ::exec::shared::NamePart* mutable_child();
  void set_allocated_child(::exec::shared::NamePart* child);
  private:
  const ::exec::shared::NamePart& _internal_child() const;
  ::exec::shared::NamePart* _internal_mutable_child();
  public:
  void unsafe_arena_set_allocated_child(
      ::exec::shared::NamePart* child);
  ::exec::shared::NamePart* unsafe_arena_release_child();
  // optional .exec.shared.NamePart.Type type = 1;
  bool has_type() const;
  void clear_type() ;
  ::exec::shared::NamePart_Type type() const;
  void set_type(::exec::shared::NamePart_Type value);

  private:
  ::exec::shared::NamePart_Type _internal_type() const;
  void _internal_set_type(::exec::shared::NamePart_Type value);

  public:
  // @@protoc_insertion_point(class_scope:exec.shared.NamePart)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::exec::shared::NamePart* child_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_UserBitShared_2eproto;
};// -------------------------------------------------------------------

class SerializedField final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.shared.SerializedField) */ {
 public:
  inline SerializedField() : SerializedField(nullptr) {}
  ~SerializedField() override;
  explicit PROTOBUF_CONSTEXPR SerializedField(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SerializedField(const SerializedField& from);
  SerializedField(SerializedField&& from) noexcept
    : SerializedField() {
    *this = ::std::move(from);
  }

  inline SerializedField& operator=(const SerializedField& from) {
    CopyFrom(from);
    return *this;
  }
  inline SerializedField& operator=(SerializedField&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SerializedField& default_instance() {
    return *internal_default_instance();
  }
  static inline const SerializedField* internal_default_instance() {
    return reinterpret_cast<const SerializedField*>(
               &_SerializedField_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SerializedField& a, SerializedField& b) {
    a.Swap(&b);
  }
  inline void Swap(SerializedField* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SerializedField* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SerializedField* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SerializedField>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SerializedField& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SerializedField& from) {
    SerializedField::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SerializedField* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.shared.SerializedField";
  }
  protected:
  explicit SerializedField(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChildFieldNumber = 3,
    kMajorTypeFieldNumber = 1,
    kNamePartFieldNumber = 2,
    kValueCountFieldNumber = 4,
    kVarByteLengthFieldNumber = 5,
    kBufferLengthFieldNumber = 7,
  };
  // repeated .exec.shared.SerializedField child = 3;
  int child_size() const;
  private:
  int _internal_child_size() const;

  public:
  void clear_child() ;
  ::exec::shared::SerializedField* mutable_child(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::shared::SerializedField >*
      mutable_child();
  private:
  const ::exec::shared::SerializedField& _internal_child(int index) const;
  ::exec::shared::SerializedField* _internal_add_child();
  public:
  const ::exec::shared::SerializedField& child(int index) const;
  ::exec::shared::SerializedField* add_child();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::shared::SerializedField >&
      child() const;
  // optional .common.MajorType major_type = 1;
  bool has_major_type() const;
  void clear_major_type() ;
  const ::common::MajorType& major_type() const;
  PROTOBUF_NODISCARD ::common::MajorType* release_major_type();
  ::common::MajorType* mutable_major_type();
  void set_allocated_major_type(::common::MajorType* major_type);
  private:
  const ::common::MajorType& _internal_major_type() const;
  ::common::MajorType* _internal_mutable_major_type();
  public:
  void unsafe_arena_set_allocated_major_type(
      ::common::MajorType* major_type);
  ::common::MajorType* unsafe_arena_release_major_type();
  // optional .exec.shared.NamePart name_part = 2;
  bool has_name_part() const;
  void clear_name_part() ;
  const ::exec::shared::NamePart& name_part() const;
  PROTOBUF_NODISCARD ::exec::shared::NamePart* release_name_part();
  ::exec::shared::NamePart* mutable_name_part();
  void set_allocated_name_part(::exec::shared::NamePart* name_part);
  private:
  const ::exec::shared::NamePart& _internal_name_part() const;
  ::exec::shared::NamePart* _internal_mutable_name_part();
  public:
  void unsafe_arena_set_allocated_name_part(
      ::exec::shared::NamePart* name_part);
  ::exec::shared::NamePart* unsafe_arena_release_name_part();
  // optional int32 value_count = 4;
  bool has_value_count() const;
  void clear_value_count() ;
  ::int32_t value_count() const;
  void set_value_count(::int32_t value);

  private:
  ::int32_t _internal_value_count() const;
  void _internal_set_value_count(::int32_t value);

  public:
  // optional int32 var_byte_length = 5;
  bool has_var_byte_length() const;
  void clear_var_byte_length() ;
  ::int32_t var_byte_length() const;
  void set_var_byte_length(::int32_t value);

  private:
  ::int32_t _internal_var_byte_length() const;
  void _internal_set_var_byte_length(::int32_t value);

  public:
  // optional int32 buffer_length = 7;
  bool has_buffer_length() const;
  void clear_buffer_length() ;
  ::int32_t buffer_length() const;
  void set_buffer_length(::int32_t value);

  private:
  ::int32_t _internal_buffer_length() const;
  void _internal_set_buffer_length(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:exec.shared.SerializedField)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::shared::SerializedField > child_;
    ::common::MajorType* major_type_;
    ::exec::shared::NamePart* name_part_;
    ::int32_t value_count_;
    ::int32_t var_byte_length_;
    ::int32_t buffer_length_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_UserBitShared_2eproto;
};// -------------------------------------------------------------------

class NodeStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.shared.NodeStatus) */ {
 public:
  inline NodeStatus() : NodeStatus(nullptr) {}
  ~NodeStatus() override;
  explicit PROTOBUF_CONSTEXPR NodeStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodeStatus(const NodeStatus& from);
  NodeStatus(NodeStatus&& from) noexcept
    : NodeStatus() {
    *this = ::std::move(from);
  }

  inline NodeStatus& operator=(const NodeStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeStatus& operator=(NodeStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeStatus* internal_default_instance() {
    return reinterpret_cast<const NodeStatus*>(
               &_NodeStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(NodeStatus& a, NodeStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeStatus* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NodeStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NodeStatus& from) {
    NodeStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.shared.NodeStatus";
  }
  protected:
  explicit NodeStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMemoryFootprintFieldNumber = 2,
    kNodeIdFieldNumber = 1,
  };
  // optional int64 memory_footprint = 2;
  bool has_memory_footprint() const;
  void clear_memory_footprint() ;
  ::int64_t memory_footprint() const;
  void set_memory_footprint(::int64_t value);

  private:
  ::int64_t _internal_memory_footprint() const;
  void _internal_set_memory_footprint(::int64_t value);

  public:
  // optional int32 node_id = 1;
  bool has_node_id() const;
  void clear_node_id() ;
  ::int32_t node_id() const;
  void set_node_id(::int32_t value);

  private:
  ::int32_t _internal_node_id() const;
  void _internal_set_node_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:exec.shared.NodeStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::int64_t memory_footprint_;
    ::int32_t node_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_UserBitShared_2eproto;
};// -------------------------------------------------------------------

class QueryResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.shared.QueryResult) */ {
 public:
  inline QueryResult() : QueryResult(nullptr) {}
  ~QueryResult() override;
  explicit PROTOBUF_CONSTEXPR QueryResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryResult(const QueryResult& from);
  QueryResult(QueryResult&& from) noexcept
    : QueryResult() {
    *this = ::std::move(from);
  }

  inline QueryResult& operator=(const QueryResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryResult& operator=(QueryResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryResult* internal_default_instance() {
    return reinterpret_cast<const QueryResult*>(
               &_QueryResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(QueryResult& a, QueryResult& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryResult* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryResult& from) {
    QueryResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.shared.QueryResult";
  }
  protected:
  explicit QueryResult(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using QueryState = QueryResult_QueryState;
  static constexpr QueryState STARTING = QueryResult_QueryState_STARTING;
  static constexpr QueryState RUNNING = QueryResult_QueryState_RUNNING;
  static constexpr QueryState COMPLETED = QueryResult_QueryState_COMPLETED;
  static constexpr QueryState CANCELED = QueryResult_QueryState_CANCELED;
  static constexpr QueryState FAILED = QueryResult_QueryState_FAILED;
  static constexpr QueryState CANCELLATION_REQUESTED = QueryResult_QueryState_CANCELLATION_REQUESTED;
  static constexpr QueryState ENQUEUED = QueryResult_QueryState_ENQUEUED;
  static constexpr QueryState PREPARING = QueryResult_QueryState_PREPARING;
  static constexpr QueryState PLANNING = QueryResult_QueryState_PLANNING;
  static inline bool QueryState_IsValid(int value) {
    return QueryResult_QueryState_IsValid(value);
  }
  static constexpr QueryState QueryState_MIN = QueryResult_QueryState_QueryState_MIN;
  static constexpr QueryState QueryState_MAX = QueryResult_QueryState_QueryState_MAX;
  static constexpr int QueryState_ARRAYSIZE = QueryResult_QueryState_QueryState_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* QueryState_descriptor() {
    return QueryResult_QueryState_descriptor();
  }
  template <typename T>
  static inline const std::string& QueryState_Name(T value) {
    return QueryResult_QueryState_Name(value);
  }
  static inline bool QueryState_Parse(absl::string_view name, QueryState* value) {
    return QueryResult_QueryState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 3,
    kQueryIdFieldNumber = 2,
    kQueryStateFieldNumber = 1,
  };
  // repeated .exec.shared.DrillPBError error = 3;
  int error_size() const;
  private:
  int _internal_error_size() const;

  public:
  void clear_error() ;
  ::exec::shared::DrillPBError* mutable_error(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::shared::DrillPBError >*
      mutable_error();
  private:
  const ::exec::shared::DrillPBError& _internal_error(int index) const;
  ::exec::shared::DrillPBError* _internal_add_error();
  public:
  const ::exec::shared::DrillPBError& error(int index) const;
  ::exec::shared::DrillPBError* add_error();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::shared::DrillPBError >&
      error() const;
  // optional .exec.shared.QueryId query_id = 2;
  bool has_query_id() const;
  void clear_query_id() ;
  const ::exec::shared::QueryId& query_id() const;
  PROTOBUF_NODISCARD ::exec::shared::QueryId* release_query_id();
  ::exec::shared::QueryId* mutable_query_id();
  void set_allocated_query_id(::exec::shared::QueryId* query_id);
  private:
  const ::exec::shared::QueryId& _internal_query_id() const;
  ::exec::shared::QueryId* _internal_mutable_query_id();
  public:
  void unsafe_arena_set_allocated_query_id(
      ::exec::shared::QueryId* query_id);
  ::exec::shared::QueryId* unsafe_arena_release_query_id();
  // optional .exec.shared.QueryResult.QueryState query_state = 1;
  bool has_query_state() const;
  void clear_query_state() ;
  ::exec::shared::QueryResult_QueryState query_state() const;
  void set_query_state(::exec::shared::QueryResult_QueryState value);

  private:
  ::exec::shared::QueryResult_QueryState _internal_query_state() const;
  void _internal_set_query_state(::exec::shared::QueryResult_QueryState value);

  public:
  // @@protoc_insertion_point(class_scope:exec.shared.QueryResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::shared::DrillPBError > error_;
    ::exec::shared::QueryId* query_id_;
    int query_state_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_UserBitShared_2eproto;
};// -------------------------------------------------------------------

class QueryData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.shared.QueryData) */ {
 public:
  inline QueryData() : QueryData(nullptr) {}
  ~QueryData() override;
  explicit PROTOBUF_CONSTEXPR QueryData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryData(const QueryData& from);
  QueryData(QueryData&& from) noexcept
    : QueryData() {
    *this = ::std::move(from);
  }

  inline QueryData& operator=(const QueryData& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryData& operator=(QueryData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryData& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryData* internal_default_instance() {
    return reinterpret_cast<const QueryData*>(
               &_QueryData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(QueryData& a, QueryData& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryData& from) {
    QueryData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.shared.QueryData";
  }
  protected:
  explicit QueryData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQueryIdFieldNumber = 1,
    kDefFieldNumber = 3,
    kRowCountFieldNumber = 2,
    kAffectedRowsCountFieldNumber = 4,
  };
  // optional .exec.shared.QueryId query_id = 1;
  bool has_query_id() const;
  void clear_query_id() ;
  const ::exec::shared::QueryId& query_id() const;
  PROTOBUF_NODISCARD ::exec::shared::QueryId* release_query_id();
  ::exec::shared::QueryId* mutable_query_id();
  void set_allocated_query_id(::exec::shared::QueryId* query_id);
  private:
  const ::exec::shared::QueryId& _internal_query_id() const;
  ::exec::shared::QueryId* _internal_mutable_query_id();
  public:
  void unsafe_arena_set_allocated_query_id(
      ::exec::shared::QueryId* query_id);
  ::exec::shared::QueryId* unsafe_arena_release_query_id();
  // optional .exec.shared.RecordBatchDef def = 3;
  bool has_def() const;
  void clear_def() ;
  const ::exec::shared::RecordBatchDef& def() const;
  PROTOBUF_NODISCARD ::exec::shared::RecordBatchDef* release_def();
  ::exec::shared::RecordBatchDef* mutable_def();
  void set_allocated_def(::exec::shared::RecordBatchDef* def);
  private:
  const ::exec::shared::RecordBatchDef& _internal_def() const;
  ::exec::shared::RecordBatchDef* _internal_mutable_def();
  public:
  void unsafe_arena_set_allocated_def(
      ::exec::shared::RecordBatchDef* def);
  ::exec::shared::RecordBatchDef* unsafe_arena_release_def();
  // optional int32 row_count = 2;
  bool has_row_count() const;
  void clear_row_count() ;
  ::int32_t row_count() const;
  void set_row_count(::int32_t value);

  private:
  ::int32_t _internal_row_count() const;
  void _internal_set_row_count(::int32_t value);

  public:
  // optional int32 affected_rows_count = 4;
  bool has_affected_rows_count() const;
  void clear_affected_rows_count() ;
  ::int32_t affected_rows_count() const;
  void set_affected_rows_count(::int32_t value);

  private:
  ::int32_t _internal_affected_rows_count() const;
  void _internal_set_affected_rows_count(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:exec.shared.QueryData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::exec::shared::QueryId* query_id_;
    ::exec::shared::RecordBatchDef* def_;
    ::int32_t row_count_;
    ::int32_t affected_rows_count_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_UserBitShared_2eproto;
};// -------------------------------------------------------------------

class QueryInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.shared.QueryInfo) */ {
 public:
  inline QueryInfo() : QueryInfo(nullptr) {}
  ~QueryInfo() override;
  explicit PROTOBUF_CONSTEXPR QueryInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryInfo(const QueryInfo& from);
  QueryInfo(QueryInfo&& from) noexcept
    : QueryInfo() {
    *this = ::std::move(from);
  }

  inline QueryInfo& operator=(const QueryInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryInfo& operator=(QueryInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryInfo* internal_default_instance() {
    return reinterpret_cast<const QueryInfo*>(
               &_QueryInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(QueryInfo& a, QueryInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryInfo& from) {
    QueryInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.shared.QueryInfo";
  }
  protected:
  explicit QueryInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQueryFieldNumber = 1,
    kUserFieldNumber = 4,
    kOptionsJsonFieldNumber = 6,
    kQueueNameFieldNumber = 8,
    kForemanFieldNumber = 5,
    kStartFieldNumber = 2,
    kTotalCostFieldNumber = 7,
    kStateFieldNumber = 3,
  };
  // optional string query = 1;
  bool has_query() const;
  void clear_query() ;
  const std::string& query() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_query(Arg_&& arg, Args_... args);
  std::string* mutable_query();
  PROTOBUF_NODISCARD std::string* release_query();
  void set_allocated_query(std::string* ptr);

  private:
  const std::string& _internal_query() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_query(
      const std::string& value);
  std::string* _internal_mutable_query();

  public:
  // optional string user = 4 [default = "-"];
  bool has_user() const;
  void clear_user() ;
  const std::string& user() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_user(Arg_&& arg, Args_... args);
  std::string* mutable_user();
  PROTOBUF_NODISCARD std::string* release_user();
  void set_allocated_user(std::string* ptr);

  private:
  const std::string& _internal_user() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user(
      const std::string& value);
  std::string* _internal_mutable_user();

  public:
  // optional string options_json = 6;
  bool has_options_json() const;
  void clear_options_json() ;
  const std::string& options_json() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_options_json(Arg_&& arg, Args_... args);
  std::string* mutable_options_json();
  PROTOBUF_NODISCARD std::string* release_options_json();
  void set_allocated_options_json(std::string* ptr);

  private:
  const std::string& _internal_options_json() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_options_json(
      const std::string& value);
  std::string* _internal_mutable_options_json();

  public:
  // optional string queue_name = 8 [default = "-"];
  bool has_queue_name() const;
  void clear_queue_name() ;
  const std::string& queue_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_queue_name(Arg_&& arg, Args_... args);
  std::string* mutable_queue_name();
  PROTOBUF_NODISCARD std::string* release_queue_name();
  void set_allocated_queue_name(std::string* ptr);

  private:
  const std::string& _internal_queue_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_queue_name(
      const std::string& value);
  std::string* _internal_mutable_queue_name();

  public:
  // optional .exec.DrillbitEndpoint foreman = 5;
  bool has_foreman() const;
  void clear_foreman() ;
  const ::exec::DrillbitEndpoint& foreman() const;
  PROTOBUF_NODISCARD ::exec::DrillbitEndpoint* release_foreman();
  ::exec::DrillbitEndpoint* mutable_foreman();
  void set_allocated_foreman(::exec::DrillbitEndpoint* foreman);
  private:
  const ::exec::DrillbitEndpoint& _internal_foreman() const;
  ::exec::DrillbitEndpoint* _internal_mutable_foreman();
  public:
  void unsafe_arena_set_allocated_foreman(
      ::exec::DrillbitEndpoint* foreman);
  ::exec::DrillbitEndpoint* unsafe_arena_release_foreman();
  // optional int64 start = 2;
  bool has_start() const;
  void clear_start() ;
  ::int64_t start() const;
  void set_start(::int64_t value);

  private:
  ::int64_t _internal_start() const;
  void _internal_set_start(::int64_t value);

  public:
  // optional double total_cost = 7;
  bool has_total_cost() const;
  void clear_total_cost() ;
  double total_cost() const;
  void set_total_cost(double value);

  private:
  double _internal_total_cost() const;
  void _internal_set_total_cost(double value);

  public:
  // optional .exec.shared.QueryResult.QueryState state = 3;
  bool has_state() const;
  void clear_state() ;
  ::exec::shared::QueryResult_QueryState state() const;
  void set_state(::exec::shared::QueryResult_QueryState value);

  private:
  ::exec::shared::QueryResult_QueryState _internal_state() const;
  void _internal_set_state(::exec::shared::QueryResult_QueryState value);

  public:
  // @@protoc_insertion_point(class_scope:exec.shared.QueryInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr query_;
    static const ::PROTOBUF_NAMESPACE_ID::internal::LazyString _i_give_permission_to_break_this_code_default_user_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr options_json_;
    static const ::PROTOBUF_NAMESPACE_ID::internal::LazyString _i_give_permission_to_break_this_code_default_queue_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr queue_name_;
    ::exec::DrillbitEndpoint* foreman_;
    ::int64_t start_;
    double total_cost_;
    int state_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_UserBitShared_2eproto;
};// -------------------------------------------------------------------

class QueryProfile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.shared.QueryProfile) */ {
 public:
  inline QueryProfile() : QueryProfile(nullptr) {}
  ~QueryProfile() override;
  explicit PROTOBUF_CONSTEXPR QueryProfile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryProfile(const QueryProfile& from);
  QueryProfile(QueryProfile&& from) noexcept
    : QueryProfile() {
    *this = ::std::move(from);
  }

  inline QueryProfile& operator=(const QueryProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryProfile& operator=(QueryProfile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryProfile& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryProfile* internal_default_instance() {
    return reinterpret_cast<const QueryProfile*>(
               &_QueryProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(QueryProfile& a, QueryProfile& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryProfile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryProfile* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryProfile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryProfile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryProfile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryProfile& from) {
    QueryProfile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryProfile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.shared.QueryProfile";
  }
  protected:
  explicit QueryProfile(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFragmentProfileFieldNumber = 11,
    kQueryFieldNumber = 5,
    kPlanFieldNumber = 6,
    kUserFieldNumber = 12,
    kErrorFieldNumber = 13,
    kVerboseErrorFieldNumber = 14,
    kErrorIdFieldNumber = 15,
    kErrorNodeFieldNumber = 16,
    kOptionsJsonFieldNumber = 17,
    kQueueNameFieldNumber = 21,
    kQueryIdFieldNumber = 22,
    kIdFieldNumber = 1,
    kForemanFieldNumber = 7,
    kStartFieldNumber = 3,
    kEndFieldNumber = 4,
    kStateFieldNumber = 8,
    kTotalFragmentsFieldNumber = 9,
    kFinishedFragmentsFieldNumber = 10,
    kAutoLimitFieldNumber = 23,
    kPlanEndFieldNumber = 18,
    kQueueWaitEndFieldNumber = 19,
    kTotalCostFieldNumber = 20,
    kTypeFieldNumber = 2,
  };
  // repeated .exec.shared.MajorFragmentProfile fragment_profile = 11;
  int fragment_profile_size() const;
  private:
  int _internal_fragment_profile_size() const;

  public:
  void clear_fragment_profile() ;
  ::exec::shared::MajorFragmentProfile* mutable_fragment_profile(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::shared::MajorFragmentProfile >*
      mutable_fragment_profile();
  private:
  const ::exec::shared::MajorFragmentProfile& _internal_fragment_profile(int index) const;
  ::exec::shared::MajorFragmentProfile* _internal_add_fragment_profile();
  public:
  const ::exec::shared::MajorFragmentProfile& fragment_profile(int index) const;
  ::exec::shared::MajorFragmentProfile* add_fragment_profile();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::shared::MajorFragmentProfile >&
      fragment_profile() const;
  // optional string query = 5;
  bool has_query() const;
  void clear_query() ;
  const std::string& query() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_query(Arg_&& arg, Args_... args);
  std::string* mutable_query();
  PROTOBUF_NODISCARD std::string* release_query();
  void set_allocated_query(std::string* ptr);

  private:
  const std::string& _internal_query() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_query(
      const std::string& value);
  std::string* _internal_mutable_query();

  public:
  // optional string plan = 6;
  bool has_plan() const;
  void clear_plan() ;
  const std::string& plan() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_plan(Arg_&& arg, Args_... args);
  std::string* mutable_plan();
  PROTOBUF_NODISCARD std::string* release_plan();
  void set_allocated_plan(std::string* ptr);

  private:
  const std::string& _internal_plan() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_plan(
      const std::string& value);
  std::string* _internal_mutable_plan();

  public:
  // optional string user = 12 [default = "-"];
  bool has_user() const;
  void clear_user() ;
  const std::string& user() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_user(Arg_&& arg, Args_... args);
  std::string* mutable_user();
  PROTOBUF_NODISCARD std::string* release_user();
  void set_allocated_user(std::string* ptr);

  private:
  const std::string& _internal_user() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user(
      const std::string& value);
  std::string* _internal_mutable_user();

  public:
  // optional string error = 13;
  bool has_error() const;
  void clear_error() ;
  const std::string& error() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error(Arg_&& arg, Args_... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* ptr);

  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(
      const std::string& value);
  std::string* _internal_mutable_error();

  public:
  // optional string verboseError = 14;
  bool has_verboseerror() const;
  void clear_verboseerror() ;
  const std::string& verboseerror() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_verboseerror(Arg_&& arg, Args_... args);
  std::string* mutable_verboseerror();
  PROTOBUF_NODISCARD std::string* release_verboseerror();
  void set_allocated_verboseerror(std::string* ptr);

  private:
  const std::string& _internal_verboseerror() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_verboseerror(
      const std::string& value);
  std::string* _internal_mutable_verboseerror();

  public:
  // optional string error_id = 15;
  bool has_error_id() const;
  void clear_error_id() ;
  const std::string& error_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error_id(Arg_&& arg, Args_... args);
  std::string* mutable_error_id();
  PROTOBUF_NODISCARD std::string* release_error_id();
  void set_allocated_error_id(std::string* ptr);

  private:
  const std::string& _internal_error_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_id(
      const std::string& value);
  std::string* _internal_mutable_error_id();

  public:
  // optional string error_node = 16;
  bool has_error_node() const;
  void clear_error_node() ;
  const std::string& error_node() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error_node(Arg_&& arg, Args_... args);
  std::string* mutable_error_node();
  PROTOBUF_NODISCARD std::string* release_error_node();
  void set_allocated_error_node(std::string* ptr);

  private:
  const std::string& _internal_error_node() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_node(
      const std::string& value);
  std::string* _internal_mutable_error_node();

  public:
  // optional string options_json = 17;
  bool has_options_json() const;
  void clear_options_json() ;
  const std::string& options_json() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_options_json(Arg_&& arg, Args_... args);
  std::string* mutable_options_json();
  PROTOBUF_NODISCARD std::string* release_options_json();
  void set_allocated_options_json(std::string* ptr);

  private:
  const std::string& _internal_options_json() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_options_json(
      const std::string& value);
  std::string* _internal_mutable_options_json();

  public:
  // optional string queue_name = 21 [default = "-"];
  bool has_queue_name() const;
  void clear_queue_name() ;
  const std::string& queue_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_queue_name(Arg_&& arg, Args_... args);
  std::string* mutable_queue_name();
  PROTOBUF_NODISCARD std::string* release_queue_name();
  void set_allocated_queue_name(std::string* ptr);

  private:
  const std::string& _internal_queue_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_queue_name(
      const std::string& value);
  std::string* _internal_mutable_queue_name();

  public:
  // optional string queryId = 22;
  bool has_queryid() const;
  void clear_queryid() ;
  const std::string& queryid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_queryid(Arg_&& arg, Args_... args);
  std::string* mutable_queryid();
  PROTOBUF_NODISCARD std::string* release_queryid();
  void set_allocated_queryid(std::string* ptr);

  private:
  const std::string& _internal_queryid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_queryid(
      const std::string& value);
  std::string* _internal_mutable_queryid();

  public:
  // optional .exec.shared.QueryId id = 1;
  bool has_id() const;
  void clear_id() ;
  const ::exec::shared::QueryId& id() const;
  PROTOBUF_NODISCARD ::exec::shared::QueryId* release_id();
  ::exec::shared::QueryId* mutable_id();
  void set_allocated_id(::exec::shared::QueryId* id);
  private:
  const ::exec::shared::QueryId& _internal_id() const;
  ::exec::shared::QueryId* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::exec::shared::QueryId* id);
  ::exec::shared::QueryId* unsafe_arena_release_id();
  // optional .exec.DrillbitEndpoint foreman = 7;
  bool has_foreman() const;
  void clear_foreman() ;
  const ::exec::DrillbitEndpoint& foreman() const;
  PROTOBUF_NODISCARD ::exec::DrillbitEndpoint* release_foreman();
  ::exec::DrillbitEndpoint* mutable_foreman();
  void set_allocated_foreman(::exec::DrillbitEndpoint* foreman);
  private:
  const ::exec::DrillbitEndpoint& _internal_foreman() const;
  ::exec::DrillbitEndpoint* _internal_mutable_foreman();
  public:
  void unsafe_arena_set_allocated_foreman(
      ::exec::DrillbitEndpoint* foreman);
  ::exec::DrillbitEndpoint* unsafe_arena_release_foreman();
  // optional int64 start = 3;
  bool has_start() const;
  void clear_start() ;
  ::int64_t start() const;
  void set_start(::int64_t value);

  private:
  ::int64_t _internal_start() const;
  void _internal_set_start(::int64_t value);

  public:
  // optional int64 end = 4;
  bool has_end() const;
  void clear_end() ;
  ::int64_t end() const;
  void set_end(::int64_t value);

  private:
  ::int64_t _internal_end() const;
  void _internal_set_end(::int64_t value);

  public:
  // optional .exec.shared.QueryResult.QueryState state = 8;
  bool has_state() const;
  void clear_state() ;
  ::exec::shared::QueryResult_QueryState state() const;
  void set_state(::exec::shared::QueryResult_QueryState value);

  private:
  ::exec::shared::QueryResult_QueryState _internal_state() const;
  void _internal_set_state(::exec::shared::QueryResult_QueryState value);

  public:
  // optional int32 total_fragments = 9;
  bool has_total_fragments() const;
  void clear_total_fragments() ;
  ::int32_t total_fragments() const;
  void set_total_fragments(::int32_t value);

  private:
  ::int32_t _internal_total_fragments() const;
  void _internal_set_total_fragments(::int32_t value);

  public:
  // optional int32 finished_fragments = 10;
  bool has_finished_fragments() const;
  void clear_finished_fragments() ;
  ::int32_t finished_fragments() const;
  void set_finished_fragments(::int32_t value);

  private:
  ::int32_t _internal_finished_fragments() const;
  void _internal_set_finished_fragments(::int32_t value);

  public:
  // optional int32 autoLimit = 23;
  bool has_autolimit() const;
  void clear_autolimit() ;
  ::int32_t autolimit() const;
  void set_autolimit(::int32_t value);

  private:
  ::int32_t _internal_autolimit() const;
  void _internal_set_autolimit(::int32_t value);

  public:
  // optional int64 planEnd = 18;
  bool has_planend() const;
  void clear_planend() ;
  ::int64_t planend() const;
  void set_planend(::int64_t value);

  private:
  ::int64_t _internal_planend() const;
  void _internal_set_planend(::int64_t value);

  public:
  // optional int64 queueWaitEnd = 19;
  bool has_queuewaitend() const;
  void clear_queuewaitend() ;
  ::int64_t queuewaitend() const;
  void set_queuewaitend(::int64_t value);

  private:
  ::int64_t _internal_queuewaitend() const;
  void _internal_set_queuewaitend(::int64_t value);

  public:
  // optional double total_cost = 20;
  bool has_total_cost() const;
  void clear_total_cost() ;
  double total_cost() const;
  void set_total_cost(double value);

  private:
  double _internal_total_cost() const;
  void _internal_set_total_cost(double value);

  public:
  // optional .exec.shared.QueryType type = 2;
  bool has_type() const;
  void clear_type() ;
  ::exec::shared::QueryType type() const;
  void set_type(::exec::shared::QueryType value);

  private:
  ::exec::shared::QueryType _internal_type() const;
  void _internal_set_type(::exec::shared::QueryType value);

  public:
  // @@protoc_insertion_point(class_scope:exec.shared.QueryProfile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::shared::MajorFragmentProfile > fragment_profile_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr query_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr plan_;
    static const ::PROTOBUF_NAMESPACE_ID::internal::LazyString _i_give_permission_to_break_this_code_default_user_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr verboseerror_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_node_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr options_json_;
    static const ::PROTOBUF_NAMESPACE_ID::internal::LazyString _i_give_permission_to_break_this_code_default_queue_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr queue_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr queryid_;
    ::exec::shared::QueryId* id_;
    ::exec::DrillbitEndpoint* foreman_;
    ::int64_t start_;
    ::int64_t end_;
    int state_;
    ::int32_t total_fragments_;
    ::int32_t finished_fragments_;
    ::int32_t autolimit_;
    ::int64_t planend_;
    ::int64_t queuewaitend_;
    double total_cost_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_UserBitShared_2eproto;
};// -------------------------------------------------------------------

class MajorFragmentProfile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.shared.MajorFragmentProfile) */ {
 public:
  inline MajorFragmentProfile() : MajorFragmentProfile(nullptr) {}
  ~MajorFragmentProfile() override;
  explicit PROTOBUF_CONSTEXPR MajorFragmentProfile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MajorFragmentProfile(const MajorFragmentProfile& from);
  MajorFragmentProfile(MajorFragmentProfile&& from) noexcept
    : MajorFragmentProfile() {
    *this = ::std::move(from);
  }

  inline MajorFragmentProfile& operator=(const MajorFragmentProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline MajorFragmentProfile& operator=(MajorFragmentProfile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MajorFragmentProfile& default_instance() {
    return *internal_default_instance();
  }
  static inline const MajorFragmentProfile* internal_default_instance() {
    return reinterpret_cast<const MajorFragmentProfile*>(
               &_MajorFragmentProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(MajorFragmentProfile& a, MajorFragmentProfile& b) {
    a.Swap(&b);
  }
  inline void Swap(MajorFragmentProfile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MajorFragmentProfile* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MajorFragmentProfile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MajorFragmentProfile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MajorFragmentProfile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MajorFragmentProfile& from) {
    MajorFragmentProfile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MajorFragmentProfile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.shared.MajorFragmentProfile";
  }
  protected:
  explicit MajorFragmentProfile(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinorFragmentProfileFieldNumber = 2,
    kMajorFragmentIdFieldNumber = 1,
  };
  // repeated .exec.shared.MinorFragmentProfile minor_fragment_profile = 2;
  int minor_fragment_profile_size() const;
  private:
  int _internal_minor_fragment_profile_size() const;

  public:
  void clear_minor_fragment_profile() ;
  ::exec::shared::MinorFragmentProfile* mutable_minor_fragment_profile(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::shared::MinorFragmentProfile >*
      mutable_minor_fragment_profile();
  private:
  const ::exec::shared::MinorFragmentProfile& _internal_minor_fragment_profile(int index) const;
  ::exec::shared::MinorFragmentProfile* _internal_add_minor_fragment_profile();
  public:
  const ::exec::shared::MinorFragmentProfile& minor_fragment_profile(int index) const;
  ::exec::shared::MinorFragmentProfile* add_minor_fragment_profile();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::shared::MinorFragmentProfile >&
      minor_fragment_profile() const;
  // optional int32 major_fragment_id = 1;
  bool has_major_fragment_id() const;
  void clear_major_fragment_id() ;
  ::int32_t major_fragment_id() const;
  void set_major_fragment_id(::int32_t value);

  private:
  ::int32_t _internal_major_fragment_id() const;
  void _internal_set_major_fragment_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:exec.shared.MajorFragmentProfile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::shared::MinorFragmentProfile > minor_fragment_profile_;
    ::int32_t major_fragment_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_UserBitShared_2eproto;
};// -------------------------------------------------------------------

class MinorFragmentProfile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.shared.MinorFragmentProfile) */ {
 public:
  inline MinorFragmentProfile() : MinorFragmentProfile(nullptr) {}
  ~MinorFragmentProfile() override;
  explicit PROTOBUF_CONSTEXPR MinorFragmentProfile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MinorFragmentProfile(const MinorFragmentProfile& from);
  MinorFragmentProfile(MinorFragmentProfile&& from) noexcept
    : MinorFragmentProfile() {
    *this = ::std::move(from);
  }

  inline MinorFragmentProfile& operator=(const MinorFragmentProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline MinorFragmentProfile& operator=(MinorFragmentProfile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MinorFragmentProfile& default_instance() {
    return *internal_default_instance();
  }
  static inline const MinorFragmentProfile* internal_default_instance() {
    return reinterpret_cast<const MinorFragmentProfile*>(
               &_MinorFragmentProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(MinorFragmentProfile& a, MinorFragmentProfile& b) {
    a.Swap(&b);
  }
  inline void Swap(MinorFragmentProfile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MinorFragmentProfile* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MinorFragmentProfile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MinorFragmentProfile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MinorFragmentProfile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MinorFragmentProfile& from) {
    MinorFragmentProfile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MinorFragmentProfile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.shared.MinorFragmentProfile";
  }
  protected:
  explicit MinorFragmentProfile(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOperatorProfileFieldNumber = 4,
    kErrorFieldNumber = 2,
    kEndpointFieldNumber = 9,
    kStateFieldNumber = 1,
    kMinorFragmentIdFieldNumber = 3,
    kStartTimeFieldNumber = 5,
    kEndTimeFieldNumber = 6,
    kMemoryUsedFieldNumber = 7,
    kMaxMemoryUsedFieldNumber = 8,
    kLastUpdateFieldNumber = 10,
    kLastProgressFieldNumber = 11,
  };
  // repeated .exec.shared.OperatorProfile operator_profile = 4;
  int operator_profile_size() const;
  private:
  int _internal_operator_profile_size() const;

  public:
  void clear_operator_profile() ;
  ::exec::shared::OperatorProfile* mutable_operator_profile(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::shared::OperatorProfile >*
      mutable_operator_profile();
  private:
  const ::exec::shared::OperatorProfile& _internal_operator_profile(int index) const;
  ::exec::shared::OperatorProfile* _internal_add_operator_profile();
  public:
  const ::exec::shared::OperatorProfile& operator_profile(int index) const;
  ::exec::shared::OperatorProfile* add_operator_profile();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::shared::OperatorProfile >&
      operator_profile() const;
  // optional .exec.shared.DrillPBError error = 2;
  bool has_error() const;
  void clear_error() ;
  const ::exec::shared::DrillPBError& error() const;
  PROTOBUF_NODISCARD ::exec::shared::DrillPBError* release_error();
  ::exec::shared::DrillPBError* mutable_error();
  void set_allocated_error(::exec::shared::DrillPBError* error);
  private:
  const ::exec::shared::DrillPBError& _internal_error() const;
  ::exec::shared::DrillPBError* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::exec::shared::DrillPBError* error);
  ::exec::shared::DrillPBError* unsafe_arena_release_error();
  // optional .exec.DrillbitEndpoint endpoint = 9;
  bool has_endpoint() const;
  void clear_endpoint() ;
  const ::exec::DrillbitEndpoint& endpoint() const;
  PROTOBUF_NODISCARD ::exec::DrillbitEndpoint* release_endpoint();
  ::exec::DrillbitEndpoint* mutable_endpoint();
  void set_allocated_endpoint(::exec::DrillbitEndpoint* endpoint);
  private:
  const ::exec::DrillbitEndpoint& _internal_endpoint() const;
  ::exec::DrillbitEndpoint* _internal_mutable_endpoint();
  public:
  void unsafe_arena_set_allocated_endpoint(
      ::exec::DrillbitEndpoint* endpoint);
  ::exec::DrillbitEndpoint* unsafe_arena_release_endpoint();
  // optional .exec.shared.FragmentState state = 1;
  bool has_state() const;
  void clear_state() ;
  ::exec::shared::FragmentState state() const;
  void set_state(::exec::shared::FragmentState value);

  private:
  ::exec::shared::FragmentState _internal_state() const;
  void _internal_set_state(::exec::shared::FragmentState value);

  public:
  // optional int32 minor_fragment_id = 3;
  bool has_minor_fragment_id() const;
  void clear_minor_fragment_id() ;
  ::int32_t minor_fragment_id() const;
  void set_minor_fragment_id(::int32_t value);

  private:
  ::int32_t _internal_minor_fragment_id() const;
  void _internal_set_minor_fragment_id(::int32_t value);

  public:
  // optional int64 start_time = 5;
  bool has_start_time() const;
  void clear_start_time() ;
  ::int64_t start_time() const;
  void set_start_time(::int64_t value);

  private:
  ::int64_t _internal_start_time() const;
  void _internal_set_start_time(::int64_t value);

  public:
  // optional int64 end_time = 6;
  bool has_end_time() const;
  void clear_end_time() ;
  ::int64_t end_time() const;
  void set_end_time(::int64_t value);

  private:
  ::int64_t _internal_end_time() const;
  void _internal_set_end_time(::int64_t value);

  public:
  // optional int64 memory_used = 7;
  bool has_memory_used() const;
  void clear_memory_used() ;
  ::int64_t memory_used() const;
  void set_memory_used(::int64_t value);

  private:
  ::int64_t _internal_memory_used() const;
  void _internal_set_memory_used(::int64_t value);

  public:
  // optional int64 max_memory_used = 8;
  bool has_max_memory_used() const;
  void clear_max_memory_used() ;
  ::int64_t max_memory_used() const;
  void set_max_memory_used(::int64_t value);

  private:
  ::int64_t _internal_max_memory_used() const;
  void _internal_set_max_memory_used(::int64_t value);

  public:
  // optional int64 last_update = 10;
  bool has_last_update() const;
  void clear_last_update() ;
  ::int64_t last_update() const;
  void set_last_update(::int64_t value);

  private:
  ::int64_t _internal_last_update() const;
  void _internal_set_last_update(::int64_t value);

  public:
  // optional int64 last_progress = 11;
  bool has_last_progress() const;
  void clear_last_progress() ;
  ::int64_t last_progress() const;
  void set_last_progress(::int64_t value);

  private:
  ::int64_t _internal_last_progress() const;
  void _internal_set_last_progress(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:exec.shared.MinorFragmentProfile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::shared::OperatorProfile > operator_profile_;
    ::exec::shared::DrillPBError* error_;
    ::exec::DrillbitEndpoint* endpoint_;
    int state_;
    ::int32_t minor_fragment_id_;
    ::int64_t start_time_;
    ::int64_t end_time_;
    ::int64_t memory_used_;
    ::int64_t max_memory_used_;
    ::int64_t last_update_;
    ::int64_t last_progress_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_UserBitShared_2eproto;
};// -------------------------------------------------------------------

class OperatorProfile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.shared.OperatorProfile) */ {
 public:
  inline OperatorProfile() : OperatorProfile(nullptr) {}
  ~OperatorProfile() override;
  explicit PROTOBUF_CONSTEXPR OperatorProfile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OperatorProfile(const OperatorProfile& from);
  OperatorProfile(OperatorProfile&& from) noexcept
    : OperatorProfile() {
    *this = ::std::move(from);
  }

  inline OperatorProfile& operator=(const OperatorProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline OperatorProfile& operator=(OperatorProfile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OperatorProfile& default_instance() {
    return *internal_default_instance();
  }
  static inline const OperatorProfile* internal_default_instance() {
    return reinterpret_cast<const OperatorProfile*>(
               &_OperatorProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(OperatorProfile& a, OperatorProfile& b) {
    a.Swap(&b);
  }
  inline void Swap(OperatorProfile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OperatorProfile* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OperatorProfile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OperatorProfile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OperatorProfile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OperatorProfile& from) {
    OperatorProfile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OperatorProfile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.shared.OperatorProfile";
  }
  protected:
  explicit OperatorProfile(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInputProfileFieldNumber = 1,
    kMetricFieldNumber = 8,
    kOperatorTypeNameFieldNumber = 10,
    kOperatorIdFieldNumber = 3,
    kOperatorTypeFieldNumber = 4,
    kSetupNanosFieldNumber = 5,
    kProcessNanosFieldNumber = 6,
    kPeakLocalMemoryAllocatedFieldNumber = 7,
    kWaitNanosFieldNumber = 9,
  };
  // repeated .exec.shared.StreamProfile input_profile = 1;
  int input_profile_size() const;
  private:
  int _internal_input_profile_size() const;

  public:
  void clear_input_profile() ;
  ::exec::shared::StreamProfile* mutable_input_profile(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::shared::StreamProfile >*
      mutable_input_profile();
  private:
  const ::exec::shared::StreamProfile& _internal_input_profile(int index) const;
  ::exec::shared::StreamProfile* _internal_add_input_profile();
  public:
  const ::exec::shared::StreamProfile& input_profile(int index) const;
  ::exec::shared::StreamProfile* add_input_profile();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::shared::StreamProfile >&
      input_profile() const;
  // repeated .exec.shared.MetricValue metric = 8;
  int metric_size() const;
  private:
  int _internal_metric_size() const;

  public:
  void clear_metric() ;
  ::exec::shared::MetricValue* mutable_metric(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::shared::MetricValue >*
      mutable_metric();
  private:
  const ::exec::shared::MetricValue& _internal_metric(int index) const;
  ::exec::shared::MetricValue* _internal_add_metric();
  public:
  const ::exec::shared::MetricValue& metric(int index) const;
  ::exec::shared::MetricValue* add_metric();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::shared::MetricValue >&
      metric() const;
  // optional string operator_type_name = 10;
  bool has_operator_type_name() const;
  void clear_operator_type_name() ;
  const std::string& operator_type_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_operator_type_name(Arg_&& arg, Args_... args);
  std::string* mutable_operator_type_name();
  PROTOBUF_NODISCARD std::string* release_operator_type_name();
  void set_allocated_operator_type_name(std::string* ptr);

  private:
  const std::string& _internal_operator_type_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operator_type_name(
      const std::string& value);
  std::string* _internal_mutable_operator_type_name();

  public:
  // optional int32 operator_id = 3;
  bool has_operator_id() const;
  void clear_operator_id() ;
  ::int32_t operator_id() const;
  void set_operator_id(::int32_t value);

  private:
  ::int32_t _internal_operator_id() const;
  void _internal_set_operator_id(::int32_t value);

  public:
  // optional int32 operator_type = 4 [deprecated = true];
  PROTOBUF_DEPRECATED  bool has_operator_type() const;
  PROTOBUF_DEPRECATED  void clear_operator_type() ;
  PROTOBUF_DEPRECATED ::int32_t operator_type() const;
  PROTOBUF_DEPRECATED void set_operator_type(::int32_t value);

  private:
  ::int32_t _internal_operator_type() const;
  void _internal_set_operator_type(::int32_t value);

  public:
  // optional int64 setup_nanos = 5;
  bool has_setup_nanos() const;
  void clear_setup_nanos() ;
  ::int64_t setup_nanos() const;
  void set_setup_nanos(::int64_t value);

  private:
  ::int64_t _internal_setup_nanos() const;
  void _internal_set_setup_nanos(::int64_t value);

  public:
  // optional int64 process_nanos = 6;
  bool has_process_nanos() const;
  void clear_process_nanos() ;
  ::int64_t process_nanos() const;
  void set_process_nanos(::int64_t value);

  private:
  ::int64_t _internal_process_nanos() const;
  void _internal_set_process_nanos(::int64_t value);

  public:
  // optional int64 peak_local_memory_allocated = 7;
  bool has_peak_local_memory_allocated() const;
  void clear_peak_local_memory_allocated() ;
  ::int64_t peak_local_memory_allocated() const;
  void set_peak_local_memory_allocated(::int64_t value);

  private:
  ::int64_t _internal_peak_local_memory_allocated() const;
  void _internal_set_peak_local_memory_allocated(::int64_t value);

  public:
  // optional int64 wait_nanos = 9;
  bool has_wait_nanos() const;
  void clear_wait_nanos() ;
  ::int64_t wait_nanos() const;
  void set_wait_nanos(::int64_t value);

  private:
  ::int64_t _internal_wait_nanos() const;
  void _internal_set_wait_nanos(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:exec.shared.OperatorProfile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::shared::StreamProfile > input_profile_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::shared::MetricValue > metric_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr operator_type_name_;
    ::int32_t operator_id_;
    ::int32_t operator_type_;
    ::int64_t setup_nanos_;
    ::int64_t process_nanos_;
    ::int64_t peak_local_memory_allocated_;
    ::int64_t wait_nanos_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_UserBitShared_2eproto;
};// -------------------------------------------------------------------

class StreamProfile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.shared.StreamProfile) */ {
 public:
  inline StreamProfile() : StreamProfile(nullptr) {}
  ~StreamProfile() override;
  explicit PROTOBUF_CONSTEXPR StreamProfile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamProfile(const StreamProfile& from);
  StreamProfile(StreamProfile&& from) noexcept
    : StreamProfile() {
    *this = ::std::move(from);
  }

  inline StreamProfile& operator=(const StreamProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamProfile& operator=(StreamProfile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamProfile& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamProfile* internal_default_instance() {
    return reinterpret_cast<const StreamProfile*>(
               &_StreamProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(StreamProfile& a, StreamProfile& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamProfile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamProfile* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamProfile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamProfile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StreamProfile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StreamProfile& from) {
    StreamProfile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamProfile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.shared.StreamProfile";
  }
  protected:
  explicit StreamProfile(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRecordsFieldNumber = 1,
    kBatchesFieldNumber = 2,
    kSchemasFieldNumber = 3,
  };
  // optional int64 records = 1;
  bool has_records() const;
  void clear_records() ;
  ::int64_t records() const;
  void set_records(::int64_t value);

  private:
  ::int64_t _internal_records() const;
  void _internal_set_records(::int64_t value);

  public:
  // optional int64 batches = 2;
  bool has_batches() const;
  void clear_batches() ;
  ::int64_t batches() const;
  void set_batches(::int64_t value);

  private:
  ::int64_t _internal_batches() const;
  void _internal_set_batches(::int64_t value);

  public:
  // optional int64 schemas = 3;
  bool has_schemas() const;
  void clear_schemas() ;
  ::int64_t schemas() const;
  void set_schemas(::int64_t value);

  private:
  ::int64_t _internal_schemas() const;
  void _internal_set_schemas(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:exec.shared.StreamProfile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::int64_t records_;
    ::int64_t batches_;
    ::int64_t schemas_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_UserBitShared_2eproto;
};// -------------------------------------------------------------------

class MetricValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.shared.MetricValue) */ {
 public:
  inline MetricValue() : MetricValue(nullptr) {}
  ~MetricValue() override;
  explicit PROTOBUF_CONSTEXPR MetricValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MetricValue(const MetricValue& from);
  MetricValue(MetricValue&& from) noexcept
    : MetricValue() {
    *this = ::std::move(from);
  }

  inline MetricValue& operator=(const MetricValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline MetricValue& operator=(MetricValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MetricValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const MetricValue* internal_default_instance() {
    return reinterpret_cast<const MetricValue*>(
               &_MetricValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(MetricValue& a, MetricValue& b) {
    a.Swap(&b);
  }
  inline void Swap(MetricValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MetricValue* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MetricValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MetricValue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MetricValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MetricValue& from) {
    MetricValue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MetricValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.shared.MetricValue";
  }
  protected:
  explicit MetricValue(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLongValueFieldNumber = 2,
    kDoubleValueFieldNumber = 3,
    kMetricIdFieldNumber = 1,
  };
  // optional int64 long_value = 2;
  bool has_long_value() const;
  void clear_long_value() ;
  ::int64_t long_value() const;
  void set_long_value(::int64_t value);

  private:
  ::int64_t _internal_long_value() const;
  void _internal_set_long_value(::int64_t value);

  public:
  // optional double double_value = 3;
  bool has_double_value() const;
  void clear_double_value() ;
  double double_value() const;
  void set_double_value(double value);

  private:
  double _internal_double_value() const;
  void _internal_set_double_value(double value);

  public:
  // optional int32 metric_id = 1;
  bool has_metric_id() const;
  void clear_metric_id() ;
  ::int32_t metric_id() const;
  void set_metric_id(::int32_t value);

  private:
  ::int32_t _internal_metric_id() const;
  void _internal_set_metric_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:exec.shared.MetricValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::int64_t long_value_;
    double double_value_;
    ::int32_t metric_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_UserBitShared_2eproto;
};// -------------------------------------------------------------------

class Registry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.shared.Registry) */ {
 public:
  inline Registry() : Registry(nullptr) {}
  ~Registry() override;
  explicit PROTOBUF_CONSTEXPR Registry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Registry(const Registry& from);
  Registry(Registry&& from) noexcept
    : Registry() {
    *this = ::std::move(from);
  }

  inline Registry& operator=(const Registry& from) {
    CopyFrom(from);
    return *this;
  }
  inline Registry& operator=(Registry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Registry& default_instance() {
    return *internal_default_instance();
  }
  static inline const Registry* internal_default_instance() {
    return reinterpret_cast<const Registry*>(
               &_Registry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(Registry& a, Registry& b) {
    a.Swap(&b);
  }
  inline void Swap(Registry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Registry* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Registry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Registry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Registry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Registry& from) {
    Registry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Registry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.shared.Registry";
  }
  protected:
  explicit Registry(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJarFieldNumber = 1,
  };
  // repeated .exec.shared.Jar jar = 1;
  int jar_size() const;
  private:
  int _internal_jar_size() const;

  public:
  void clear_jar() ;
  ::exec::shared::Jar* mutable_jar(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::shared::Jar >*
      mutable_jar();
  private:
  const ::exec::shared::Jar& _internal_jar(int index) const;
  ::exec::shared::Jar* _internal_add_jar();
  public:
  const ::exec::shared::Jar& jar(int index) const;
  ::exec::shared::Jar* add_jar();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::shared::Jar >&
      jar() const;
  // @@protoc_insertion_point(class_scope:exec.shared.Registry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::shared::Jar > jar_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_UserBitShared_2eproto;
};// -------------------------------------------------------------------

class Jar final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.shared.Jar) */ {
 public:
  inline Jar() : Jar(nullptr) {}
  ~Jar() override;
  explicit PROTOBUF_CONSTEXPR Jar(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Jar(const Jar& from);
  Jar(Jar&& from) noexcept
    : Jar() {
    *this = ::std::move(from);
  }

  inline Jar& operator=(const Jar& from) {
    CopyFrom(from);
    return *this;
  }
  inline Jar& operator=(Jar&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Jar& default_instance() {
    return *internal_default_instance();
  }
  static inline const Jar* internal_default_instance() {
    return reinterpret_cast<const Jar*>(
               &_Jar_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(Jar& a, Jar& b) {
    a.Swap(&b);
  }
  inline void Swap(Jar* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Jar* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Jar* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Jar>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Jar& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Jar& from) {
    Jar::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Jar* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.shared.Jar";
  }
  protected:
  explicit Jar(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFunctionSignatureFieldNumber = 2,
    kNameFieldNumber = 1,
  };
  // repeated string function_signature = 2;
  int function_signature_size() const;
  private:
  int _internal_function_signature_size() const;

  public:
  void clear_function_signature() ;
  const std::string& function_signature(int index) const;
  std::string* mutable_function_signature(int index);
  void set_function_signature(int index, const std::string& value);
  void set_function_signature(int index, std::string&& value);
  void set_function_signature(int index, const char* value);
  void set_function_signature(int index, const char* value, std::size_t size);
  void set_function_signature(int index, absl::string_view value);
  std::string* add_function_signature();
  void add_function_signature(const std::string& value);
  void add_function_signature(std::string&& value);
  void add_function_signature(const char* value);
  void add_function_signature(const char* value, std::size_t size);
  void add_function_signature(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& function_signature() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_function_signature();

  private:
  const std::string& _internal_function_signature(int index) const;
  std::string* _internal_add_function_signature();

  public:
  // optional string name = 1;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:exec.shared.Jar)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> function_signature_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_UserBitShared_2eproto;
};// -------------------------------------------------------------------

class SaslMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.shared.SaslMessage) */ {
 public:
  inline SaslMessage() : SaslMessage(nullptr) {}
  ~SaslMessage() override;
  explicit PROTOBUF_CONSTEXPR SaslMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SaslMessage(const SaslMessage& from);
  SaslMessage(SaslMessage&& from) noexcept
    : SaslMessage() {
    *this = ::std::move(from);
  }

  inline SaslMessage& operator=(const SaslMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline SaslMessage& operator=(SaslMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SaslMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const SaslMessage* internal_default_instance() {
    return reinterpret_cast<const SaslMessage*>(
               &_SaslMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(SaslMessage& a, SaslMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(SaslMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SaslMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SaslMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SaslMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SaslMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SaslMessage& from) {
    SaslMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SaslMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.shared.SaslMessage";
  }
  protected:
  explicit SaslMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMechanismFieldNumber = 1,
    kDataFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  // optional string mechanism = 1;
  bool has_mechanism() const;
  void clear_mechanism() ;
  const std::string& mechanism() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mechanism(Arg_&& arg, Args_... args);
  std::string* mutable_mechanism();
  PROTOBUF_NODISCARD std::string* release_mechanism();
  void set_allocated_mechanism(std::string* ptr);

  private:
  const std::string& _internal_mechanism() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mechanism(
      const std::string& value);
  std::string* _internal_mutable_mechanism();

  public:
  // optional bytes data = 2;
  bool has_data() const;
  void clear_data() ;
  const std::string& data() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data(Arg_&& arg, Args_... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* ptr);

  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(
      const std::string& value);
  std::string* _internal_mutable_data();

  public:
  // optional .exec.shared.SaslStatus status = 3;
  bool has_status() const;
  void clear_status() ;
  ::exec::shared::SaslStatus status() const;
  void set_status(::exec::shared::SaslStatus value);

  private:
  ::exec::shared::SaslStatus _internal_status() const;
  void _internal_set_status(::exec::shared::SaslStatus value);

  public:
  // @@protoc_insertion_point(class_scope:exec.shared.SaslMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mechanism_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    int status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_UserBitShared_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// UserCredentials

// optional string user_name = 1;
inline bool UserCredentials::has_user_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UserCredentials::clear_user_name() {
  _impl_.user_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UserCredentials::user_name() const {
  // @@protoc_insertion_point(field_get:exec.shared.UserCredentials.user_name)
  return _internal_user_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserCredentials::set_user_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.user_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.shared.UserCredentials.user_name)
}
inline std::string* UserCredentials::mutable_user_name() {
  std::string* _s = _internal_mutable_user_name();
  // @@protoc_insertion_point(field_mutable:exec.shared.UserCredentials.user_name)
  return _s;
}
inline const std::string& UserCredentials::_internal_user_name() const {
  return _impl_.user_name_.Get();
}
inline void UserCredentials::_internal_set_user_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.user_name_.Set(value, GetArenaForAllocation());
}
inline std::string* UserCredentials::_internal_mutable_user_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.user_name_.Mutable( GetArenaForAllocation());
}
inline std::string* UserCredentials::release_user_name() {
  // @@protoc_insertion_point(field_release:exec.shared.UserCredentials.user_name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.user_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.user_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void UserCredentials::set_allocated_user_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.user_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.user_name_.IsDefault()) {
          _impl_.user_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.shared.UserCredentials.user_name)
}

// -------------------------------------------------------------------

// QueryId

// optional sfixed64 part1 = 1;
inline bool QueryId::has_part1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void QueryId::clear_part1() {
  _impl_.part1_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t QueryId::part1() const {
  // @@protoc_insertion_point(field_get:exec.shared.QueryId.part1)
  return _internal_part1();
}
inline void QueryId::set_part1(::int64_t value) {
  _internal_set_part1(value);
  // @@protoc_insertion_point(field_set:exec.shared.QueryId.part1)
}
inline ::int64_t QueryId::_internal_part1() const {
  return _impl_.part1_;
}
inline void QueryId::_internal_set_part1(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.part1_ = value;
}

// optional sfixed64 part2 = 2;
inline bool QueryId::has_part2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void QueryId::clear_part2() {
  _impl_.part2_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int64_t QueryId::part2() const {
  // @@protoc_insertion_point(field_get:exec.shared.QueryId.part2)
  return _internal_part2();
}
inline void QueryId::set_part2(::int64_t value) {
  _internal_set_part2(value);
  // @@protoc_insertion_point(field_set:exec.shared.QueryId.part2)
}
inline ::int64_t QueryId::_internal_part2() const {
  return _impl_.part2_;
}
inline void QueryId::_internal_set_part2(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.part2_ = value;
}

// -------------------------------------------------------------------

// DrillPBError

// optional string error_id = 1;
inline bool DrillPBError::has_error_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void DrillPBError::clear_error_id() {
  _impl_.error_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DrillPBError::error_id() const {
  // @@protoc_insertion_point(field_get:exec.shared.DrillPBError.error_id)
  return _internal_error_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DrillPBError::set_error_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.error_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.shared.DrillPBError.error_id)
}
inline std::string* DrillPBError::mutable_error_id() {
  std::string* _s = _internal_mutable_error_id();
  // @@protoc_insertion_point(field_mutable:exec.shared.DrillPBError.error_id)
  return _s;
}
inline const std::string& DrillPBError::_internal_error_id() const {
  return _impl_.error_id_.Get();
}
inline void DrillPBError::_internal_set_error_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.error_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DrillPBError::_internal_mutable_error_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.error_id_.Mutable( GetArenaForAllocation());
}
inline std::string* DrillPBError::release_error_id() {
  // @@protoc_insertion_point(field_release:exec.shared.DrillPBError.error_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.error_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.error_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void DrillPBError::set_allocated_error_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.error_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.error_id_.IsDefault()) {
          _impl_.error_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.shared.DrillPBError.error_id)
}

// optional .exec.DrillbitEndpoint endpoint = 2;
inline bool DrillPBError::has_endpoint() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.endpoint_ != nullptr);
  return value;
}
inline const ::exec::DrillbitEndpoint& DrillPBError::_internal_endpoint() const {
  const ::exec::DrillbitEndpoint* p = _impl_.endpoint_;
  return p != nullptr ? *p : reinterpret_cast<const ::exec::DrillbitEndpoint&>(
      ::exec::_DrillbitEndpoint_default_instance_);
}
inline const ::exec::DrillbitEndpoint& DrillPBError::endpoint() const {
  // @@protoc_insertion_point(field_get:exec.shared.DrillPBError.endpoint)
  return _internal_endpoint();
}
inline void DrillPBError::unsafe_arena_set_allocated_endpoint(
    ::exec::DrillbitEndpoint* endpoint) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.endpoint_);
  }
  _impl_.endpoint_ = endpoint;
  if (endpoint) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:exec.shared.DrillPBError.endpoint)
}
inline ::exec::DrillbitEndpoint* DrillPBError::release_endpoint() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::exec::DrillbitEndpoint* temp = _impl_.endpoint_;
  _impl_.endpoint_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exec::DrillbitEndpoint* DrillPBError::unsafe_arena_release_endpoint() {
  // @@protoc_insertion_point(field_release:exec.shared.DrillPBError.endpoint)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::exec::DrillbitEndpoint* temp = _impl_.endpoint_;
  _impl_.endpoint_ = nullptr;
  return temp;
}
inline ::exec::DrillbitEndpoint* DrillPBError::_internal_mutable_endpoint() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.endpoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::exec::DrillbitEndpoint>(GetArenaForAllocation());
    _impl_.endpoint_ = p;
  }
  return _impl_.endpoint_;
}
inline ::exec::DrillbitEndpoint* DrillPBError::mutable_endpoint() {
  ::exec::DrillbitEndpoint* _msg = _internal_mutable_endpoint();
  // @@protoc_insertion_point(field_mutable:exec.shared.DrillPBError.endpoint)
  return _msg;
}
inline void DrillPBError::set_allocated_endpoint(::exec::DrillbitEndpoint* endpoint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.endpoint_);
  }
  if (endpoint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(endpoint));
    if (message_arena != submessage_arena) {
      endpoint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, endpoint, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.endpoint_ = endpoint;
  // @@protoc_insertion_point(field_set_allocated:exec.shared.DrillPBError.endpoint)
}

// optional .exec.shared.DrillPBError.ErrorType error_type = 3;
inline bool DrillPBError::has_error_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void DrillPBError::clear_error_type() {
  _impl_.error_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::exec::shared::DrillPBError_ErrorType DrillPBError::error_type() const {
  // @@protoc_insertion_point(field_get:exec.shared.DrillPBError.error_type)
  return _internal_error_type();
}
inline void DrillPBError::set_error_type(::exec::shared::DrillPBError_ErrorType value) {
   _internal_set_error_type(value);
  // @@protoc_insertion_point(field_set:exec.shared.DrillPBError.error_type)
}
inline ::exec::shared::DrillPBError_ErrorType DrillPBError::_internal_error_type() const {
  return static_cast<::exec::shared::DrillPBError_ErrorType>(_impl_.error_type_);
}
inline void DrillPBError::_internal_set_error_type(::exec::shared::DrillPBError_ErrorType value) {
  assert(::exec::shared::DrillPBError_ErrorType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.error_type_ = value;
}

// optional string message = 4;
inline bool DrillPBError::has_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void DrillPBError::clear_message() {
  _impl_.message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DrillPBError::message() const {
  // @@protoc_insertion_point(field_get:exec.shared.DrillPBError.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DrillPBError::set_message(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.shared.DrillPBError.message)
}
inline std::string* DrillPBError::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:exec.shared.DrillPBError.message)
  return _s;
}
inline const std::string& DrillPBError::_internal_message() const {
  return _impl_.message_.Get();
}
inline void DrillPBError::_internal_set_message(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* DrillPBError::_internal_mutable_message() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.message_.Mutable( GetArenaForAllocation());
}
inline std::string* DrillPBError::release_message() {
  // @@protoc_insertion_point(field_release:exec.shared.DrillPBError.message)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.message_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.message_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void DrillPBError::set_allocated_message(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.message_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.shared.DrillPBError.message)
}

// optional .exec.shared.ExceptionWrapper exception = 5;
inline bool DrillPBError::has_exception() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.exception_ != nullptr);
  return value;
}
inline void DrillPBError::clear_exception() {
  if (_impl_.exception_ != nullptr) _impl_.exception_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::exec::shared::ExceptionWrapper& DrillPBError::_internal_exception() const {
  const ::exec::shared::ExceptionWrapper* p = _impl_.exception_;
  return p != nullptr ? *p : reinterpret_cast<const ::exec::shared::ExceptionWrapper&>(
      ::exec::shared::_ExceptionWrapper_default_instance_);
}
inline const ::exec::shared::ExceptionWrapper& DrillPBError::exception() const {
  // @@protoc_insertion_point(field_get:exec.shared.DrillPBError.exception)
  return _internal_exception();
}
inline void DrillPBError::unsafe_arena_set_allocated_exception(
    ::exec::shared::ExceptionWrapper* exception) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.exception_);
  }
  _impl_.exception_ = exception;
  if (exception) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:exec.shared.DrillPBError.exception)
}
inline ::exec::shared::ExceptionWrapper* DrillPBError::release_exception() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::exec::shared::ExceptionWrapper* temp = _impl_.exception_;
  _impl_.exception_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exec::shared::ExceptionWrapper* DrillPBError::unsafe_arena_release_exception() {
  // @@protoc_insertion_point(field_release:exec.shared.DrillPBError.exception)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::exec::shared::ExceptionWrapper* temp = _impl_.exception_;
  _impl_.exception_ = nullptr;
  return temp;
}
inline ::exec::shared::ExceptionWrapper* DrillPBError::_internal_mutable_exception() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.exception_ == nullptr) {
    auto* p = CreateMaybeMessage<::exec::shared::ExceptionWrapper>(GetArenaForAllocation());
    _impl_.exception_ = p;
  }
  return _impl_.exception_;
}
inline ::exec::shared::ExceptionWrapper* DrillPBError::mutable_exception() {
  ::exec::shared::ExceptionWrapper* _msg = _internal_mutable_exception();
  // @@protoc_insertion_point(field_mutable:exec.shared.DrillPBError.exception)
  return _msg;
}
inline void DrillPBError::set_allocated_exception(::exec::shared::ExceptionWrapper* exception) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.exception_;
  }
  if (exception) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(exception);
    if (message_arena != submessage_arena) {
      exception = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, exception, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.exception_ = exception;
  // @@protoc_insertion_point(field_set_allocated:exec.shared.DrillPBError.exception)
}

// repeated .exec.shared.ParsingError parsing_error = 6;
inline int DrillPBError::_internal_parsing_error_size() const {
  return _impl_.parsing_error_.size();
}
inline int DrillPBError::parsing_error_size() const {
  return _internal_parsing_error_size();
}
inline void DrillPBError::clear_parsing_error() {
  _impl_.parsing_error_.Clear();
}
inline ::exec::shared::ParsingError* DrillPBError::mutable_parsing_error(int index) {
  // @@protoc_insertion_point(field_mutable:exec.shared.DrillPBError.parsing_error)
  return _impl_.parsing_error_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::shared::ParsingError >*
DrillPBError::mutable_parsing_error() {
  // @@protoc_insertion_point(field_mutable_list:exec.shared.DrillPBError.parsing_error)
  return &_impl_.parsing_error_;
}
inline const ::exec::shared::ParsingError& DrillPBError::_internal_parsing_error(int index) const {
  return _impl_.parsing_error_.Get(index);
}
inline const ::exec::shared::ParsingError& DrillPBError::parsing_error(int index) const {
  // @@protoc_insertion_point(field_get:exec.shared.DrillPBError.parsing_error)
  return _internal_parsing_error(index);
}
inline ::exec::shared::ParsingError* DrillPBError::_internal_add_parsing_error() {
  return _impl_.parsing_error_.Add();
}
inline ::exec::shared::ParsingError* DrillPBError::add_parsing_error() {
  ::exec::shared::ParsingError* _add = _internal_add_parsing_error();
  // @@protoc_insertion_point(field_add:exec.shared.DrillPBError.parsing_error)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::shared::ParsingError >&
DrillPBError::parsing_error() const {
  // @@protoc_insertion_point(field_list:exec.shared.DrillPBError.parsing_error)
  return _impl_.parsing_error_;
}

// -------------------------------------------------------------------

// ExceptionWrapper

// optional string exception_class = 1;
inline bool ExceptionWrapper::has_exception_class() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ExceptionWrapper::clear_exception_class() {
  _impl_.exception_class_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ExceptionWrapper::exception_class() const {
  // @@protoc_insertion_point(field_get:exec.shared.ExceptionWrapper.exception_class)
  return _internal_exception_class();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ExceptionWrapper::set_exception_class(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.exception_class_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.shared.ExceptionWrapper.exception_class)
}
inline std::string* ExceptionWrapper::mutable_exception_class() {
  std::string* _s = _internal_mutable_exception_class();
  // @@protoc_insertion_point(field_mutable:exec.shared.ExceptionWrapper.exception_class)
  return _s;
}
inline const std::string& ExceptionWrapper::_internal_exception_class() const {
  return _impl_.exception_class_.Get();
}
inline void ExceptionWrapper::_internal_set_exception_class(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.exception_class_.Set(value, GetArenaForAllocation());
}
inline std::string* ExceptionWrapper::_internal_mutable_exception_class() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.exception_class_.Mutable( GetArenaForAllocation());
}
inline std::string* ExceptionWrapper::release_exception_class() {
  // @@protoc_insertion_point(field_release:exec.shared.ExceptionWrapper.exception_class)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.exception_class_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.exception_class_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ExceptionWrapper::set_allocated_exception_class(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.exception_class_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.exception_class_.IsDefault()) {
          _impl_.exception_class_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.shared.ExceptionWrapper.exception_class)
}

// optional string message = 2;
inline bool ExceptionWrapper::has_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ExceptionWrapper::clear_message() {
  _impl_.message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ExceptionWrapper::message() const {
  // @@protoc_insertion_point(field_get:exec.shared.ExceptionWrapper.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ExceptionWrapper::set_message(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.shared.ExceptionWrapper.message)
}
inline std::string* ExceptionWrapper::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:exec.shared.ExceptionWrapper.message)
  return _s;
}
inline const std::string& ExceptionWrapper::_internal_message() const {
  return _impl_.message_.Get();
}
inline void ExceptionWrapper::_internal_set_message(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* ExceptionWrapper::_internal_mutable_message() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.message_.Mutable( GetArenaForAllocation());
}
inline std::string* ExceptionWrapper::release_message() {
  // @@protoc_insertion_point(field_release:exec.shared.ExceptionWrapper.message)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.message_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.message_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ExceptionWrapper::set_allocated_message(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.message_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.shared.ExceptionWrapper.message)
}

// repeated .exec.shared.StackTraceElementWrapper stack_trace = 3;
inline int ExceptionWrapper::_internal_stack_trace_size() const {
  return _impl_.stack_trace_.size();
}
inline int ExceptionWrapper::stack_trace_size() const {
  return _internal_stack_trace_size();
}
inline void ExceptionWrapper::clear_stack_trace() {
  _impl_.stack_trace_.Clear();
}
inline ::exec::shared::StackTraceElementWrapper* ExceptionWrapper::mutable_stack_trace(int index) {
  // @@protoc_insertion_point(field_mutable:exec.shared.ExceptionWrapper.stack_trace)
  return _impl_.stack_trace_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::shared::StackTraceElementWrapper >*
ExceptionWrapper::mutable_stack_trace() {
  // @@protoc_insertion_point(field_mutable_list:exec.shared.ExceptionWrapper.stack_trace)
  return &_impl_.stack_trace_;
}
inline const ::exec::shared::StackTraceElementWrapper& ExceptionWrapper::_internal_stack_trace(int index) const {
  return _impl_.stack_trace_.Get(index);
}
inline const ::exec::shared::StackTraceElementWrapper& ExceptionWrapper::stack_trace(int index) const {
  // @@protoc_insertion_point(field_get:exec.shared.ExceptionWrapper.stack_trace)
  return _internal_stack_trace(index);
}
inline ::exec::shared::StackTraceElementWrapper* ExceptionWrapper::_internal_add_stack_trace() {
  return _impl_.stack_trace_.Add();
}
inline ::exec::shared::StackTraceElementWrapper* ExceptionWrapper::add_stack_trace() {
  ::exec::shared::StackTraceElementWrapper* _add = _internal_add_stack_trace();
  // @@protoc_insertion_point(field_add:exec.shared.ExceptionWrapper.stack_trace)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::shared::StackTraceElementWrapper >&
ExceptionWrapper::stack_trace() const {
  // @@protoc_insertion_point(field_list:exec.shared.ExceptionWrapper.stack_trace)
  return _impl_.stack_trace_;
}

// optional .exec.shared.ExceptionWrapper cause = 4;
inline bool ExceptionWrapper::has_cause() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cause_ != nullptr);
  return value;
}
inline void ExceptionWrapper::clear_cause() {
  if (_impl_.cause_ != nullptr) _impl_.cause_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::exec::shared::ExceptionWrapper& ExceptionWrapper::_internal_cause() const {
  const ::exec::shared::ExceptionWrapper* p = _impl_.cause_;
  return p != nullptr ? *p : reinterpret_cast<const ::exec::shared::ExceptionWrapper&>(
      ::exec::shared::_ExceptionWrapper_default_instance_);
}
inline const ::exec::shared::ExceptionWrapper& ExceptionWrapper::cause() const {
  // @@protoc_insertion_point(field_get:exec.shared.ExceptionWrapper.cause)
  return _internal_cause();
}
inline void ExceptionWrapper::unsafe_arena_set_allocated_cause(
    ::exec::shared::ExceptionWrapper* cause) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cause_);
  }
  _impl_.cause_ = cause;
  if (cause) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:exec.shared.ExceptionWrapper.cause)
}
inline ::exec::shared::ExceptionWrapper* ExceptionWrapper::release_cause() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::exec::shared::ExceptionWrapper* temp = _impl_.cause_;
  _impl_.cause_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exec::shared::ExceptionWrapper* ExceptionWrapper::unsafe_arena_release_cause() {
  // @@protoc_insertion_point(field_release:exec.shared.ExceptionWrapper.cause)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::exec::shared::ExceptionWrapper* temp = _impl_.cause_;
  _impl_.cause_ = nullptr;
  return temp;
}
inline ::exec::shared::ExceptionWrapper* ExceptionWrapper::_internal_mutable_cause() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.cause_ == nullptr) {
    auto* p = CreateMaybeMessage<::exec::shared::ExceptionWrapper>(GetArenaForAllocation());
    _impl_.cause_ = p;
  }
  return _impl_.cause_;
}
inline ::exec::shared::ExceptionWrapper* ExceptionWrapper::mutable_cause() {
  ::exec::shared::ExceptionWrapper* _msg = _internal_mutable_cause();
  // @@protoc_insertion_point(field_mutable:exec.shared.ExceptionWrapper.cause)
  return _msg;
}
inline void ExceptionWrapper::set_allocated_cause(::exec::shared::ExceptionWrapper* cause) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cause_;
  }
  if (cause) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cause);
    if (message_arena != submessage_arena) {
      cause = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cause, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.cause_ = cause;
  // @@protoc_insertion_point(field_set_allocated:exec.shared.ExceptionWrapper.cause)
}

// -------------------------------------------------------------------

// StackTraceElementWrapper

// optional string class_name = 1;
inline bool StackTraceElementWrapper::has_class_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void StackTraceElementWrapper::clear_class_name() {
  _impl_.class_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StackTraceElementWrapper::class_name() const {
  // @@protoc_insertion_point(field_get:exec.shared.StackTraceElementWrapper.class_name)
  return _internal_class_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StackTraceElementWrapper::set_class_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.class_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.shared.StackTraceElementWrapper.class_name)
}
inline std::string* StackTraceElementWrapper::mutable_class_name() {
  std::string* _s = _internal_mutable_class_name();
  // @@protoc_insertion_point(field_mutable:exec.shared.StackTraceElementWrapper.class_name)
  return _s;
}
inline const std::string& StackTraceElementWrapper::_internal_class_name() const {
  return _impl_.class_name_.Get();
}
inline void StackTraceElementWrapper::_internal_set_class_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.class_name_.Set(value, GetArenaForAllocation());
}
inline std::string* StackTraceElementWrapper::_internal_mutable_class_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.class_name_.Mutable( GetArenaForAllocation());
}
inline std::string* StackTraceElementWrapper::release_class_name() {
  // @@protoc_insertion_point(field_release:exec.shared.StackTraceElementWrapper.class_name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.class_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.class_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void StackTraceElementWrapper::set_allocated_class_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.class_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.class_name_.IsDefault()) {
          _impl_.class_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.shared.StackTraceElementWrapper.class_name)
}

// optional string file_name = 2;
inline bool StackTraceElementWrapper::has_file_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void StackTraceElementWrapper::clear_file_name() {
  _impl_.file_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& StackTraceElementWrapper::file_name() const {
  // @@protoc_insertion_point(field_get:exec.shared.StackTraceElementWrapper.file_name)
  return _internal_file_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StackTraceElementWrapper::set_file_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.file_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.shared.StackTraceElementWrapper.file_name)
}
inline std::string* StackTraceElementWrapper::mutable_file_name() {
  std::string* _s = _internal_mutable_file_name();
  // @@protoc_insertion_point(field_mutable:exec.shared.StackTraceElementWrapper.file_name)
  return _s;
}
inline const std::string& StackTraceElementWrapper::_internal_file_name() const {
  return _impl_.file_name_.Get();
}
inline void StackTraceElementWrapper::_internal_set_file_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.file_name_.Set(value, GetArenaForAllocation());
}
inline std::string* StackTraceElementWrapper::_internal_mutable_file_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.file_name_.Mutable( GetArenaForAllocation());
}
inline std::string* StackTraceElementWrapper::release_file_name() {
  // @@protoc_insertion_point(field_release:exec.shared.StackTraceElementWrapper.file_name)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.file_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.file_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void StackTraceElementWrapper::set_allocated_file_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.file_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.file_name_.IsDefault()) {
          _impl_.file_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.shared.StackTraceElementWrapper.file_name)
}

// optional int32 line_number = 3;
inline bool StackTraceElementWrapper::has_line_number() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void StackTraceElementWrapper::clear_line_number() {
  _impl_.line_number_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t StackTraceElementWrapper::line_number() const {
  // @@protoc_insertion_point(field_get:exec.shared.StackTraceElementWrapper.line_number)
  return _internal_line_number();
}
inline void StackTraceElementWrapper::set_line_number(::int32_t value) {
  _internal_set_line_number(value);
  // @@protoc_insertion_point(field_set:exec.shared.StackTraceElementWrapper.line_number)
}
inline ::int32_t StackTraceElementWrapper::_internal_line_number() const {
  return _impl_.line_number_;
}
inline void StackTraceElementWrapper::_internal_set_line_number(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.line_number_ = value;
}

// optional string method_name = 4;
inline bool StackTraceElementWrapper::has_method_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void StackTraceElementWrapper::clear_method_name() {
  _impl_.method_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& StackTraceElementWrapper::method_name() const {
  // @@protoc_insertion_point(field_get:exec.shared.StackTraceElementWrapper.method_name)
  return _internal_method_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StackTraceElementWrapper::set_method_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.method_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.shared.StackTraceElementWrapper.method_name)
}
inline std::string* StackTraceElementWrapper::mutable_method_name() {
  std::string* _s = _internal_mutable_method_name();
  // @@protoc_insertion_point(field_mutable:exec.shared.StackTraceElementWrapper.method_name)
  return _s;
}
inline const std::string& StackTraceElementWrapper::_internal_method_name() const {
  return _impl_.method_name_.Get();
}
inline void StackTraceElementWrapper::_internal_set_method_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;


  _impl_.method_name_.Set(value, GetArenaForAllocation());
}
inline std::string* StackTraceElementWrapper::_internal_mutable_method_name() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.method_name_.Mutable( GetArenaForAllocation());
}
inline std::string* StackTraceElementWrapper::release_method_name() {
  // @@protoc_insertion_point(field_release:exec.shared.StackTraceElementWrapper.method_name)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.method_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.method_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void StackTraceElementWrapper::set_allocated_method_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.method_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.method_name_.IsDefault()) {
          _impl_.method_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.shared.StackTraceElementWrapper.method_name)
}

// optional bool is_native_method = 5;
inline bool StackTraceElementWrapper::has_is_native_method() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void StackTraceElementWrapper::clear_is_native_method() {
  _impl_.is_native_method_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool StackTraceElementWrapper::is_native_method() const {
  // @@protoc_insertion_point(field_get:exec.shared.StackTraceElementWrapper.is_native_method)
  return _internal_is_native_method();
}
inline void StackTraceElementWrapper::set_is_native_method(bool value) {
  _internal_set_is_native_method(value);
  // @@protoc_insertion_point(field_set:exec.shared.StackTraceElementWrapper.is_native_method)
}
inline bool StackTraceElementWrapper::_internal_is_native_method() const {
  return _impl_.is_native_method_;
}
inline void StackTraceElementWrapper::_internal_set_is_native_method(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.is_native_method_ = value;
}

// -------------------------------------------------------------------

// ParsingError

// optional int32 start_column = 2;
inline bool ParsingError::has_start_column() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ParsingError::clear_start_column() {
  _impl_.start_column_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t ParsingError::start_column() const {
  // @@protoc_insertion_point(field_get:exec.shared.ParsingError.start_column)
  return _internal_start_column();
}
inline void ParsingError::set_start_column(::int32_t value) {
  _internal_set_start_column(value);
  // @@protoc_insertion_point(field_set:exec.shared.ParsingError.start_column)
}
inline ::int32_t ParsingError::_internal_start_column() const {
  return _impl_.start_column_;
}
inline void ParsingError::_internal_set_start_column(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.start_column_ = value;
}

// optional int32 start_row = 3;
inline bool ParsingError::has_start_row() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ParsingError::clear_start_row() {
  _impl_.start_row_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t ParsingError::start_row() const {
  // @@protoc_insertion_point(field_get:exec.shared.ParsingError.start_row)
  return _internal_start_row();
}
inline void ParsingError::set_start_row(::int32_t value) {
  _internal_set_start_row(value);
  // @@protoc_insertion_point(field_set:exec.shared.ParsingError.start_row)
}
inline ::int32_t ParsingError::_internal_start_row() const {
  return _impl_.start_row_;
}
inline void ParsingError::_internal_set_start_row(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.start_row_ = value;
}

// optional int32 end_column = 4;
inline bool ParsingError::has_end_column() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ParsingError::clear_end_column() {
  _impl_.end_column_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t ParsingError::end_column() const {
  // @@protoc_insertion_point(field_get:exec.shared.ParsingError.end_column)
  return _internal_end_column();
}
inline void ParsingError::set_end_column(::int32_t value) {
  _internal_set_end_column(value);
  // @@protoc_insertion_point(field_set:exec.shared.ParsingError.end_column)
}
inline ::int32_t ParsingError::_internal_end_column() const {
  return _impl_.end_column_;
}
inline void ParsingError::_internal_set_end_column(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.end_column_ = value;
}

// optional int32 end_row = 5;
inline bool ParsingError::has_end_row() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void ParsingError::clear_end_row() {
  _impl_.end_row_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t ParsingError::end_row() const {
  // @@protoc_insertion_point(field_get:exec.shared.ParsingError.end_row)
  return _internal_end_row();
}
inline void ParsingError::set_end_row(::int32_t value) {
  _internal_set_end_row(value);
  // @@protoc_insertion_point(field_set:exec.shared.ParsingError.end_row)
}
inline ::int32_t ParsingError::_internal_end_row() const {
  return _impl_.end_row_;
}
inline void ParsingError::_internal_set_end_row(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.end_row_ = value;
}

// -------------------------------------------------------------------

// RecordBatchDef

// optional int32 record_count = 1;
inline bool RecordBatchDef::has_record_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RecordBatchDef::clear_record_count() {
  _impl_.record_count_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t RecordBatchDef::record_count() const {
  // @@protoc_insertion_point(field_get:exec.shared.RecordBatchDef.record_count)
  return _internal_record_count();
}
inline void RecordBatchDef::set_record_count(::int32_t value) {
  _internal_set_record_count(value);
  // @@protoc_insertion_point(field_set:exec.shared.RecordBatchDef.record_count)
}
inline ::int32_t RecordBatchDef::_internal_record_count() const {
  return _impl_.record_count_;
}
inline void RecordBatchDef::_internal_set_record_count(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.record_count_ = value;
}

// repeated .exec.shared.SerializedField field = 2;
inline int RecordBatchDef::_internal_field_size() const {
  return _impl_.field_.size();
}
inline int RecordBatchDef::field_size() const {
  return _internal_field_size();
}
inline void RecordBatchDef::clear_field() {
  _impl_.field_.Clear();
}
inline ::exec::shared::SerializedField* RecordBatchDef::mutable_field(int index) {
  // @@protoc_insertion_point(field_mutable:exec.shared.RecordBatchDef.field)
  return _impl_.field_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::shared::SerializedField >*
RecordBatchDef::mutable_field() {
  // @@protoc_insertion_point(field_mutable_list:exec.shared.RecordBatchDef.field)
  return &_impl_.field_;
}
inline const ::exec::shared::SerializedField& RecordBatchDef::_internal_field(int index) const {
  return _impl_.field_.Get(index);
}
inline const ::exec::shared::SerializedField& RecordBatchDef::field(int index) const {
  // @@protoc_insertion_point(field_get:exec.shared.RecordBatchDef.field)
  return _internal_field(index);
}
inline ::exec::shared::SerializedField* RecordBatchDef::_internal_add_field() {
  return _impl_.field_.Add();
}
inline ::exec::shared::SerializedField* RecordBatchDef::add_field() {
  ::exec::shared::SerializedField* _add = _internal_add_field();
  // @@protoc_insertion_point(field_add:exec.shared.RecordBatchDef.field)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::shared::SerializedField >&
RecordBatchDef::field() const {
  // @@protoc_insertion_point(field_list:exec.shared.RecordBatchDef.field)
  return _impl_.field_;
}

// optional bool carries_two_byte_selection_vector = 3;
inline bool RecordBatchDef::has_carries_two_byte_selection_vector() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RecordBatchDef::clear_carries_two_byte_selection_vector() {
  _impl_.carries_two_byte_selection_vector_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool RecordBatchDef::carries_two_byte_selection_vector() const {
  // @@protoc_insertion_point(field_get:exec.shared.RecordBatchDef.carries_two_byte_selection_vector)
  return _internal_carries_two_byte_selection_vector();
}
inline void RecordBatchDef::set_carries_two_byte_selection_vector(bool value) {
  _internal_set_carries_two_byte_selection_vector(value);
  // @@protoc_insertion_point(field_set:exec.shared.RecordBatchDef.carries_two_byte_selection_vector)
}
inline bool RecordBatchDef::_internal_carries_two_byte_selection_vector() const {
  return _impl_.carries_two_byte_selection_vector_;
}
inline void RecordBatchDef::_internal_set_carries_two_byte_selection_vector(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.carries_two_byte_selection_vector_ = value;
}

// optional int32 affected_rows_count = 4;
inline bool RecordBatchDef::has_affected_rows_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void RecordBatchDef::clear_affected_rows_count() {
  _impl_.affected_rows_count_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t RecordBatchDef::affected_rows_count() const {
  // @@protoc_insertion_point(field_get:exec.shared.RecordBatchDef.affected_rows_count)
  return _internal_affected_rows_count();
}
inline void RecordBatchDef::set_affected_rows_count(::int32_t value) {
  _internal_set_affected_rows_count(value);
  // @@protoc_insertion_point(field_set:exec.shared.RecordBatchDef.affected_rows_count)
}
inline ::int32_t RecordBatchDef::_internal_affected_rows_count() const {
  return _impl_.affected_rows_count_;
}
inline void RecordBatchDef::_internal_set_affected_rows_count(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.affected_rows_count_ = value;
}

// -------------------------------------------------------------------

// NamePart

// optional .exec.shared.NamePart.Type type = 1;
inline bool NamePart::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void NamePart::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::exec::shared::NamePart_Type NamePart::type() const {
  // @@protoc_insertion_point(field_get:exec.shared.NamePart.type)
  return _internal_type();
}
inline void NamePart::set_type(::exec::shared::NamePart_Type value) {
   _internal_set_type(value);
  // @@protoc_insertion_point(field_set:exec.shared.NamePart.type)
}
inline ::exec::shared::NamePart_Type NamePart::_internal_type() const {
  return static_cast<::exec::shared::NamePart_Type>(_impl_.type_);
}
inline void NamePart::_internal_set_type(::exec::shared::NamePart_Type value) {
  assert(::exec::shared::NamePart_Type_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.type_ = value;
}

// optional string name = 2;
inline bool NamePart::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NamePart::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NamePart::name() const {
  // @@protoc_insertion_point(field_get:exec.shared.NamePart.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NamePart::set_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.shared.NamePart.name)
}
inline std::string* NamePart::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:exec.shared.NamePart.name)
  return _s;
}
inline const std::string& NamePart::_internal_name() const {
  return _impl_.name_.Get();
}
inline void NamePart::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* NamePart::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* NamePart::release_name() {
  // @@protoc_insertion_point(field_release:exec.shared.NamePart.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void NamePart::set_allocated_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.shared.NamePart.name)
}

// optional .exec.shared.NamePart child = 3;
inline bool NamePart::has_child() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.child_ != nullptr);
  return value;
}
inline void NamePart::clear_child() {
  if (_impl_.child_ != nullptr) _impl_.child_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::exec::shared::NamePart& NamePart::_internal_child() const {
  const ::exec::shared::NamePart* p = _impl_.child_;
  return p != nullptr ? *p : reinterpret_cast<const ::exec::shared::NamePart&>(
      ::exec::shared::_NamePart_default_instance_);
}
inline const ::exec::shared::NamePart& NamePart::child() const {
  // @@protoc_insertion_point(field_get:exec.shared.NamePart.child)
  return _internal_child();
}
inline void NamePart::unsafe_arena_set_allocated_child(
    ::exec::shared::NamePart* child) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.child_);
  }
  _impl_.child_ = child;
  if (child) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:exec.shared.NamePart.child)
}
inline ::exec::shared::NamePart* NamePart::release_child() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::exec::shared::NamePart* temp = _impl_.child_;
  _impl_.child_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exec::shared::NamePart* NamePart::unsafe_arena_release_child() {
  // @@protoc_insertion_point(field_release:exec.shared.NamePart.child)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::exec::shared::NamePart* temp = _impl_.child_;
  _impl_.child_ = nullptr;
  return temp;
}
inline ::exec::shared::NamePart* NamePart::_internal_mutable_child() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.child_ == nullptr) {
    auto* p = CreateMaybeMessage<::exec::shared::NamePart>(GetArenaForAllocation());
    _impl_.child_ = p;
  }
  return _impl_.child_;
}
inline ::exec::shared::NamePart* NamePart::mutable_child() {
  ::exec::shared::NamePart* _msg = _internal_mutable_child();
  // @@protoc_insertion_point(field_mutable:exec.shared.NamePart.child)
  return _msg;
}
inline void NamePart::set_allocated_child(::exec::shared::NamePart* child) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.child_;
  }
  if (child) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(child);
    if (message_arena != submessage_arena) {
      child = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, child, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.child_ = child;
  // @@protoc_insertion_point(field_set_allocated:exec.shared.NamePart.child)
}

// -------------------------------------------------------------------

// SerializedField

// optional .common.MajorType major_type = 1;
inline bool SerializedField::has_major_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.major_type_ != nullptr);
  return value;
}
inline const ::common::MajorType& SerializedField::_internal_major_type() const {
  const ::common::MajorType* p = _impl_.major_type_;
  return p != nullptr ? *p : reinterpret_cast<const ::common::MajorType&>(
      ::common::_MajorType_default_instance_);
}
inline const ::common::MajorType& SerializedField::major_type() const {
  // @@protoc_insertion_point(field_get:exec.shared.SerializedField.major_type)
  return _internal_major_type();
}
inline void SerializedField::unsafe_arena_set_allocated_major_type(
    ::common::MajorType* major_type) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.major_type_);
  }
  _impl_.major_type_ = major_type;
  if (major_type) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:exec.shared.SerializedField.major_type)
}
inline ::common::MajorType* SerializedField::release_major_type() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::common::MajorType* temp = _impl_.major_type_;
  _impl_.major_type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::common::MajorType* SerializedField::unsafe_arena_release_major_type() {
  // @@protoc_insertion_point(field_release:exec.shared.SerializedField.major_type)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::common::MajorType* temp = _impl_.major_type_;
  _impl_.major_type_ = nullptr;
  return temp;
}
inline ::common::MajorType* SerializedField::_internal_mutable_major_type() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.major_type_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::MajorType>(GetArenaForAllocation());
    _impl_.major_type_ = p;
  }
  return _impl_.major_type_;
}
inline ::common::MajorType* SerializedField::mutable_major_type() {
  ::common::MajorType* _msg = _internal_mutable_major_type();
  // @@protoc_insertion_point(field_mutable:exec.shared.SerializedField.major_type)
  return _msg;
}
inline void SerializedField::set_allocated_major_type(::common::MajorType* major_type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.major_type_);
  }
  if (major_type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(major_type));
    if (message_arena != submessage_arena) {
      major_type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, major_type, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.major_type_ = major_type;
  // @@protoc_insertion_point(field_set_allocated:exec.shared.SerializedField.major_type)
}

// optional .exec.shared.NamePart name_part = 2;
inline bool SerializedField::has_name_part() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.name_part_ != nullptr);
  return value;
}
inline void SerializedField::clear_name_part() {
  if (_impl_.name_part_ != nullptr) _impl_.name_part_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::exec::shared::NamePart& SerializedField::_internal_name_part() const {
  const ::exec::shared::NamePart* p = _impl_.name_part_;
  return p != nullptr ? *p : reinterpret_cast<const ::exec::shared::NamePart&>(
      ::exec::shared::_NamePart_default_instance_);
}
inline const ::exec::shared::NamePart& SerializedField::name_part() const {
  // @@protoc_insertion_point(field_get:exec.shared.SerializedField.name_part)
  return _internal_name_part();
}
inline void SerializedField::unsafe_arena_set_allocated_name_part(
    ::exec::shared::NamePart* name_part) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.name_part_);
  }
  _impl_.name_part_ = name_part;
  if (name_part) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:exec.shared.SerializedField.name_part)
}
inline ::exec::shared::NamePart* SerializedField::release_name_part() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::exec::shared::NamePart* temp = _impl_.name_part_;
  _impl_.name_part_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exec::shared::NamePart* SerializedField::unsafe_arena_release_name_part() {
  // @@protoc_insertion_point(field_release:exec.shared.SerializedField.name_part)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::exec::shared::NamePart* temp = _impl_.name_part_;
  _impl_.name_part_ = nullptr;
  return temp;
}
inline ::exec::shared::NamePart* SerializedField::_internal_mutable_name_part() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.name_part_ == nullptr) {
    auto* p = CreateMaybeMessage<::exec::shared::NamePart>(GetArenaForAllocation());
    _impl_.name_part_ = p;
  }
  return _impl_.name_part_;
}
inline ::exec::shared::NamePart* SerializedField::mutable_name_part() {
  ::exec::shared::NamePart* _msg = _internal_mutable_name_part();
  // @@protoc_insertion_point(field_mutable:exec.shared.SerializedField.name_part)
  return _msg;
}
inline void SerializedField::set_allocated_name_part(::exec::shared::NamePart* name_part) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.name_part_;
  }
  if (name_part) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(name_part);
    if (message_arena != submessage_arena) {
      name_part = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, name_part, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.name_part_ = name_part;
  // @@protoc_insertion_point(field_set_allocated:exec.shared.SerializedField.name_part)
}

// repeated .exec.shared.SerializedField child = 3;
inline int SerializedField::_internal_child_size() const {
  return _impl_.child_.size();
}
inline int SerializedField::child_size() const {
  return _internal_child_size();
}
inline void SerializedField::clear_child() {
  _impl_.child_.Clear();
}
inline ::exec::shared::SerializedField* SerializedField::mutable_child(int index) {
  // @@protoc_insertion_point(field_mutable:exec.shared.SerializedField.child)
  return _impl_.child_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::shared::SerializedField >*
SerializedField::mutable_child() {
  // @@protoc_insertion_point(field_mutable_list:exec.shared.SerializedField.child)
  return &_impl_.child_;
}
inline const ::exec::shared::SerializedField& SerializedField::_internal_child(int index) const {
  return _impl_.child_.Get(index);
}
inline const ::exec::shared::SerializedField& SerializedField::child(int index) const {
  // @@protoc_insertion_point(field_get:exec.shared.SerializedField.child)
  return _internal_child(index);
}
inline ::exec::shared::SerializedField* SerializedField::_internal_add_child() {
  return _impl_.child_.Add();
}
inline ::exec::shared::SerializedField* SerializedField::add_child() {
  ::exec::shared::SerializedField* _add = _internal_add_child();
  // @@protoc_insertion_point(field_add:exec.shared.SerializedField.child)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::shared::SerializedField >&
SerializedField::child() const {
  // @@protoc_insertion_point(field_list:exec.shared.SerializedField.child)
  return _impl_.child_;
}

// optional int32 value_count = 4;
inline bool SerializedField::has_value_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SerializedField::clear_value_count() {
  _impl_.value_count_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t SerializedField::value_count() const {
  // @@protoc_insertion_point(field_get:exec.shared.SerializedField.value_count)
  return _internal_value_count();
}
inline void SerializedField::set_value_count(::int32_t value) {
  _internal_set_value_count(value);
  // @@protoc_insertion_point(field_set:exec.shared.SerializedField.value_count)
}
inline ::int32_t SerializedField::_internal_value_count() const {
  return _impl_.value_count_;
}
inline void SerializedField::_internal_set_value_count(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.value_count_ = value;
}

// optional int32 var_byte_length = 5;
inline bool SerializedField::has_var_byte_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void SerializedField::clear_var_byte_length() {
  _impl_.var_byte_length_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t SerializedField::var_byte_length() const {
  // @@protoc_insertion_point(field_get:exec.shared.SerializedField.var_byte_length)
  return _internal_var_byte_length();
}
inline void SerializedField::set_var_byte_length(::int32_t value) {
  _internal_set_var_byte_length(value);
  // @@protoc_insertion_point(field_set:exec.shared.SerializedField.var_byte_length)
}
inline ::int32_t SerializedField::_internal_var_byte_length() const {
  return _impl_.var_byte_length_;
}
inline void SerializedField::_internal_set_var_byte_length(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.var_byte_length_ = value;
}

// optional int32 buffer_length = 7;
inline bool SerializedField::has_buffer_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void SerializedField::clear_buffer_length() {
  _impl_.buffer_length_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t SerializedField::buffer_length() const {
  // @@protoc_insertion_point(field_get:exec.shared.SerializedField.buffer_length)
  return _internal_buffer_length();
}
inline void SerializedField::set_buffer_length(::int32_t value) {
  _internal_set_buffer_length(value);
  // @@protoc_insertion_point(field_set:exec.shared.SerializedField.buffer_length)
}
inline ::int32_t SerializedField::_internal_buffer_length() const {
  return _impl_.buffer_length_;
}
inline void SerializedField::_internal_set_buffer_length(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.buffer_length_ = value;
}

// -------------------------------------------------------------------

// NodeStatus

// optional int32 node_id = 1;
inline bool NodeStatus::has_node_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NodeStatus::clear_node_id() {
  _impl_.node_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t NodeStatus::node_id() const {
  // @@protoc_insertion_point(field_get:exec.shared.NodeStatus.node_id)
  return _internal_node_id();
}
inline void NodeStatus::set_node_id(::int32_t value) {
  _internal_set_node_id(value);
  // @@protoc_insertion_point(field_set:exec.shared.NodeStatus.node_id)
}
inline ::int32_t NodeStatus::_internal_node_id() const {
  return _impl_.node_id_;
}
inline void NodeStatus::_internal_set_node_id(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.node_id_ = value;
}

// optional int64 memory_footprint = 2;
inline bool NodeStatus::has_memory_footprint() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NodeStatus::clear_memory_footprint() {
  _impl_.memory_footprint_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t NodeStatus::memory_footprint() const {
  // @@protoc_insertion_point(field_get:exec.shared.NodeStatus.memory_footprint)
  return _internal_memory_footprint();
}
inline void NodeStatus::set_memory_footprint(::int64_t value) {
  _internal_set_memory_footprint(value);
  // @@protoc_insertion_point(field_set:exec.shared.NodeStatus.memory_footprint)
}
inline ::int64_t NodeStatus::_internal_memory_footprint() const {
  return _impl_.memory_footprint_;
}
inline void NodeStatus::_internal_set_memory_footprint(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.memory_footprint_ = value;
}

// -------------------------------------------------------------------

// QueryResult

// optional .exec.shared.QueryResult.QueryState query_state = 1;
inline bool QueryResult::has_query_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void QueryResult::clear_query_state() {
  _impl_.query_state_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::exec::shared::QueryResult_QueryState QueryResult::query_state() const {
  // @@protoc_insertion_point(field_get:exec.shared.QueryResult.query_state)
  return _internal_query_state();
}
inline void QueryResult::set_query_state(::exec::shared::QueryResult_QueryState value) {
   _internal_set_query_state(value);
  // @@protoc_insertion_point(field_set:exec.shared.QueryResult.query_state)
}
inline ::exec::shared::QueryResult_QueryState QueryResult::_internal_query_state() const {
  return static_cast<::exec::shared::QueryResult_QueryState>(_impl_.query_state_);
}
inline void QueryResult::_internal_set_query_state(::exec::shared::QueryResult_QueryState value) {
  assert(::exec::shared::QueryResult_QueryState_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.query_state_ = value;
}

// optional .exec.shared.QueryId query_id = 2;
inline bool QueryResult::has_query_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.query_id_ != nullptr);
  return value;
}
inline void QueryResult::clear_query_id() {
  if (_impl_.query_id_ != nullptr) _impl_.query_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::exec::shared::QueryId& QueryResult::_internal_query_id() const {
  const ::exec::shared::QueryId* p = _impl_.query_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::exec::shared::QueryId&>(
      ::exec::shared::_QueryId_default_instance_);
}
inline const ::exec::shared::QueryId& QueryResult::query_id() const {
  // @@protoc_insertion_point(field_get:exec.shared.QueryResult.query_id)
  return _internal_query_id();
}
inline void QueryResult::unsafe_arena_set_allocated_query_id(
    ::exec::shared::QueryId* query_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.query_id_);
  }
  _impl_.query_id_ = query_id;
  if (query_id) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:exec.shared.QueryResult.query_id)
}
inline ::exec::shared::QueryId* QueryResult::release_query_id() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::exec::shared::QueryId* temp = _impl_.query_id_;
  _impl_.query_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exec::shared::QueryId* QueryResult::unsafe_arena_release_query_id() {
  // @@protoc_insertion_point(field_release:exec.shared.QueryResult.query_id)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::exec::shared::QueryId* temp = _impl_.query_id_;
  _impl_.query_id_ = nullptr;
  return temp;
}
inline ::exec::shared::QueryId* QueryResult::_internal_mutable_query_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.query_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::exec::shared::QueryId>(GetArenaForAllocation());
    _impl_.query_id_ = p;
  }
  return _impl_.query_id_;
}
inline ::exec::shared::QueryId* QueryResult::mutable_query_id() {
  ::exec::shared::QueryId* _msg = _internal_mutable_query_id();
  // @@protoc_insertion_point(field_mutable:exec.shared.QueryResult.query_id)
  return _msg;
}
inline void QueryResult::set_allocated_query_id(::exec::shared::QueryId* query_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.query_id_;
  }
  if (query_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(query_id);
    if (message_arena != submessage_arena) {
      query_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, query_id, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.query_id_ = query_id;
  // @@protoc_insertion_point(field_set_allocated:exec.shared.QueryResult.query_id)
}

// repeated .exec.shared.DrillPBError error = 3;
inline int QueryResult::_internal_error_size() const {
  return _impl_.error_.size();
}
inline int QueryResult::error_size() const {
  return _internal_error_size();
}
inline void QueryResult::clear_error() {
  _impl_.error_.Clear();
}
inline ::exec::shared::DrillPBError* QueryResult::mutable_error(int index) {
  // @@protoc_insertion_point(field_mutable:exec.shared.QueryResult.error)
  return _impl_.error_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::shared::DrillPBError >*
QueryResult::mutable_error() {
  // @@protoc_insertion_point(field_mutable_list:exec.shared.QueryResult.error)
  return &_impl_.error_;
}
inline const ::exec::shared::DrillPBError& QueryResult::_internal_error(int index) const {
  return _impl_.error_.Get(index);
}
inline const ::exec::shared::DrillPBError& QueryResult::error(int index) const {
  // @@protoc_insertion_point(field_get:exec.shared.QueryResult.error)
  return _internal_error(index);
}
inline ::exec::shared::DrillPBError* QueryResult::_internal_add_error() {
  return _impl_.error_.Add();
}
inline ::exec::shared::DrillPBError* QueryResult::add_error() {
  ::exec::shared::DrillPBError* _add = _internal_add_error();
  // @@protoc_insertion_point(field_add:exec.shared.QueryResult.error)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::shared::DrillPBError >&
QueryResult::error() const {
  // @@protoc_insertion_point(field_list:exec.shared.QueryResult.error)
  return _impl_.error_;
}

// -------------------------------------------------------------------

// QueryData

// optional .exec.shared.QueryId query_id = 1;
inline bool QueryData::has_query_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.query_id_ != nullptr);
  return value;
}
inline void QueryData::clear_query_id() {
  if (_impl_.query_id_ != nullptr) _impl_.query_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::exec::shared::QueryId& QueryData::_internal_query_id() const {
  const ::exec::shared::QueryId* p = _impl_.query_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::exec::shared::QueryId&>(
      ::exec::shared::_QueryId_default_instance_);
}
inline const ::exec::shared::QueryId& QueryData::query_id() const {
  // @@protoc_insertion_point(field_get:exec.shared.QueryData.query_id)
  return _internal_query_id();
}
inline void QueryData::unsafe_arena_set_allocated_query_id(
    ::exec::shared::QueryId* query_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.query_id_);
  }
  _impl_.query_id_ = query_id;
  if (query_id) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:exec.shared.QueryData.query_id)
}
inline ::exec::shared::QueryId* QueryData::release_query_id() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::exec::shared::QueryId* temp = _impl_.query_id_;
  _impl_.query_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exec::shared::QueryId* QueryData::unsafe_arena_release_query_id() {
  // @@protoc_insertion_point(field_release:exec.shared.QueryData.query_id)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::exec::shared::QueryId* temp = _impl_.query_id_;
  _impl_.query_id_ = nullptr;
  return temp;
}
inline ::exec::shared::QueryId* QueryData::_internal_mutable_query_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.query_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::exec::shared::QueryId>(GetArenaForAllocation());
    _impl_.query_id_ = p;
  }
  return _impl_.query_id_;
}
inline ::exec::shared::QueryId* QueryData::mutable_query_id() {
  ::exec::shared::QueryId* _msg = _internal_mutable_query_id();
  // @@protoc_insertion_point(field_mutable:exec.shared.QueryData.query_id)
  return _msg;
}
inline void QueryData::set_allocated_query_id(::exec::shared::QueryId* query_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.query_id_;
  }
  if (query_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(query_id);
    if (message_arena != submessage_arena) {
      query_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, query_id, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.query_id_ = query_id;
  // @@protoc_insertion_point(field_set_allocated:exec.shared.QueryData.query_id)
}

// optional int32 row_count = 2;
inline bool QueryData::has_row_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void QueryData::clear_row_count() {
  _impl_.row_count_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t QueryData::row_count() const {
  // @@protoc_insertion_point(field_get:exec.shared.QueryData.row_count)
  return _internal_row_count();
}
inline void QueryData::set_row_count(::int32_t value) {
  _internal_set_row_count(value);
  // @@protoc_insertion_point(field_set:exec.shared.QueryData.row_count)
}
inline ::int32_t QueryData::_internal_row_count() const {
  return _impl_.row_count_;
}
inline void QueryData::_internal_set_row_count(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.row_count_ = value;
}

// optional .exec.shared.RecordBatchDef def = 3;
inline bool QueryData::has_def() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.def_ != nullptr);
  return value;
}
inline void QueryData::clear_def() {
  if (_impl_.def_ != nullptr) _impl_.def_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::exec::shared::RecordBatchDef& QueryData::_internal_def() const {
  const ::exec::shared::RecordBatchDef* p = _impl_.def_;
  return p != nullptr ? *p : reinterpret_cast<const ::exec::shared::RecordBatchDef&>(
      ::exec::shared::_RecordBatchDef_default_instance_);
}
inline const ::exec::shared::RecordBatchDef& QueryData::def() const {
  // @@protoc_insertion_point(field_get:exec.shared.QueryData.def)
  return _internal_def();
}
inline void QueryData::unsafe_arena_set_allocated_def(
    ::exec::shared::RecordBatchDef* def) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.def_);
  }
  _impl_.def_ = def;
  if (def) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:exec.shared.QueryData.def)
}
inline ::exec::shared::RecordBatchDef* QueryData::release_def() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::exec::shared::RecordBatchDef* temp = _impl_.def_;
  _impl_.def_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exec::shared::RecordBatchDef* QueryData::unsafe_arena_release_def() {
  // @@protoc_insertion_point(field_release:exec.shared.QueryData.def)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::exec::shared::RecordBatchDef* temp = _impl_.def_;
  _impl_.def_ = nullptr;
  return temp;
}
inline ::exec::shared::RecordBatchDef* QueryData::_internal_mutable_def() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.def_ == nullptr) {
    auto* p = CreateMaybeMessage<::exec::shared::RecordBatchDef>(GetArenaForAllocation());
    _impl_.def_ = p;
  }
  return _impl_.def_;
}
inline ::exec::shared::RecordBatchDef* QueryData::mutable_def() {
  ::exec::shared::RecordBatchDef* _msg = _internal_mutable_def();
  // @@protoc_insertion_point(field_mutable:exec.shared.QueryData.def)
  return _msg;
}
inline void QueryData::set_allocated_def(::exec::shared::RecordBatchDef* def) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.def_;
  }
  if (def) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(def);
    if (message_arena != submessage_arena) {
      def = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, def, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.def_ = def;
  // @@protoc_insertion_point(field_set_allocated:exec.shared.QueryData.def)
}

// optional int32 affected_rows_count = 4;
inline bool QueryData::has_affected_rows_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void QueryData::clear_affected_rows_count() {
  _impl_.affected_rows_count_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t QueryData::affected_rows_count() const {
  // @@protoc_insertion_point(field_get:exec.shared.QueryData.affected_rows_count)
  return _internal_affected_rows_count();
}
inline void QueryData::set_affected_rows_count(::int32_t value) {
  _internal_set_affected_rows_count(value);
  // @@protoc_insertion_point(field_set:exec.shared.QueryData.affected_rows_count)
}
inline ::int32_t QueryData::_internal_affected_rows_count() const {
  return _impl_.affected_rows_count_;
}
inline void QueryData::_internal_set_affected_rows_count(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.affected_rows_count_ = value;
}

// -------------------------------------------------------------------

// QueryInfo

// optional string query = 1;
inline bool QueryInfo::has_query() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void QueryInfo::clear_query() {
  _impl_.query_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& QueryInfo::query() const {
  // @@protoc_insertion_point(field_get:exec.shared.QueryInfo.query)
  return _internal_query();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryInfo::set_query(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.query_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.shared.QueryInfo.query)
}
inline std::string* QueryInfo::mutable_query() {
  std::string* _s = _internal_mutable_query();
  // @@protoc_insertion_point(field_mutable:exec.shared.QueryInfo.query)
  return _s;
}
inline const std::string& QueryInfo::_internal_query() const {
  return _impl_.query_.Get();
}
inline void QueryInfo::_internal_set_query(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.query_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryInfo::_internal_mutable_query() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.query_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryInfo::release_query() {
  // @@protoc_insertion_point(field_release:exec.shared.QueryInfo.query)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.query_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.query_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void QueryInfo::set_allocated_query(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.query_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.query_.IsDefault()) {
          _impl_.query_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.shared.QueryInfo.query)
}

// optional int64 start = 2;
inline bool QueryInfo::has_start() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void QueryInfo::clear_start() {
  _impl_.start_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int64_t QueryInfo::start() const {
  // @@protoc_insertion_point(field_get:exec.shared.QueryInfo.start)
  return _internal_start();
}
inline void QueryInfo::set_start(::int64_t value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:exec.shared.QueryInfo.start)
}
inline ::int64_t QueryInfo::_internal_start() const {
  return _impl_.start_;
}
inline void QueryInfo::_internal_set_start(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.start_ = value;
}

// optional .exec.shared.QueryResult.QueryState state = 3;
inline bool QueryInfo::has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void QueryInfo::clear_state() {
  _impl_.state_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::exec::shared::QueryResult_QueryState QueryInfo::state() const {
  // @@protoc_insertion_point(field_get:exec.shared.QueryInfo.state)
  return _internal_state();
}
inline void QueryInfo::set_state(::exec::shared::QueryResult_QueryState value) {
   _internal_set_state(value);
  // @@protoc_insertion_point(field_set:exec.shared.QueryInfo.state)
}
inline ::exec::shared::QueryResult_QueryState QueryInfo::_internal_state() const {
  return static_cast<::exec::shared::QueryResult_QueryState>(_impl_.state_);
}
inline void QueryInfo::_internal_set_state(::exec::shared::QueryResult_QueryState value) {
  assert(::exec::shared::QueryResult_QueryState_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.state_ = value;
}

// optional string user = 4 [default = "-"];
inline bool QueryInfo::has_user() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void QueryInfo::clear_user() {
  _impl_.user_.ClearToDefault(::exec::shared::QueryInfo::Impl_::_i_give_permission_to_break_this_code_default_user_, GetArenaForAllocation());
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& QueryInfo::user() const {
  // @@protoc_insertion_point(field_get:exec.shared.QueryInfo.user)
  if (_impl_.user_.IsDefault()) {
    return Impl_::_i_give_permission_to_break_this_code_default_user_.get();
  }
  return _internal_user();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryInfo::set_user(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.user_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.shared.QueryInfo.user)
}
inline std::string* QueryInfo::mutable_user() {
  std::string* _s = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:exec.shared.QueryInfo.user)
  return _s;
}
inline const std::string& QueryInfo::_internal_user() const {
  return _impl_.user_.Get();
}
inline void QueryInfo::_internal_set_user(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.user_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryInfo::_internal_mutable_user() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.user_.Mutable(::exec::shared::QueryInfo::Impl_::_i_give_permission_to_break_this_code_default_user_, GetArenaForAllocation());
}
inline std::string* QueryInfo::release_user() {
  // @@protoc_insertion_point(field_release:exec.shared.QueryInfo.user)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  return _impl_.user_.Release();
}
inline void QueryInfo::set_allocated_user(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.user_.SetAllocated(value, GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:exec.shared.QueryInfo.user)
}

// optional .exec.DrillbitEndpoint foreman = 5;
inline bool QueryInfo::has_foreman() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.foreman_ != nullptr);
  return value;
}
inline const ::exec::DrillbitEndpoint& QueryInfo::_internal_foreman() const {
  const ::exec::DrillbitEndpoint* p = _impl_.foreman_;
  return p != nullptr ? *p : reinterpret_cast<const ::exec::DrillbitEndpoint&>(
      ::exec::_DrillbitEndpoint_default_instance_);
}
inline const ::exec::DrillbitEndpoint& QueryInfo::foreman() const {
  // @@protoc_insertion_point(field_get:exec.shared.QueryInfo.foreman)
  return _internal_foreman();
}
inline void QueryInfo::unsafe_arena_set_allocated_foreman(
    ::exec::DrillbitEndpoint* foreman) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.foreman_);
  }
  _impl_.foreman_ = foreman;
  if (foreman) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:exec.shared.QueryInfo.foreman)
}
inline ::exec::DrillbitEndpoint* QueryInfo::release_foreman() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::exec::DrillbitEndpoint* temp = _impl_.foreman_;
  _impl_.foreman_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exec::DrillbitEndpoint* QueryInfo::unsafe_arena_release_foreman() {
  // @@protoc_insertion_point(field_release:exec.shared.QueryInfo.foreman)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::exec::DrillbitEndpoint* temp = _impl_.foreman_;
  _impl_.foreman_ = nullptr;
  return temp;
}
inline ::exec::DrillbitEndpoint* QueryInfo::_internal_mutable_foreman() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.foreman_ == nullptr) {
    auto* p = CreateMaybeMessage<::exec::DrillbitEndpoint>(GetArenaForAllocation());
    _impl_.foreman_ = p;
  }
  return _impl_.foreman_;
}
inline ::exec::DrillbitEndpoint* QueryInfo::mutable_foreman() {
  ::exec::DrillbitEndpoint* _msg = _internal_mutable_foreman();
  // @@protoc_insertion_point(field_mutable:exec.shared.QueryInfo.foreman)
  return _msg;
}
inline void QueryInfo::set_allocated_foreman(::exec::DrillbitEndpoint* foreman) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.foreman_);
  }
  if (foreman) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(foreman));
    if (message_arena != submessage_arena) {
      foreman = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, foreman, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.foreman_ = foreman;
  // @@protoc_insertion_point(field_set_allocated:exec.shared.QueryInfo.foreman)
}

// optional string options_json = 6;
inline bool QueryInfo::has_options_json() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void QueryInfo::clear_options_json() {
  _impl_.options_json_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& QueryInfo::options_json() const {
  // @@protoc_insertion_point(field_get:exec.shared.QueryInfo.options_json)
  return _internal_options_json();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryInfo::set_options_json(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.options_json_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.shared.QueryInfo.options_json)
}
inline std::string* QueryInfo::mutable_options_json() {
  std::string* _s = _internal_mutable_options_json();
  // @@protoc_insertion_point(field_mutable:exec.shared.QueryInfo.options_json)
  return _s;
}
inline const std::string& QueryInfo::_internal_options_json() const {
  return _impl_.options_json_.Get();
}
inline void QueryInfo::_internal_set_options_json(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;


  _impl_.options_json_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryInfo::_internal_mutable_options_json() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.options_json_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryInfo::release_options_json() {
  // @@protoc_insertion_point(field_release:exec.shared.QueryInfo.options_json)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.options_json_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.options_json_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void QueryInfo::set_allocated_options_json(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.options_json_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.options_json_.IsDefault()) {
          _impl_.options_json_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.shared.QueryInfo.options_json)
}

// optional double total_cost = 7;
inline bool QueryInfo::has_total_cost() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void QueryInfo::clear_total_cost() {
  _impl_.total_cost_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline double QueryInfo::total_cost() const {
  // @@protoc_insertion_point(field_get:exec.shared.QueryInfo.total_cost)
  return _internal_total_cost();
}
inline void QueryInfo::set_total_cost(double value) {
  _internal_set_total_cost(value);
  // @@protoc_insertion_point(field_set:exec.shared.QueryInfo.total_cost)
}
inline double QueryInfo::_internal_total_cost() const {
  return _impl_.total_cost_;
}
inline void QueryInfo::_internal_set_total_cost(double value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.total_cost_ = value;
}

// optional string queue_name = 8 [default = "-"];
inline bool QueryInfo::has_queue_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void QueryInfo::clear_queue_name() {
  _impl_.queue_name_.ClearToDefault(::exec::shared::QueryInfo::Impl_::_i_give_permission_to_break_this_code_default_queue_name_, GetArenaForAllocation());
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& QueryInfo::queue_name() const {
  // @@protoc_insertion_point(field_get:exec.shared.QueryInfo.queue_name)
  if (_impl_.queue_name_.IsDefault()) {
    return Impl_::_i_give_permission_to_break_this_code_default_queue_name_.get();
  }
  return _internal_queue_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryInfo::set_queue_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.queue_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.shared.QueryInfo.queue_name)
}
inline std::string* QueryInfo::mutable_queue_name() {
  std::string* _s = _internal_mutable_queue_name();
  // @@protoc_insertion_point(field_mutable:exec.shared.QueryInfo.queue_name)
  return _s;
}
inline const std::string& QueryInfo::_internal_queue_name() const {
  return _impl_.queue_name_.Get();
}
inline void QueryInfo::_internal_set_queue_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;


  _impl_.queue_name_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryInfo::_internal_mutable_queue_name() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.queue_name_.Mutable(::exec::shared::QueryInfo::Impl_::_i_give_permission_to_break_this_code_default_queue_name_, GetArenaForAllocation());
}
inline std::string* QueryInfo::release_queue_name() {
  // @@protoc_insertion_point(field_release:exec.shared.QueryInfo.queue_name)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  return _impl_.queue_name_.Release();
}
inline void QueryInfo::set_allocated_queue_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.queue_name_.SetAllocated(value, GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:exec.shared.QueryInfo.queue_name)
}

// -------------------------------------------------------------------

// QueryProfile

// optional .exec.shared.QueryId id = 1;
inline bool QueryProfile::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.id_ != nullptr);
  return value;
}
inline void QueryProfile::clear_id() {
  if (_impl_.id_ != nullptr) _impl_.id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const ::exec::shared::QueryId& QueryProfile::_internal_id() const {
  const ::exec::shared::QueryId* p = _impl_.id_;
  return p != nullptr ? *p : reinterpret_cast<const ::exec::shared::QueryId&>(
      ::exec::shared::_QueryId_default_instance_);
}
inline const ::exec::shared::QueryId& QueryProfile::id() const {
  // @@protoc_insertion_point(field_get:exec.shared.QueryProfile.id)
  return _internal_id();
}
inline void QueryProfile::unsafe_arena_set_allocated_id(
    ::exec::shared::QueryId* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.id_);
  }
  _impl_.id_ = id;
  if (id) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:exec.shared.QueryProfile.id)
}
inline ::exec::shared::QueryId* QueryProfile::release_id() {
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::exec::shared::QueryId* temp = _impl_.id_;
  _impl_.id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exec::shared::QueryId* QueryProfile::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:exec.shared.QueryProfile.id)
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::exec::shared::QueryId* temp = _impl_.id_;
  _impl_.id_ = nullptr;
  return temp;
}
inline ::exec::shared::QueryId* QueryProfile::_internal_mutable_id() {
  _impl_._has_bits_[0] |= 0x00000400u;
  if (_impl_.id_ == nullptr) {
    auto* p = CreateMaybeMessage<::exec::shared::QueryId>(GetArenaForAllocation());
    _impl_.id_ = p;
  }
  return _impl_.id_;
}
inline ::exec::shared::QueryId* QueryProfile::mutable_id() {
  ::exec::shared::QueryId* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:exec.shared.QueryProfile.id)
  return _msg;
}
inline void QueryProfile::set_allocated_id(::exec::shared::QueryId* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.id_;
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(id);
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  _impl_.id_ = id;
  // @@protoc_insertion_point(field_set_allocated:exec.shared.QueryProfile.id)
}

// optional .exec.shared.QueryType type = 2;
inline bool QueryProfile::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline void QueryProfile::clear_type() {
  _impl_.type_ = 1;
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline ::exec::shared::QueryType QueryProfile::type() const {
  // @@protoc_insertion_point(field_get:exec.shared.QueryProfile.type)
  return _internal_type();
}
inline void QueryProfile::set_type(::exec::shared::QueryType value) {
   _internal_set_type(value);
  // @@protoc_insertion_point(field_set:exec.shared.QueryProfile.type)
}
inline ::exec::shared::QueryType QueryProfile::_internal_type() const {
  return static_cast<::exec::shared::QueryType>(_impl_.type_);
}
inline void QueryProfile::_internal_set_type(::exec::shared::QueryType value) {
  assert(::exec::shared::QueryType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00200000u;
  _impl_.type_ = value;
}

// optional int64 start = 3;
inline bool QueryProfile::has_start() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline void QueryProfile::clear_start() {
  _impl_.start_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline ::int64_t QueryProfile::start() const {
  // @@protoc_insertion_point(field_get:exec.shared.QueryProfile.start)
  return _internal_start();
}
inline void QueryProfile::set_start(::int64_t value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:exec.shared.QueryProfile.start)
}
inline ::int64_t QueryProfile::_internal_start() const {
  return _impl_.start_;
}
inline void QueryProfile::_internal_set_start(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.start_ = value;
}

// optional int64 end = 4;
inline bool QueryProfile::has_end() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline void QueryProfile::clear_end() {
  _impl_.end_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline ::int64_t QueryProfile::end() const {
  // @@protoc_insertion_point(field_get:exec.shared.QueryProfile.end)
  return _internal_end();
}
inline void QueryProfile::set_end(::int64_t value) {
  _internal_set_end(value);
  // @@protoc_insertion_point(field_set:exec.shared.QueryProfile.end)
}
inline ::int64_t QueryProfile::_internal_end() const {
  return _impl_.end_;
}
inline void QueryProfile::_internal_set_end(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.end_ = value;
}

// optional string query = 5;
inline bool QueryProfile::has_query() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void QueryProfile::clear_query() {
  _impl_.query_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& QueryProfile::query() const {
  // @@protoc_insertion_point(field_get:exec.shared.QueryProfile.query)
  return _internal_query();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryProfile::set_query(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.query_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.shared.QueryProfile.query)
}
inline std::string* QueryProfile::mutable_query() {
  std::string* _s = _internal_mutable_query();
  // @@protoc_insertion_point(field_mutable:exec.shared.QueryProfile.query)
  return _s;
}
inline const std::string& QueryProfile::_internal_query() const {
  return _impl_.query_.Get();
}
inline void QueryProfile::_internal_set_query(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.query_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryProfile::_internal_mutable_query() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.query_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryProfile::release_query() {
  // @@protoc_insertion_point(field_release:exec.shared.QueryProfile.query)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.query_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.query_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void QueryProfile::set_allocated_query(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.query_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.query_.IsDefault()) {
          _impl_.query_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.shared.QueryProfile.query)
}

// optional string plan = 6;
inline bool QueryProfile::has_plan() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void QueryProfile::clear_plan() {
  _impl_.plan_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& QueryProfile::plan() const {
  // @@protoc_insertion_point(field_get:exec.shared.QueryProfile.plan)
  return _internal_plan();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryProfile::set_plan(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.plan_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.shared.QueryProfile.plan)
}
inline std::string* QueryProfile::mutable_plan() {
  std::string* _s = _internal_mutable_plan();
  // @@protoc_insertion_point(field_mutable:exec.shared.QueryProfile.plan)
  return _s;
}
inline const std::string& QueryProfile::_internal_plan() const {
  return _impl_.plan_.Get();
}
inline void QueryProfile::_internal_set_plan(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.plan_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryProfile::_internal_mutable_plan() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.plan_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryProfile::release_plan() {
  // @@protoc_insertion_point(field_release:exec.shared.QueryProfile.plan)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.plan_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.plan_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void QueryProfile::set_allocated_plan(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.plan_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.plan_.IsDefault()) {
          _impl_.plan_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.shared.QueryProfile.plan)
}

// optional .exec.DrillbitEndpoint foreman = 7;
inline bool QueryProfile::has_foreman() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.foreman_ != nullptr);
  return value;
}
inline const ::exec::DrillbitEndpoint& QueryProfile::_internal_foreman() const {
  const ::exec::DrillbitEndpoint* p = _impl_.foreman_;
  return p != nullptr ? *p : reinterpret_cast<const ::exec::DrillbitEndpoint&>(
      ::exec::_DrillbitEndpoint_default_instance_);
}
inline const ::exec::DrillbitEndpoint& QueryProfile::foreman() const {
  // @@protoc_insertion_point(field_get:exec.shared.QueryProfile.foreman)
  return _internal_foreman();
}
inline void QueryProfile::unsafe_arena_set_allocated_foreman(
    ::exec::DrillbitEndpoint* foreman) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.foreman_);
  }
  _impl_.foreman_ = foreman;
  if (foreman) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:exec.shared.QueryProfile.foreman)
}
inline ::exec::DrillbitEndpoint* QueryProfile::release_foreman() {
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::exec::DrillbitEndpoint* temp = _impl_.foreman_;
  _impl_.foreman_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exec::DrillbitEndpoint* QueryProfile::unsafe_arena_release_foreman() {
  // @@protoc_insertion_point(field_release:exec.shared.QueryProfile.foreman)
  _impl_._has_bits_[0] &= ~0x00000800u;
  ::exec::DrillbitEndpoint* temp = _impl_.foreman_;
  _impl_.foreman_ = nullptr;
  return temp;
}
inline ::exec::DrillbitEndpoint* QueryProfile::_internal_mutable_foreman() {
  _impl_._has_bits_[0] |= 0x00000800u;
  if (_impl_.foreman_ == nullptr) {
    auto* p = CreateMaybeMessage<::exec::DrillbitEndpoint>(GetArenaForAllocation());
    _impl_.foreman_ = p;
  }
  return _impl_.foreman_;
}
inline ::exec::DrillbitEndpoint* QueryProfile::mutable_foreman() {
  ::exec::DrillbitEndpoint* _msg = _internal_mutable_foreman();
  // @@protoc_insertion_point(field_mutable:exec.shared.QueryProfile.foreman)
  return _msg;
}
inline void QueryProfile::set_allocated_foreman(::exec::DrillbitEndpoint* foreman) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.foreman_);
  }
  if (foreman) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(foreman));
    if (message_arena != submessage_arena) {
      foreman = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, foreman, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  _impl_.foreman_ = foreman;
  // @@protoc_insertion_point(field_set_allocated:exec.shared.QueryProfile.foreman)
}

// optional .exec.shared.QueryResult.QueryState state = 8;
inline bool QueryProfile::has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline void QueryProfile::clear_state() {
  _impl_.state_ = 0;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline ::exec::shared::QueryResult_QueryState QueryProfile::state() const {
  // @@protoc_insertion_point(field_get:exec.shared.QueryProfile.state)
  return _internal_state();
}
inline void QueryProfile::set_state(::exec::shared::QueryResult_QueryState value) {
   _internal_set_state(value);
  // @@protoc_insertion_point(field_set:exec.shared.QueryProfile.state)
}
inline ::exec::shared::QueryResult_QueryState QueryProfile::_internal_state() const {
  return static_cast<::exec::shared::QueryResult_QueryState>(_impl_.state_);
}
inline void QueryProfile::_internal_set_state(::exec::shared::QueryResult_QueryState value) {
  assert(::exec::shared::QueryResult_QueryState_IsValid(value));
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.state_ = value;
}

// optional int32 total_fragments = 9;
inline bool QueryProfile::has_total_fragments() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline void QueryProfile::clear_total_fragments() {
  _impl_.total_fragments_ = 0;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline ::int32_t QueryProfile::total_fragments() const {
  // @@protoc_insertion_point(field_get:exec.shared.QueryProfile.total_fragments)
  return _internal_total_fragments();
}
inline void QueryProfile::set_total_fragments(::int32_t value) {
  _internal_set_total_fragments(value);
  // @@protoc_insertion_point(field_set:exec.shared.QueryProfile.total_fragments)
}
inline ::int32_t QueryProfile::_internal_total_fragments() const {
  return _impl_.total_fragments_;
}
inline void QueryProfile::_internal_set_total_fragments(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.total_fragments_ = value;
}

// optional int32 finished_fragments = 10;
inline bool QueryProfile::has_finished_fragments() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline void QueryProfile::clear_finished_fragments() {
  _impl_.finished_fragments_ = 0;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline ::int32_t QueryProfile::finished_fragments() const {
  // @@protoc_insertion_point(field_get:exec.shared.QueryProfile.finished_fragments)
  return _internal_finished_fragments();
}
inline void QueryProfile::set_finished_fragments(::int32_t value) {
  _internal_set_finished_fragments(value);
  // @@protoc_insertion_point(field_set:exec.shared.QueryProfile.finished_fragments)
}
inline ::int32_t QueryProfile::_internal_finished_fragments() const {
  return _impl_.finished_fragments_;
}
inline void QueryProfile::_internal_set_finished_fragments(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.finished_fragments_ = value;
}

// repeated .exec.shared.MajorFragmentProfile fragment_profile = 11;
inline int QueryProfile::_internal_fragment_profile_size() const {
  return _impl_.fragment_profile_.size();
}
inline int QueryProfile::fragment_profile_size() const {
  return _internal_fragment_profile_size();
}
inline void QueryProfile::clear_fragment_profile() {
  _impl_.fragment_profile_.Clear();
}
inline ::exec::shared::MajorFragmentProfile* QueryProfile::mutable_fragment_profile(int index) {
  // @@protoc_insertion_point(field_mutable:exec.shared.QueryProfile.fragment_profile)
  return _impl_.fragment_profile_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::shared::MajorFragmentProfile >*
QueryProfile::mutable_fragment_profile() {
  // @@protoc_insertion_point(field_mutable_list:exec.shared.QueryProfile.fragment_profile)
  return &_impl_.fragment_profile_;
}
inline const ::exec::shared::MajorFragmentProfile& QueryProfile::_internal_fragment_profile(int index) const {
  return _impl_.fragment_profile_.Get(index);
}
inline const ::exec::shared::MajorFragmentProfile& QueryProfile::fragment_profile(int index) const {
  // @@protoc_insertion_point(field_get:exec.shared.QueryProfile.fragment_profile)
  return _internal_fragment_profile(index);
}
inline ::exec::shared::MajorFragmentProfile* QueryProfile::_internal_add_fragment_profile() {
  return _impl_.fragment_profile_.Add();
}
inline ::exec::shared::MajorFragmentProfile* QueryProfile::add_fragment_profile() {
  ::exec::shared::MajorFragmentProfile* _add = _internal_add_fragment_profile();
  // @@protoc_insertion_point(field_add:exec.shared.QueryProfile.fragment_profile)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::shared::MajorFragmentProfile >&
QueryProfile::fragment_profile() const {
  // @@protoc_insertion_point(field_list:exec.shared.QueryProfile.fragment_profile)
  return _impl_.fragment_profile_;
}

// optional string user = 12 [default = "-"];
inline bool QueryProfile::has_user() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void QueryProfile::clear_user() {
  _impl_.user_.ClearToDefault(::exec::shared::QueryProfile::Impl_::_i_give_permission_to_break_this_code_default_user_, GetArenaForAllocation());
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& QueryProfile::user() const {
  // @@protoc_insertion_point(field_get:exec.shared.QueryProfile.user)
  if (_impl_.user_.IsDefault()) {
    return Impl_::_i_give_permission_to_break_this_code_default_user_.get();
  }
  return _internal_user();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryProfile::set_user(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.user_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.shared.QueryProfile.user)
}
inline std::string* QueryProfile::mutable_user() {
  std::string* _s = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:exec.shared.QueryProfile.user)
  return _s;
}
inline const std::string& QueryProfile::_internal_user() const {
  return _impl_.user_.Get();
}
inline void QueryProfile::_internal_set_user(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;


  _impl_.user_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryProfile::_internal_mutable_user() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.user_.Mutable(::exec::shared::QueryProfile::Impl_::_i_give_permission_to_break_this_code_default_user_, GetArenaForAllocation());
}
inline std::string* QueryProfile::release_user() {
  // @@protoc_insertion_point(field_release:exec.shared.QueryProfile.user)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  return _impl_.user_.Release();
}
inline void QueryProfile::set_allocated_user(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.user_.SetAllocated(value, GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:exec.shared.QueryProfile.user)
}

// optional string error = 13;
inline bool QueryProfile::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void QueryProfile::clear_error() {
  _impl_.error_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& QueryProfile::error() const {
  // @@protoc_insertion_point(field_get:exec.shared.QueryProfile.error)
  return _internal_error();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryProfile::set_error(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.error_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.shared.QueryProfile.error)
}
inline std::string* QueryProfile::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:exec.shared.QueryProfile.error)
  return _s;
}
inline const std::string& QueryProfile::_internal_error() const {
  return _impl_.error_.Get();
}
inline void QueryProfile::_internal_set_error(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;


  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryProfile::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.error_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryProfile::release_error() {
  // @@protoc_insertion_point(field_release:exec.shared.QueryProfile.error)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.error_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.error_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void QueryProfile::set_allocated_error(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.error_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.error_.IsDefault()) {
          _impl_.error_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.shared.QueryProfile.error)
}

// optional string verboseError = 14;
inline bool QueryProfile::has_verboseerror() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void QueryProfile::clear_verboseerror() {
  _impl_.verboseerror_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& QueryProfile::verboseerror() const {
  // @@protoc_insertion_point(field_get:exec.shared.QueryProfile.verboseError)
  return _internal_verboseerror();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryProfile::set_verboseerror(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.verboseerror_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.shared.QueryProfile.verboseError)
}
inline std::string* QueryProfile::mutable_verboseerror() {
  std::string* _s = _internal_mutable_verboseerror();
  // @@protoc_insertion_point(field_mutable:exec.shared.QueryProfile.verboseError)
  return _s;
}
inline const std::string& QueryProfile::_internal_verboseerror() const {
  return _impl_.verboseerror_.Get();
}
inline void QueryProfile::_internal_set_verboseerror(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;


  _impl_.verboseerror_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryProfile::_internal_mutable_verboseerror() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.verboseerror_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryProfile::release_verboseerror() {
  // @@protoc_insertion_point(field_release:exec.shared.QueryProfile.verboseError)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.verboseerror_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.verboseerror_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void QueryProfile::set_allocated_verboseerror(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.verboseerror_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.verboseerror_.IsDefault()) {
          _impl_.verboseerror_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.shared.QueryProfile.verboseError)
}

// optional string error_id = 15;
inline bool QueryProfile::has_error_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void QueryProfile::clear_error_id() {
  _impl_.error_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& QueryProfile::error_id() const {
  // @@protoc_insertion_point(field_get:exec.shared.QueryProfile.error_id)
  return _internal_error_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryProfile::set_error_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.error_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.shared.QueryProfile.error_id)
}
inline std::string* QueryProfile::mutable_error_id() {
  std::string* _s = _internal_mutable_error_id();
  // @@protoc_insertion_point(field_mutable:exec.shared.QueryProfile.error_id)
  return _s;
}
inline const std::string& QueryProfile::_internal_error_id() const {
  return _impl_.error_id_.Get();
}
inline void QueryProfile::_internal_set_error_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;


  _impl_.error_id_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryProfile::_internal_mutable_error_id() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.error_id_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryProfile::release_error_id() {
  // @@protoc_insertion_point(field_release:exec.shared.QueryProfile.error_id)
  if ((_impl_._has_bits_[0] & 0x00000020u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* released = _impl_.error_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.error_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void QueryProfile::set_allocated_error_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.error_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.error_id_.IsDefault()) {
          _impl_.error_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.shared.QueryProfile.error_id)
}

// optional string error_node = 16;
inline bool QueryProfile::has_error_node() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void QueryProfile::clear_error_node() {
  _impl_.error_node_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& QueryProfile::error_node() const {
  // @@protoc_insertion_point(field_get:exec.shared.QueryProfile.error_node)
  return _internal_error_node();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryProfile::set_error_node(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.error_node_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.shared.QueryProfile.error_node)
}
inline std::string* QueryProfile::mutable_error_node() {
  std::string* _s = _internal_mutable_error_node();
  // @@protoc_insertion_point(field_mutable:exec.shared.QueryProfile.error_node)
  return _s;
}
inline const std::string& QueryProfile::_internal_error_node() const {
  return _impl_.error_node_.Get();
}
inline void QueryProfile::_internal_set_error_node(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000040u;


  _impl_.error_node_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryProfile::_internal_mutable_error_node() {
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.error_node_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryProfile::release_error_node() {
  // @@protoc_insertion_point(field_release:exec.shared.QueryProfile.error_node)
  if ((_impl_._has_bits_[0] & 0x00000040u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* released = _impl_.error_node_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.error_node_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void QueryProfile::set_allocated_error_node(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.error_node_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.error_node_.IsDefault()) {
          _impl_.error_node_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.shared.QueryProfile.error_node)
}

// optional string options_json = 17;
inline bool QueryProfile::has_options_json() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void QueryProfile::clear_options_json() {
  _impl_.options_json_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const std::string& QueryProfile::options_json() const {
  // @@protoc_insertion_point(field_get:exec.shared.QueryProfile.options_json)
  return _internal_options_json();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryProfile::set_options_json(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.options_json_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.shared.QueryProfile.options_json)
}
inline std::string* QueryProfile::mutable_options_json() {
  std::string* _s = _internal_mutable_options_json();
  // @@protoc_insertion_point(field_mutable:exec.shared.QueryProfile.options_json)
  return _s;
}
inline const std::string& QueryProfile::_internal_options_json() const {
  return _impl_.options_json_.Get();
}
inline void QueryProfile::_internal_set_options_json(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000080u;


  _impl_.options_json_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryProfile::_internal_mutable_options_json() {
  _impl_._has_bits_[0] |= 0x00000080u;
  return _impl_.options_json_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryProfile::release_options_json() {
  // @@protoc_insertion_point(field_release:exec.shared.QueryProfile.options_json)
  if ((_impl_._has_bits_[0] & 0x00000080u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000080u;
  auto* released = _impl_.options_json_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.options_json_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void QueryProfile::set_allocated_options_json(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.options_json_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.options_json_.IsDefault()) {
          _impl_.options_json_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.shared.QueryProfile.options_json)
}

// optional int64 planEnd = 18;
inline bool QueryProfile::has_planend() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline void QueryProfile::clear_planend() {
  _impl_.planend_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline ::int64_t QueryProfile::planend() const {
  // @@protoc_insertion_point(field_get:exec.shared.QueryProfile.planEnd)
  return _internal_planend();
}
inline void QueryProfile::set_planend(::int64_t value) {
  _internal_set_planend(value);
  // @@protoc_insertion_point(field_set:exec.shared.QueryProfile.planEnd)
}
inline ::int64_t QueryProfile::_internal_planend() const {
  return _impl_.planend_;
}
inline void QueryProfile::_internal_set_planend(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00040000u;
  _impl_.planend_ = value;
}

// optional int64 queueWaitEnd = 19;
inline bool QueryProfile::has_queuewaitend() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline void QueryProfile::clear_queuewaitend() {
  _impl_.queuewaitend_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline ::int64_t QueryProfile::queuewaitend() const {
  // @@protoc_insertion_point(field_get:exec.shared.QueryProfile.queueWaitEnd)
  return _internal_queuewaitend();
}
inline void QueryProfile::set_queuewaitend(::int64_t value) {
  _internal_set_queuewaitend(value);
  // @@protoc_insertion_point(field_set:exec.shared.QueryProfile.queueWaitEnd)
}
inline ::int64_t QueryProfile::_internal_queuewaitend() const {
  return _impl_.queuewaitend_;
}
inline void QueryProfile::_internal_set_queuewaitend(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00080000u;
  _impl_.queuewaitend_ = value;
}

// optional double total_cost = 20;
inline bool QueryProfile::has_total_cost() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline void QueryProfile::clear_total_cost() {
  _impl_.total_cost_ = 0;
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline double QueryProfile::total_cost() const {
  // @@protoc_insertion_point(field_get:exec.shared.QueryProfile.total_cost)
  return _internal_total_cost();
}
inline void QueryProfile::set_total_cost(double value) {
  _internal_set_total_cost(value);
  // @@protoc_insertion_point(field_set:exec.shared.QueryProfile.total_cost)
}
inline double QueryProfile::_internal_total_cost() const {
  return _impl_.total_cost_;
}
inline void QueryProfile::_internal_set_total_cost(double value) {
  _impl_._has_bits_[0] |= 0x00100000u;
  _impl_.total_cost_ = value;
}

// optional string queue_name = 21 [default = "-"];
inline bool QueryProfile::has_queue_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void QueryProfile::clear_queue_name() {
  _impl_.queue_name_.ClearToDefault(::exec::shared::QueryProfile::Impl_::_i_give_permission_to_break_this_code_default_queue_name_, GetArenaForAllocation());
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const std::string& QueryProfile::queue_name() const {
  // @@protoc_insertion_point(field_get:exec.shared.QueryProfile.queue_name)
  if (_impl_.queue_name_.IsDefault()) {
    return Impl_::_i_give_permission_to_break_this_code_default_queue_name_.get();
  }
  return _internal_queue_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryProfile::set_queue_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.queue_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.shared.QueryProfile.queue_name)
}
inline std::string* QueryProfile::mutable_queue_name() {
  std::string* _s = _internal_mutable_queue_name();
  // @@protoc_insertion_point(field_mutable:exec.shared.QueryProfile.queue_name)
  return _s;
}
inline const std::string& QueryProfile::_internal_queue_name() const {
  return _impl_.queue_name_.Get();
}
inline void QueryProfile::_internal_set_queue_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000100u;


  _impl_.queue_name_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryProfile::_internal_mutable_queue_name() {
  _impl_._has_bits_[0] |= 0x00000100u;
  return _impl_.queue_name_.Mutable(::exec::shared::QueryProfile::Impl_::_i_give_permission_to_break_this_code_default_queue_name_, GetArenaForAllocation());
}
inline std::string* QueryProfile::release_queue_name() {
  // @@protoc_insertion_point(field_release:exec.shared.QueryProfile.queue_name)
  if ((_impl_._has_bits_[0] & 0x00000100u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000100u;
  return _impl_.queue_name_.Release();
}
inline void QueryProfile::set_allocated_queue_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.queue_name_.SetAllocated(value, GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:exec.shared.QueryProfile.queue_name)
}

// optional string queryId = 22;
inline bool QueryProfile::has_queryid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void QueryProfile::clear_queryid() {
  _impl_.queryid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const std::string& QueryProfile::queryid() const {
  // @@protoc_insertion_point(field_get:exec.shared.QueryProfile.queryId)
  return _internal_queryid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryProfile::set_queryid(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.queryid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.shared.QueryProfile.queryId)
}
inline std::string* QueryProfile::mutable_queryid() {
  std::string* _s = _internal_mutable_queryid();
  // @@protoc_insertion_point(field_mutable:exec.shared.QueryProfile.queryId)
  return _s;
}
inline const std::string& QueryProfile::_internal_queryid() const {
  return _impl_.queryid_.Get();
}
inline void QueryProfile::_internal_set_queryid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000200u;


  _impl_.queryid_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryProfile::_internal_mutable_queryid() {
  _impl_._has_bits_[0] |= 0x00000200u;
  return _impl_.queryid_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryProfile::release_queryid() {
  // @@protoc_insertion_point(field_release:exec.shared.QueryProfile.queryId)
  if ((_impl_._has_bits_[0] & 0x00000200u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000200u;
  auto* released = _impl_.queryid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.queryid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void QueryProfile::set_allocated_queryid(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.queryid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.queryid_.IsDefault()) {
          _impl_.queryid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.shared.QueryProfile.queryId)
}

// optional int32 autoLimit = 23;
inline bool QueryProfile::has_autolimit() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline void QueryProfile::clear_autolimit() {
  _impl_.autolimit_ = 0;
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline ::int32_t QueryProfile::autolimit() const {
  // @@protoc_insertion_point(field_get:exec.shared.QueryProfile.autoLimit)
  return _internal_autolimit();
}
inline void QueryProfile::set_autolimit(::int32_t value) {
  _internal_set_autolimit(value);
  // @@protoc_insertion_point(field_set:exec.shared.QueryProfile.autoLimit)
}
inline ::int32_t QueryProfile::_internal_autolimit() const {
  return _impl_.autolimit_;
}
inline void QueryProfile::_internal_set_autolimit(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.autolimit_ = value;
}

// -------------------------------------------------------------------

// MajorFragmentProfile

// optional int32 major_fragment_id = 1;
inline bool MajorFragmentProfile::has_major_fragment_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MajorFragmentProfile::clear_major_fragment_id() {
  _impl_.major_fragment_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t MajorFragmentProfile::major_fragment_id() const {
  // @@protoc_insertion_point(field_get:exec.shared.MajorFragmentProfile.major_fragment_id)
  return _internal_major_fragment_id();
}
inline void MajorFragmentProfile::set_major_fragment_id(::int32_t value) {
  _internal_set_major_fragment_id(value);
  // @@protoc_insertion_point(field_set:exec.shared.MajorFragmentProfile.major_fragment_id)
}
inline ::int32_t MajorFragmentProfile::_internal_major_fragment_id() const {
  return _impl_.major_fragment_id_;
}
inline void MajorFragmentProfile::_internal_set_major_fragment_id(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.major_fragment_id_ = value;
}

// repeated .exec.shared.MinorFragmentProfile minor_fragment_profile = 2;
inline int MajorFragmentProfile::_internal_minor_fragment_profile_size() const {
  return _impl_.minor_fragment_profile_.size();
}
inline int MajorFragmentProfile::minor_fragment_profile_size() const {
  return _internal_minor_fragment_profile_size();
}
inline void MajorFragmentProfile::clear_minor_fragment_profile() {
  _impl_.minor_fragment_profile_.Clear();
}
inline ::exec::shared::MinorFragmentProfile* MajorFragmentProfile::mutable_minor_fragment_profile(int index) {
  // @@protoc_insertion_point(field_mutable:exec.shared.MajorFragmentProfile.minor_fragment_profile)
  return _impl_.minor_fragment_profile_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::shared::MinorFragmentProfile >*
MajorFragmentProfile::mutable_minor_fragment_profile() {
  // @@protoc_insertion_point(field_mutable_list:exec.shared.MajorFragmentProfile.minor_fragment_profile)
  return &_impl_.minor_fragment_profile_;
}
inline const ::exec::shared::MinorFragmentProfile& MajorFragmentProfile::_internal_minor_fragment_profile(int index) const {
  return _impl_.minor_fragment_profile_.Get(index);
}
inline const ::exec::shared::MinorFragmentProfile& MajorFragmentProfile::minor_fragment_profile(int index) const {
  // @@protoc_insertion_point(field_get:exec.shared.MajorFragmentProfile.minor_fragment_profile)
  return _internal_minor_fragment_profile(index);
}
inline ::exec::shared::MinorFragmentProfile* MajorFragmentProfile::_internal_add_minor_fragment_profile() {
  return _impl_.minor_fragment_profile_.Add();
}
inline ::exec::shared::MinorFragmentProfile* MajorFragmentProfile::add_minor_fragment_profile() {
  ::exec::shared::MinorFragmentProfile* _add = _internal_add_minor_fragment_profile();
  // @@protoc_insertion_point(field_add:exec.shared.MajorFragmentProfile.minor_fragment_profile)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::shared::MinorFragmentProfile >&
MajorFragmentProfile::minor_fragment_profile() const {
  // @@protoc_insertion_point(field_list:exec.shared.MajorFragmentProfile.minor_fragment_profile)
  return _impl_.minor_fragment_profile_;
}

// -------------------------------------------------------------------

// MinorFragmentProfile

// optional .exec.shared.FragmentState state = 1;
inline bool MinorFragmentProfile::has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void MinorFragmentProfile::clear_state() {
  _impl_.state_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::exec::shared::FragmentState MinorFragmentProfile::state() const {
  // @@protoc_insertion_point(field_get:exec.shared.MinorFragmentProfile.state)
  return _internal_state();
}
inline void MinorFragmentProfile::set_state(::exec::shared::FragmentState value) {
   _internal_set_state(value);
  // @@protoc_insertion_point(field_set:exec.shared.MinorFragmentProfile.state)
}
inline ::exec::shared::FragmentState MinorFragmentProfile::_internal_state() const {
  return static_cast<::exec::shared::FragmentState>(_impl_.state_);
}
inline void MinorFragmentProfile::_internal_set_state(::exec::shared::FragmentState value) {
  assert(::exec::shared::FragmentState_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.state_ = value;
}

// optional .exec.shared.DrillPBError error = 2;
inline bool MinorFragmentProfile::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_ != nullptr);
  return value;
}
inline void MinorFragmentProfile::clear_error() {
  if (_impl_.error_ != nullptr) _impl_.error_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::exec::shared::DrillPBError& MinorFragmentProfile::_internal_error() const {
  const ::exec::shared::DrillPBError* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::exec::shared::DrillPBError&>(
      ::exec::shared::_DrillPBError_default_instance_);
}
inline const ::exec::shared::DrillPBError& MinorFragmentProfile::error() const {
  // @@protoc_insertion_point(field_get:exec.shared.MinorFragmentProfile.error)
  return _internal_error();
}
inline void MinorFragmentProfile::unsafe_arena_set_allocated_error(
    ::exec::shared::DrillPBError* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:exec.shared.MinorFragmentProfile.error)
}
inline ::exec::shared::DrillPBError* MinorFragmentProfile::release_error() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::exec::shared::DrillPBError* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exec::shared::DrillPBError* MinorFragmentProfile::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:exec.shared.MinorFragmentProfile.error)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::exec::shared::DrillPBError* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::exec::shared::DrillPBError* MinorFragmentProfile::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::exec::shared::DrillPBError>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::exec::shared::DrillPBError* MinorFragmentProfile::mutable_error() {
  ::exec::shared::DrillPBError* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:exec.shared.MinorFragmentProfile.error)
  return _msg;
}
inline void MinorFragmentProfile::set_allocated_error(::exec::shared::DrillPBError* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:exec.shared.MinorFragmentProfile.error)
}

// optional int32 minor_fragment_id = 3;
inline bool MinorFragmentProfile::has_minor_fragment_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void MinorFragmentProfile::clear_minor_fragment_id() {
  _impl_.minor_fragment_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t MinorFragmentProfile::minor_fragment_id() const {
  // @@protoc_insertion_point(field_get:exec.shared.MinorFragmentProfile.minor_fragment_id)
  return _internal_minor_fragment_id();
}
inline void MinorFragmentProfile::set_minor_fragment_id(::int32_t value) {
  _internal_set_minor_fragment_id(value);
  // @@protoc_insertion_point(field_set:exec.shared.MinorFragmentProfile.minor_fragment_id)
}
inline ::int32_t MinorFragmentProfile::_internal_minor_fragment_id() const {
  return _impl_.minor_fragment_id_;
}
inline void MinorFragmentProfile::_internal_set_minor_fragment_id(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.minor_fragment_id_ = value;
}

// repeated .exec.shared.OperatorProfile operator_profile = 4;
inline int MinorFragmentProfile::_internal_operator_profile_size() const {
  return _impl_.operator_profile_.size();
}
inline int MinorFragmentProfile::operator_profile_size() const {
  return _internal_operator_profile_size();
}
inline void MinorFragmentProfile::clear_operator_profile() {
  _impl_.operator_profile_.Clear();
}
inline ::exec::shared::OperatorProfile* MinorFragmentProfile::mutable_operator_profile(int index) {
  // @@protoc_insertion_point(field_mutable:exec.shared.MinorFragmentProfile.operator_profile)
  return _impl_.operator_profile_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::shared::OperatorProfile >*
MinorFragmentProfile::mutable_operator_profile() {
  // @@protoc_insertion_point(field_mutable_list:exec.shared.MinorFragmentProfile.operator_profile)
  return &_impl_.operator_profile_;
}
inline const ::exec::shared::OperatorProfile& MinorFragmentProfile::_internal_operator_profile(int index) const {
  return _impl_.operator_profile_.Get(index);
}
inline const ::exec::shared::OperatorProfile& MinorFragmentProfile::operator_profile(int index) const {
  // @@protoc_insertion_point(field_get:exec.shared.MinorFragmentProfile.operator_profile)
  return _internal_operator_profile(index);
}
inline ::exec::shared::OperatorProfile* MinorFragmentProfile::_internal_add_operator_profile() {
  return _impl_.operator_profile_.Add();
}
inline ::exec::shared::OperatorProfile* MinorFragmentProfile::add_operator_profile() {
  ::exec::shared::OperatorProfile* _add = _internal_add_operator_profile();
  // @@protoc_insertion_point(field_add:exec.shared.MinorFragmentProfile.operator_profile)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::shared::OperatorProfile >&
MinorFragmentProfile::operator_profile() const {
  // @@protoc_insertion_point(field_list:exec.shared.MinorFragmentProfile.operator_profile)
  return _impl_.operator_profile_;
}

// optional int64 start_time = 5;
inline bool MinorFragmentProfile::has_start_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void MinorFragmentProfile::clear_start_time() {
  _impl_.start_time_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int64_t MinorFragmentProfile::start_time() const {
  // @@protoc_insertion_point(field_get:exec.shared.MinorFragmentProfile.start_time)
  return _internal_start_time();
}
inline void MinorFragmentProfile::set_start_time(::int64_t value) {
  _internal_set_start_time(value);
  // @@protoc_insertion_point(field_set:exec.shared.MinorFragmentProfile.start_time)
}
inline ::int64_t MinorFragmentProfile::_internal_start_time() const {
  return _impl_.start_time_;
}
inline void MinorFragmentProfile::_internal_set_start_time(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.start_time_ = value;
}

// optional int64 end_time = 6;
inline bool MinorFragmentProfile::has_end_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void MinorFragmentProfile::clear_end_time() {
  _impl_.end_time_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int64_t MinorFragmentProfile::end_time() const {
  // @@protoc_insertion_point(field_get:exec.shared.MinorFragmentProfile.end_time)
  return _internal_end_time();
}
inline void MinorFragmentProfile::set_end_time(::int64_t value) {
  _internal_set_end_time(value);
  // @@protoc_insertion_point(field_set:exec.shared.MinorFragmentProfile.end_time)
}
inline ::int64_t MinorFragmentProfile::_internal_end_time() const {
  return _impl_.end_time_;
}
inline void MinorFragmentProfile::_internal_set_end_time(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.end_time_ = value;
}

// optional int64 memory_used = 7;
inline bool MinorFragmentProfile::has_memory_used() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void MinorFragmentProfile::clear_memory_used() {
  _impl_.memory_used_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::int64_t MinorFragmentProfile::memory_used() const {
  // @@protoc_insertion_point(field_get:exec.shared.MinorFragmentProfile.memory_used)
  return _internal_memory_used();
}
inline void MinorFragmentProfile::set_memory_used(::int64_t value) {
  _internal_set_memory_used(value);
  // @@protoc_insertion_point(field_set:exec.shared.MinorFragmentProfile.memory_used)
}
inline ::int64_t MinorFragmentProfile::_internal_memory_used() const {
  return _impl_.memory_used_;
}
inline void MinorFragmentProfile::_internal_set_memory_used(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.memory_used_ = value;
}

// optional int64 max_memory_used = 8;
inline bool MinorFragmentProfile::has_max_memory_used() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void MinorFragmentProfile::clear_max_memory_used() {
  _impl_.max_memory_used_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::int64_t MinorFragmentProfile::max_memory_used() const {
  // @@protoc_insertion_point(field_get:exec.shared.MinorFragmentProfile.max_memory_used)
  return _internal_max_memory_used();
}
inline void MinorFragmentProfile::set_max_memory_used(::int64_t value) {
  _internal_set_max_memory_used(value);
  // @@protoc_insertion_point(field_set:exec.shared.MinorFragmentProfile.max_memory_used)
}
inline ::int64_t MinorFragmentProfile::_internal_max_memory_used() const {
  return _impl_.max_memory_used_;
}
inline void MinorFragmentProfile::_internal_set_max_memory_used(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.max_memory_used_ = value;
}

// optional .exec.DrillbitEndpoint endpoint = 9;
inline bool MinorFragmentProfile::has_endpoint() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.endpoint_ != nullptr);
  return value;
}
inline const ::exec::DrillbitEndpoint& MinorFragmentProfile::_internal_endpoint() const {
  const ::exec::DrillbitEndpoint* p = _impl_.endpoint_;
  return p != nullptr ? *p : reinterpret_cast<const ::exec::DrillbitEndpoint&>(
      ::exec::_DrillbitEndpoint_default_instance_);
}
inline const ::exec::DrillbitEndpoint& MinorFragmentProfile::endpoint() const {
  // @@protoc_insertion_point(field_get:exec.shared.MinorFragmentProfile.endpoint)
  return _internal_endpoint();
}
inline void MinorFragmentProfile::unsafe_arena_set_allocated_endpoint(
    ::exec::DrillbitEndpoint* endpoint) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.endpoint_);
  }
  _impl_.endpoint_ = endpoint;
  if (endpoint) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:exec.shared.MinorFragmentProfile.endpoint)
}
inline ::exec::DrillbitEndpoint* MinorFragmentProfile::release_endpoint() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::exec::DrillbitEndpoint* temp = _impl_.endpoint_;
  _impl_.endpoint_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exec::DrillbitEndpoint* MinorFragmentProfile::unsafe_arena_release_endpoint() {
  // @@protoc_insertion_point(field_release:exec.shared.MinorFragmentProfile.endpoint)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::exec::DrillbitEndpoint* temp = _impl_.endpoint_;
  _impl_.endpoint_ = nullptr;
  return temp;
}
inline ::exec::DrillbitEndpoint* MinorFragmentProfile::_internal_mutable_endpoint() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.endpoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::exec::DrillbitEndpoint>(GetArenaForAllocation());
    _impl_.endpoint_ = p;
  }
  return _impl_.endpoint_;
}
inline ::exec::DrillbitEndpoint* MinorFragmentProfile::mutable_endpoint() {
  ::exec::DrillbitEndpoint* _msg = _internal_mutable_endpoint();
  // @@protoc_insertion_point(field_mutable:exec.shared.MinorFragmentProfile.endpoint)
  return _msg;
}
inline void MinorFragmentProfile::set_allocated_endpoint(::exec::DrillbitEndpoint* endpoint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.endpoint_);
  }
  if (endpoint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(endpoint));
    if (message_arena != submessage_arena) {
      endpoint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, endpoint, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.endpoint_ = endpoint;
  // @@protoc_insertion_point(field_set_allocated:exec.shared.MinorFragmentProfile.endpoint)
}

// optional int64 last_update = 10;
inline bool MinorFragmentProfile::has_last_update() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void MinorFragmentProfile::clear_last_update() {
  _impl_.last_update_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::int64_t MinorFragmentProfile::last_update() const {
  // @@protoc_insertion_point(field_get:exec.shared.MinorFragmentProfile.last_update)
  return _internal_last_update();
}
inline void MinorFragmentProfile::set_last_update(::int64_t value) {
  _internal_set_last_update(value);
  // @@protoc_insertion_point(field_set:exec.shared.MinorFragmentProfile.last_update)
}
inline ::int64_t MinorFragmentProfile::_internal_last_update() const {
  return _impl_.last_update_;
}
inline void MinorFragmentProfile::_internal_set_last_update(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.last_update_ = value;
}

// optional int64 last_progress = 11;
inline bool MinorFragmentProfile::has_last_progress() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void MinorFragmentProfile::clear_last_progress() {
  _impl_.last_progress_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::int64_t MinorFragmentProfile::last_progress() const {
  // @@protoc_insertion_point(field_get:exec.shared.MinorFragmentProfile.last_progress)
  return _internal_last_progress();
}
inline void MinorFragmentProfile::set_last_progress(::int64_t value) {
  _internal_set_last_progress(value);
  // @@protoc_insertion_point(field_set:exec.shared.MinorFragmentProfile.last_progress)
}
inline ::int64_t MinorFragmentProfile::_internal_last_progress() const {
  return _impl_.last_progress_;
}
inline void MinorFragmentProfile::_internal_set_last_progress(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.last_progress_ = value;
}

// -------------------------------------------------------------------

// OperatorProfile

// repeated .exec.shared.StreamProfile input_profile = 1;
inline int OperatorProfile::_internal_input_profile_size() const {
  return _impl_.input_profile_.size();
}
inline int OperatorProfile::input_profile_size() const {
  return _internal_input_profile_size();
}
inline void OperatorProfile::clear_input_profile() {
  _impl_.input_profile_.Clear();
}
inline ::exec::shared::StreamProfile* OperatorProfile::mutable_input_profile(int index) {
  // @@protoc_insertion_point(field_mutable:exec.shared.OperatorProfile.input_profile)
  return _impl_.input_profile_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::shared::StreamProfile >*
OperatorProfile::mutable_input_profile() {
  // @@protoc_insertion_point(field_mutable_list:exec.shared.OperatorProfile.input_profile)
  return &_impl_.input_profile_;
}
inline const ::exec::shared::StreamProfile& OperatorProfile::_internal_input_profile(int index) const {
  return _impl_.input_profile_.Get(index);
}
inline const ::exec::shared::StreamProfile& OperatorProfile::input_profile(int index) const {
  // @@protoc_insertion_point(field_get:exec.shared.OperatorProfile.input_profile)
  return _internal_input_profile(index);
}
inline ::exec::shared::StreamProfile* OperatorProfile::_internal_add_input_profile() {
  return _impl_.input_profile_.Add();
}
inline ::exec::shared::StreamProfile* OperatorProfile::add_input_profile() {
  ::exec::shared::StreamProfile* _add = _internal_add_input_profile();
  // @@protoc_insertion_point(field_add:exec.shared.OperatorProfile.input_profile)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::shared::StreamProfile >&
OperatorProfile::input_profile() const {
  // @@protoc_insertion_point(field_list:exec.shared.OperatorProfile.input_profile)
  return _impl_.input_profile_;
}

// optional int32 operator_id = 3;
inline bool OperatorProfile::has_operator_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void OperatorProfile::clear_operator_id() {
  _impl_.operator_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t OperatorProfile::operator_id() const {
  // @@protoc_insertion_point(field_get:exec.shared.OperatorProfile.operator_id)
  return _internal_operator_id();
}
inline void OperatorProfile::set_operator_id(::int32_t value) {
  _internal_set_operator_id(value);
  // @@protoc_insertion_point(field_set:exec.shared.OperatorProfile.operator_id)
}
inline ::int32_t OperatorProfile::_internal_operator_id() const {
  return _impl_.operator_id_;
}
inline void OperatorProfile::_internal_set_operator_id(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.operator_id_ = value;
}

// optional int32 operator_type = 4 [deprecated = true];
inline bool OperatorProfile::has_operator_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void OperatorProfile::clear_operator_type() {
  _impl_.operator_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t OperatorProfile::operator_type() const {
  // @@protoc_insertion_point(field_get:exec.shared.OperatorProfile.operator_type)
  return _internal_operator_type();
}
inline void OperatorProfile::set_operator_type(::int32_t value) {
  _internal_set_operator_type(value);
  // @@protoc_insertion_point(field_set:exec.shared.OperatorProfile.operator_type)
}
inline ::int32_t OperatorProfile::_internal_operator_type() const {
  return _impl_.operator_type_;
}
inline void OperatorProfile::_internal_set_operator_type(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.operator_type_ = value;
}

// optional int64 setup_nanos = 5;
inline bool OperatorProfile::has_setup_nanos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void OperatorProfile::clear_setup_nanos() {
  _impl_.setup_nanos_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int64_t OperatorProfile::setup_nanos() const {
  // @@protoc_insertion_point(field_get:exec.shared.OperatorProfile.setup_nanos)
  return _internal_setup_nanos();
}
inline void OperatorProfile::set_setup_nanos(::int64_t value) {
  _internal_set_setup_nanos(value);
  // @@protoc_insertion_point(field_set:exec.shared.OperatorProfile.setup_nanos)
}
inline ::int64_t OperatorProfile::_internal_setup_nanos() const {
  return _impl_.setup_nanos_;
}
inline void OperatorProfile::_internal_set_setup_nanos(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.setup_nanos_ = value;
}

// optional int64 process_nanos = 6;
inline bool OperatorProfile::has_process_nanos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void OperatorProfile::clear_process_nanos() {
  _impl_.process_nanos_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int64_t OperatorProfile::process_nanos() const {
  // @@protoc_insertion_point(field_get:exec.shared.OperatorProfile.process_nanos)
  return _internal_process_nanos();
}
inline void OperatorProfile::set_process_nanos(::int64_t value) {
  _internal_set_process_nanos(value);
  // @@protoc_insertion_point(field_set:exec.shared.OperatorProfile.process_nanos)
}
inline ::int64_t OperatorProfile::_internal_process_nanos() const {
  return _impl_.process_nanos_;
}
inline void OperatorProfile::_internal_set_process_nanos(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.process_nanos_ = value;
}

// optional int64 peak_local_memory_allocated = 7;
inline bool OperatorProfile::has_peak_local_memory_allocated() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void OperatorProfile::clear_peak_local_memory_allocated() {
  _impl_.peak_local_memory_allocated_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int64_t OperatorProfile::peak_local_memory_allocated() const {
  // @@protoc_insertion_point(field_get:exec.shared.OperatorProfile.peak_local_memory_allocated)
  return _internal_peak_local_memory_allocated();
}
inline void OperatorProfile::set_peak_local_memory_allocated(::int64_t value) {
  _internal_set_peak_local_memory_allocated(value);
  // @@protoc_insertion_point(field_set:exec.shared.OperatorProfile.peak_local_memory_allocated)
}
inline ::int64_t OperatorProfile::_internal_peak_local_memory_allocated() const {
  return _impl_.peak_local_memory_allocated_;
}
inline void OperatorProfile::_internal_set_peak_local_memory_allocated(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.peak_local_memory_allocated_ = value;
}

// repeated .exec.shared.MetricValue metric = 8;
inline int OperatorProfile::_internal_metric_size() const {
  return _impl_.metric_.size();
}
inline int OperatorProfile::metric_size() const {
  return _internal_metric_size();
}
inline void OperatorProfile::clear_metric() {
  _impl_.metric_.Clear();
}
inline ::exec::shared::MetricValue* OperatorProfile::mutable_metric(int index) {
  // @@protoc_insertion_point(field_mutable:exec.shared.OperatorProfile.metric)
  return _impl_.metric_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::shared::MetricValue >*
OperatorProfile::mutable_metric() {
  // @@protoc_insertion_point(field_mutable_list:exec.shared.OperatorProfile.metric)
  return &_impl_.metric_;
}
inline const ::exec::shared::MetricValue& OperatorProfile::_internal_metric(int index) const {
  return _impl_.metric_.Get(index);
}
inline const ::exec::shared::MetricValue& OperatorProfile::metric(int index) const {
  // @@protoc_insertion_point(field_get:exec.shared.OperatorProfile.metric)
  return _internal_metric(index);
}
inline ::exec::shared::MetricValue* OperatorProfile::_internal_add_metric() {
  return _impl_.metric_.Add();
}
inline ::exec::shared::MetricValue* OperatorProfile::add_metric() {
  ::exec::shared::MetricValue* _add = _internal_add_metric();
  // @@protoc_insertion_point(field_add:exec.shared.OperatorProfile.metric)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::shared::MetricValue >&
OperatorProfile::metric() const {
  // @@protoc_insertion_point(field_list:exec.shared.OperatorProfile.metric)
  return _impl_.metric_;
}

// optional int64 wait_nanos = 9;
inline bool OperatorProfile::has_wait_nanos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void OperatorProfile::clear_wait_nanos() {
  _impl_.wait_nanos_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::int64_t OperatorProfile::wait_nanos() const {
  // @@protoc_insertion_point(field_get:exec.shared.OperatorProfile.wait_nanos)
  return _internal_wait_nanos();
}
inline void OperatorProfile::set_wait_nanos(::int64_t value) {
  _internal_set_wait_nanos(value);
  // @@protoc_insertion_point(field_set:exec.shared.OperatorProfile.wait_nanos)
}
inline ::int64_t OperatorProfile::_internal_wait_nanos() const {
  return _impl_.wait_nanos_;
}
inline void OperatorProfile::_internal_set_wait_nanos(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.wait_nanos_ = value;
}

// optional string operator_type_name = 10;
inline bool OperatorProfile::has_operator_type_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void OperatorProfile::clear_operator_type_name() {
  _impl_.operator_type_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& OperatorProfile::operator_type_name() const {
  // @@protoc_insertion_point(field_get:exec.shared.OperatorProfile.operator_type_name)
  return _internal_operator_type_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OperatorProfile::set_operator_type_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.operator_type_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.shared.OperatorProfile.operator_type_name)
}
inline std::string* OperatorProfile::mutable_operator_type_name() {
  std::string* _s = _internal_mutable_operator_type_name();
  // @@protoc_insertion_point(field_mutable:exec.shared.OperatorProfile.operator_type_name)
  return _s;
}
inline const std::string& OperatorProfile::_internal_operator_type_name() const {
  return _impl_.operator_type_name_.Get();
}
inline void OperatorProfile::_internal_set_operator_type_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.operator_type_name_.Set(value, GetArenaForAllocation());
}
inline std::string* OperatorProfile::_internal_mutable_operator_type_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.operator_type_name_.Mutable( GetArenaForAllocation());
}
inline std::string* OperatorProfile::release_operator_type_name() {
  // @@protoc_insertion_point(field_release:exec.shared.OperatorProfile.operator_type_name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.operator_type_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.operator_type_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void OperatorProfile::set_allocated_operator_type_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.operator_type_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.operator_type_name_.IsDefault()) {
          _impl_.operator_type_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.shared.OperatorProfile.operator_type_name)
}

// -------------------------------------------------------------------

// StreamProfile

// optional int64 records = 1;
inline bool StreamProfile::has_records() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void StreamProfile::clear_records() {
  _impl_.records_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t StreamProfile::records() const {
  // @@protoc_insertion_point(field_get:exec.shared.StreamProfile.records)
  return _internal_records();
}
inline void StreamProfile::set_records(::int64_t value) {
  _internal_set_records(value);
  // @@protoc_insertion_point(field_set:exec.shared.StreamProfile.records)
}
inline ::int64_t StreamProfile::_internal_records() const {
  return _impl_.records_;
}
inline void StreamProfile::_internal_set_records(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.records_ = value;
}

// optional int64 batches = 2;
inline bool StreamProfile::has_batches() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void StreamProfile::clear_batches() {
  _impl_.batches_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int64_t StreamProfile::batches() const {
  // @@protoc_insertion_point(field_get:exec.shared.StreamProfile.batches)
  return _internal_batches();
}
inline void StreamProfile::set_batches(::int64_t value) {
  _internal_set_batches(value);
  // @@protoc_insertion_point(field_set:exec.shared.StreamProfile.batches)
}
inline ::int64_t StreamProfile::_internal_batches() const {
  return _impl_.batches_;
}
inline void StreamProfile::_internal_set_batches(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.batches_ = value;
}

// optional int64 schemas = 3;
inline bool StreamProfile::has_schemas() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void StreamProfile::clear_schemas() {
  _impl_.schemas_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int64_t StreamProfile::schemas() const {
  // @@protoc_insertion_point(field_get:exec.shared.StreamProfile.schemas)
  return _internal_schemas();
}
inline void StreamProfile::set_schemas(::int64_t value) {
  _internal_set_schemas(value);
  // @@protoc_insertion_point(field_set:exec.shared.StreamProfile.schemas)
}
inline ::int64_t StreamProfile::_internal_schemas() const {
  return _impl_.schemas_;
}
inline void StreamProfile::_internal_set_schemas(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.schemas_ = value;
}

// -------------------------------------------------------------------

// MetricValue

// optional int32 metric_id = 1;
inline bool MetricValue::has_metric_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void MetricValue::clear_metric_id() {
  _impl_.metric_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t MetricValue::metric_id() const {
  // @@protoc_insertion_point(field_get:exec.shared.MetricValue.metric_id)
  return _internal_metric_id();
}
inline void MetricValue::set_metric_id(::int32_t value) {
  _internal_set_metric_id(value);
  // @@protoc_insertion_point(field_set:exec.shared.MetricValue.metric_id)
}
inline ::int32_t MetricValue::_internal_metric_id() const {
  return _impl_.metric_id_;
}
inline void MetricValue::_internal_set_metric_id(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.metric_id_ = value;
}

// optional int64 long_value = 2;
inline bool MetricValue::has_long_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MetricValue::clear_long_value() {
  _impl_.long_value_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t MetricValue::long_value() const {
  // @@protoc_insertion_point(field_get:exec.shared.MetricValue.long_value)
  return _internal_long_value();
}
inline void MetricValue::set_long_value(::int64_t value) {
  _internal_set_long_value(value);
  // @@protoc_insertion_point(field_set:exec.shared.MetricValue.long_value)
}
inline ::int64_t MetricValue::_internal_long_value() const {
  return _impl_.long_value_;
}
inline void MetricValue::_internal_set_long_value(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.long_value_ = value;
}

// optional double double_value = 3;
inline bool MetricValue::has_double_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MetricValue::clear_double_value() {
  _impl_.double_value_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double MetricValue::double_value() const {
  // @@protoc_insertion_point(field_get:exec.shared.MetricValue.double_value)
  return _internal_double_value();
}
inline void MetricValue::set_double_value(double value) {
  _internal_set_double_value(value);
  // @@protoc_insertion_point(field_set:exec.shared.MetricValue.double_value)
}
inline double MetricValue::_internal_double_value() const {
  return _impl_.double_value_;
}
inline void MetricValue::_internal_set_double_value(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.double_value_ = value;
}

// -------------------------------------------------------------------

// Registry

// repeated .exec.shared.Jar jar = 1;
inline int Registry::_internal_jar_size() const {
  return _impl_.jar_.size();
}
inline int Registry::jar_size() const {
  return _internal_jar_size();
}
inline void Registry::clear_jar() {
  _impl_.jar_.Clear();
}
inline ::exec::shared::Jar* Registry::mutable_jar(int index) {
  // @@protoc_insertion_point(field_mutable:exec.shared.Registry.jar)
  return _impl_.jar_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::shared::Jar >*
Registry::mutable_jar() {
  // @@protoc_insertion_point(field_mutable_list:exec.shared.Registry.jar)
  return &_impl_.jar_;
}
inline const ::exec::shared::Jar& Registry::_internal_jar(int index) const {
  return _impl_.jar_.Get(index);
}
inline const ::exec::shared::Jar& Registry::jar(int index) const {
  // @@protoc_insertion_point(field_get:exec.shared.Registry.jar)
  return _internal_jar(index);
}
inline ::exec::shared::Jar* Registry::_internal_add_jar() {
  return _impl_.jar_.Add();
}
inline ::exec::shared::Jar* Registry::add_jar() {
  ::exec::shared::Jar* _add = _internal_add_jar();
  // @@protoc_insertion_point(field_add:exec.shared.Registry.jar)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::shared::Jar >&
Registry::jar() const {
  // @@protoc_insertion_point(field_list:exec.shared.Registry.jar)
  return _impl_.jar_;
}

// -------------------------------------------------------------------

// Jar

// optional string name = 1;
inline bool Jar::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Jar::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Jar::name() const {
  // @@protoc_insertion_point(field_get:exec.shared.Jar.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Jar::set_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.shared.Jar.name)
}
inline std::string* Jar::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:exec.shared.Jar.name)
  return _s;
}
inline const std::string& Jar::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Jar::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Jar::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* Jar::release_name() {
  // @@protoc_insertion_point(field_release:exec.shared.Jar.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Jar::set_allocated_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.shared.Jar.name)
}

// repeated string function_signature = 2;
inline int Jar::_internal_function_signature_size() const {
  return _impl_.function_signature_.size();
}
inline int Jar::function_signature_size() const {
  return _internal_function_signature_size();
}
inline void Jar::clear_function_signature() {
  _impl_.function_signature_.Clear();
}
inline std::string* Jar::add_function_signature() {
  std::string* _s = _internal_add_function_signature();
  // @@protoc_insertion_point(field_add_mutable:exec.shared.Jar.function_signature)
  return _s;
}
inline const std::string& Jar::_internal_function_signature(int index) const {
  return _impl_.function_signature_.Get(index);
}
inline const std::string& Jar::function_signature(int index) const {
  // @@protoc_insertion_point(field_get:exec.shared.Jar.function_signature)
  return _internal_function_signature(index);
}
inline std::string* Jar::mutable_function_signature(int index) {
  // @@protoc_insertion_point(field_mutable:exec.shared.Jar.function_signature)
  return _impl_.function_signature_.Mutable(index);
}
inline void Jar::set_function_signature(int index, const std::string& value) {
  _impl_.function_signature_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:exec.shared.Jar.function_signature)
}
inline void Jar::set_function_signature(int index, std::string&& value) {
  _impl_.function_signature_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:exec.shared.Jar.function_signature)
}
inline void Jar::set_function_signature(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _impl_.function_signature_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:exec.shared.Jar.function_signature)
}
inline void Jar::set_function_signature(int index, const char* value,
                              std::size_t size) {
  _impl_.function_signature_.Mutable(index)->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:exec.shared.Jar.function_signature)
}
inline void Jar::set_function_signature(int index, absl::string_view value) {
  _impl_.function_signature_.Mutable(index)->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:exec.shared.Jar.function_signature)
}
inline std::string* Jar::_internal_add_function_signature() { return _impl_.function_signature_.Add(); }
inline void Jar::add_function_signature(const std::string& value) {
  _impl_.function_signature_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:exec.shared.Jar.function_signature)
}
inline void Jar::add_function_signature(std::string&& value) {
  _impl_.function_signature_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:exec.shared.Jar.function_signature)
}
inline void Jar::add_function_signature(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _impl_.function_signature_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:exec.shared.Jar.function_signature)
}
inline void Jar::add_function_signature(const char* value, std::size_t size) {
  _impl_.function_signature_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:exec.shared.Jar.function_signature)
}
inline void Jar::add_function_signature(absl::string_view value) {
  _impl_.function_signature_.Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:exec.shared.Jar.function_signature)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Jar::function_signature() const {
  // @@protoc_insertion_point(field_list:exec.shared.Jar.function_signature)
  return _impl_.function_signature_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* Jar::mutable_function_signature() {
  // @@protoc_insertion_point(field_mutable_list:exec.shared.Jar.function_signature)
  return &_impl_.function_signature_;
}

// -------------------------------------------------------------------

// SaslMessage

// optional string mechanism = 1;
inline bool SaslMessage::has_mechanism() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SaslMessage::clear_mechanism() {
  _impl_.mechanism_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SaslMessage::mechanism() const {
  // @@protoc_insertion_point(field_get:exec.shared.SaslMessage.mechanism)
  return _internal_mechanism();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SaslMessage::set_mechanism(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.mechanism_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.shared.SaslMessage.mechanism)
}
inline std::string* SaslMessage::mutable_mechanism() {
  std::string* _s = _internal_mutable_mechanism();
  // @@protoc_insertion_point(field_mutable:exec.shared.SaslMessage.mechanism)
  return _s;
}
inline const std::string& SaslMessage::_internal_mechanism() const {
  return _impl_.mechanism_.Get();
}
inline void SaslMessage::_internal_set_mechanism(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.mechanism_.Set(value, GetArenaForAllocation());
}
inline std::string* SaslMessage::_internal_mutable_mechanism() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.mechanism_.Mutable( GetArenaForAllocation());
}
inline std::string* SaslMessage::release_mechanism() {
  // @@protoc_insertion_point(field_release:exec.shared.SaslMessage.mechanism)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.mechanism_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.mechanism_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SaslMessage::set_allocated_mechanism(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.mechanism_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.mechanism_.IsDefault()) {
          _impl_.mechanism_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.shared.SaslMessage.mechanism)
}

// optional bytes data = 2;
inline bool SaslMessage::has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SaslMessage::clear_data() {
  _impl_.data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SaslMessage::data() const {
  // @@protoc_insertion_point(field_get:exec.shared.SaslMessage.data)
  return _internal_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SaslMessage::set_data(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.shared.SaslMessage.data)
}
inline std::string* SaslMessage::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:exec.shared.SaslMessage.data)
  return _s;
}
inline const std::string& SaslMessage::_internal_data() const {
  return _impl_.data_.Get();
}
inline void SaslMessage::_internal_set_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* SaslMessage::_internal_mutable_data() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.data_.Mutable( GetArenaForAllocation());
}
inline std::string* SaslMessage::release_data() {
  // @@protoc_insertion_point(field_release:exec.shared.SaslMessage.data)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.data_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.data_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SaslMessage::set_allocated_data(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.data_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.data_.IsDefault()) {
          _impl_.data_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.shared.SaslMessage.data)
}

// optional .exec.shared.SaslStatus status = 3;
inline bool SaslMessage::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SaslMessage::clear_status() {
  _impl_.status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::exec::shared::SaslStatus SaslMessage::status() const {
  // @@protoc_insertion_point(field_get:exec.shared.SaslMessage.status)
  return _internal_status();
}
inline void SaslMessage::set_status(::exec::shared::SaslStatus value) {
   _internal_set_status(value);
  // @@protoc_insertion_point(field_set:exec.shared.SaslMessage.status)
}
inline ::exec::shared::SaslStatus SaslMessage::_internal_status() const {
  return static_cast<::exec::shared::SaslStatus>(_impl_.status_);
}
inline void SaslMessage::_internal_set_status(::exec::shared::SaslStatus value) {
  assert(::exec::shared::SaslStatus_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.status_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace shared
}  // namespace exec


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::exec::shared::DrillPBError_ErrorType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::exec::shared::DrillPBError_ErrorType>() {
  return ::exec::shared::DrillPBError_ErrorType_descriptor();
}
template <>
struct is_proto_enum<::exec::shared::NamePart_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::exec::shared::NamePart_Type>() {
  return ::exec::shared::NamePart_Type_descriptor();
}
template <>
struct is_proto_enum<::exec::shared::QueryResult_QueryState> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::exec::shared::QueryResult_QueryState>() {
  return ::exec::shared::QueryResult_QueryState_descriptor();
}
template <>
struct is_proto_enum<::exec::shared::RpcChannel> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::exec::shared::RpcChannel>() {
  return ::exec::shared::RpcChannel_descriptor();
}
template <>
struct is_proto_enum<::exec::shared::QueryType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::exec::shared::QueryType>() {
  return ::exec::shared::QueryType_descriptor();
}
template <>
struct is_proto_enum<::exec::shared::FragmentState> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::exec::shared::FragmentState>() {
  return ::exec::shared::FragmentState_descriptor();
}
template <>
struct is_proto_enum<::exec::shared::SaslStatus> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::exec::shared::SaslStatus>() {
  return ::exec::shared::SaslStatus_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_UserBitShared_2eproto_2epb_2eh
