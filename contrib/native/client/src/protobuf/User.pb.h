// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: User.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_User_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_User_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4022000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4022002 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "SchemaDef.pb.h"
#include "Types.pb.h"
#include "UserBitShared.pb.h"
#include "BitData.pb.h"
#include "BitControl.pb.h"
#include "ExecutionProtos.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_User_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_User_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_User_2eproto;
namespace exec {
namespace user {
class BitToUserHandshake;
struct BitToUserHandshakeDefaultTypeInternal;
extern BitToUserHandshakeDefaultTypeInternal _BitToUserHandshake_default_instance_;
class CancelQueryWithSessionHandle;
struct CancelQueryWithSessionHandleDefaultTypeInternal;
extern CancelQueryWithSessionHandleDefaultTypeInternal _CancelQueryWithSessionHandle_default_instance_;
class CatalogMetadata;
struct CatalogMetadataDefaultTypeInternal;
extern CatalogMetadataDefaultTypeInternal _CatalogMetadata_default_instance_;
class ColumnMetadata;
struct ColumnMetadataDefaultTypeInternal;
extern ColumnMetadataDefaultTypeInternal _ColumnMetadata_default_instance_;
class ConvertSupport;
struct ConvertSupportDefaultTypeInternal;
extern ConvertSupportDefaultTypeInternal _ConvertSupport_default_instance_;
class CreatePreparedStatementReq;
struct CreatePreparedStatementReqDefaultTypeInternal;
extern CreatePreparedStatementReqDefaultTypeInternal _CreatePreparedStatementReq_default_instance_;
class CreatePreparedStatementResp;
struct CreatePreparedStatementRespDefaultTypeInternal;
extern CreatePreparedStatementRespDefaultTypeInternal _CreatePreparedStatementResp_default_instance_;
class GetCatalogsReq;
struct GetCatalogsReqDefaultTypeInternal;
extern GetCatalogsReqDefaultTypeInternal _GetCatalogsReq_default_instance_;
class GetCatalogsResp;
struct GetCatalogsRespDefaultTypeInternal;
extern GetCatalogsRespDefaultTypeInternal _GetCatalogsResp_default_instance_;
class GetColumnsReq;
struct GetColumnsReqDefaultTypeInternal;
extern GetColumnsReqDefaultTypeInternal _GetColumnsReq_default_instance_;
class GetColumnsResp;
struct GetColumnsRespDefaultTypeInternal;
extern GetColumnsRespDefaultTypeInternal _GetColumnsResp_default_instance_;
class GetQueryPlanFragments;
struct GetQueryPlanFragmentsDefaultTypeInternal;
extern GetQueryPlanFragmentsDefaultTypeInternal _GetQueryPlanFragments_default_instance_;
class GetSchemasReq;
struct GetSchemasReqDefaultTypeInternal;
extern GetSchemasReqDefaultTypeInternal _GetSchemasReq_default_instance_;
class GetSchemasResp;
struct GetSchemasRespDefaultTypeInternal;
extern GetSchemasRespDefaultTypeInternal _GetSchemasResp_default_instance_;
class GetServerMetaReq;
struct GetServerMetaReqDefaultTypeInternal;
extern GetServerMetaReqDefaultTypeInternal _GetServerMetaReq_default_instance_;
class GetServerMetaResp;
struct GetServerMetaRespDefaultTypeInternal;
extern GetServerMetaRespDefaultTypeInternal _GetServerMetaResp_default_instance_;
class GetTablesReq;
struct GetTablesReqDefaultTypeInternal;
extern GetTablesReqDefaultTypeInternal _GetTablesReq_default_instance_;
class GetTablesResp;
struct GetTablesRespDefaultTypeInternal;
extern GetTablesRespDefaultTypeInternal _GetTablesResp_default_instance_;
class LikeFilter;
struct LikeFilterDefaultTypeInternal;
extern LikeFilterDefaultTypeInternal _LikeFilter_default_instance_;
class NewSessionRequest;
struct NewSessionRequestDefaultTypeInternal;
extern NewSessionRequestDefaultTypeInternal _NewSessionRequest_default_instance_;
class PreparedStatement;
struct PreparedStatementDefaultTypeInternal;
extern PreparedStatementDefaultTypeInternal _PreparedStatement_default_instance_;
class PreparedStatementHandle;
struct PreparedStatementHandleDefaultTypeInternal;
extern PreparedStatementHandleDefaultTypeInternal _PreparedStatementHandle_default_instance_;
class Property;
struct PropertyDefaultTypeInternal;
extern PropertyDefaultTypeInternal _Property_default_instance_;
class QueryPlanFragments;
struct QueryPlanFragmentsDefaultTypeInternal;
extern QueryPlanFragmentsDefaultTypeInternal _QueryPlanFragments_default_instance_;
class RequestResults;
struct RequestResultsDefaultTypeInternal;
extern RequestResultsDefaultTypeInternal _RequestResults_default_instance_;
class ResultColumnMetadata;
struct ResultColumnMetadataDefaultTypeInternal;
extern ResultColumnMetadataDefaultTypeInternal _ResultColumnMetadata_default_instance_;
class RpcEndpointInfos;
struct RpcEndpointInfosDefaultTypeInternal;
extern RpcEndpointInfosDefaultTypeInternal _RpcEndpointInfos_default_instance_;
class RunQuery;
struct RunQueryDefaultTypeInternal;
extern RunQueryDefaultTypeInternal _RunQuery_default_instance_;
class RunQueryWithSessionHandle;
struct RunQueryWithSessionHandleDefaultTypeInternal;
extern RunQueryWithSessionHandleDefaultTypeInternal _RunQueryWithSessionHandle_default_instance_;
class SchemaMetadata;
struct SchemaMetadataDefaultTypeInternal;
extern SchemaMetadataDefaultTypeInternal _SchemaMetadata_default_instance_;
class ServerMeta;
struct ServerMetaDefaultTypeInternal;
extern ServerMetaDefaultTypeInternal _ServerMeta_default_instance_;
class SessionHandle;
struct SessionHandleDefaultTypeInternal;
extern SessionHandleDefaultTypeInternal _SessionHandle_default_instance_;
class TableMetadata;
struct TableMetadataDefaultTypeInternal;
extern TableMetadataDefaultTypeInternal _TableMetadata_default_instance_;
class UserProperties;
struct UserPropertiesDefaultTypeInternal;
extern UserPropertiesDefaultTypeInternal _UserProperties_default_instance_;
class UserToBitHandshake;
struct UserToBitHandshakeDefaultTypeInternal;
extern UserToBitHandshakeDefaultTypeInternal _UserToBitHandshake_default_instance_;
}  // namespace user
}  // namespace exec
PROTOBUF_NAMESPACE_OPEN
template <>
::exec::user::BitToUserHandshake* Arena::CreateMaybeMessage<::exec::user::BitToUserHandshake>(Arena*);
template <>
::exec::user::CancelQueryWithSessionHandle* Arena::CreateMaybeMessage<::exec::user::CancelQueryWithSessionHandle>(Arena*);
template <>
::exec::user::CatalogMetadata* Arena::CreateMaybeMessage<::exec::user::CatalogMetadata>(Arena*);
template <>
::exec::user::ColumnMetadata* Arena::CreateMaybeMessage<::exec::user::ColumnMetadata>(Arena*);
template <>
::exec::user::ConvertSupport* Arena::CreateMaybeMessage<::exec::user::ConvertSupport>(Arena*);
template <>
::exec::user::CreatePreparedStatementReq* Arena::CreateMaybeMessage<::exec::user::CreatePreparedStatementReq>(Arena*);
template <>
::exec::user::CreatePreparedStatementResp* Arena::CreateMaybeMessage<::exec::user::CreatePreparedStatementResp>(Arena*);
template <>
::exec::user::GetCatalogsReq* Arena::CreateMaybeMessage<::exec::user::GetCatalogsReq>(Arena*);
template <>
::exec::user::GetCatalogsResp* Arena::CreateMaybeMessage<::exec::user::GetCatalogsResp>(Arena*);
template <>
::exec::user::GetColumnsReq* Arena::CreateMaybeMessage<::exec::user::GetColumnsReq>(Arena*);
template <>
::exec::user::GetColumnsResp* Arena::CreateMaybeMessage<::exec::user::GetColumnsResp>(Arena*);
template <>
::exec::user::GetQueryPlanFragments* Arena::CreateMaybeMessage<::exec::user::GetQueryPlanFragments>(Arena*);
template <>
::exec::user::GetSchemasReq* Arena::CreateMaybeMessage<::exec::user::GetSchemasReq>(Arena*);
template <>
::exec::user::GetSchemasResp* Arena::CreateMaybeMessage<::exec::user::GetSchemasResp>(Arena*);
template <>
::exec::user::GetServerMetaReq* Arena::CreateMaybeMessage<::exec::user::GetServerMetaReq>(Arena*);
template <>
::exec::user::GetServerMetaResp* Arena::CreateMaybeMessage<::exec::user::GetServerMetaResp>(Arena*);
template <>
::exec::user::GetTablesReq* Arena::CreateMaybeMessage<::exec::user::GetTablesReq>(Arena*);
template <>
::exec::user::GetTablesResp* Arena::CreateMaybeMessage<::exec::user::GetTablesResp>(Arena*);
template <>
::exec::user::LikeFilter* Arena::CreateMaybeMessage<::exec::user::LikeFilter>(Arena*);
template <>
::exec::user::NewSessionRequest* Arena::CreateMaybeMessage<::exec::user::NewSessionRequest>(Arena*);
template <>
::exec::user::PreparedStatement* Arena::CreateMaybeMessage<::exec::user::PreparedStatement>(Arena*);
template <>
::exec::user::PreparedStatementHandle* Arena::CreateMaybeMessage<::exec::user::PreparedStatementHandle>(Arena*);
template <>
::exec::user::Property* Arena::CreateMaybeMessage<::exec::user::Property>(Arena*);
template <>
::exec::user::QueryPlanFragments* Arena::CreateMaybeMessage<::exec::user::QueryPlanFragments>(Arena*);
template <>
::exec::user::RequestResults* Arena::CreateMaybeMessage<::exec::user::RequestResults>(Arena*);
template <>
::exec::user::ResultColumnMetadata* Arena::CreateMaybeMessage<::exec::user::ResultColumnMetadata>(Arena*);
template <>
::exec::user::RpcEndpointInfos* Arena::CreateMaybeMessage<::exec::user::RpcEndpointInfos>(Arena*);
template <>
::exec::user::RunQuery* Arena::CreateMaybeMessage<::exec::user::RunQuery>(Arena*);
template <>
::exec::user::RunQueryWithSessionHandle* Arena::CreateMaybeMessage<::exec::user::RunQueryWithSessionHandle>(Arena*);
template <>
::exec::user::SchemaMetadata* Arena::CreateMaybeMessage<::exec::user::SchemaMetadata>(Arena*);
template <>
::exec::user::ServerMeta* Arena::CreateMaybeMessage<::exec::user::ServerMeta>(Arena*);
template <>
::exec::user::SessionHandle* Arena::CreateMaybeMessage<::exec::user::SessionHandle>(Arena*);
template <>
::exec::user::TableMetadata* Arena::CreateMaybeMessage<::exec::user::TableMetadata>(Arena*);
template <>
::exec::user::UserProperties* Arena::CreateMaybeMessage<::exec::user::UserProperties>(Arena*);
template <>
::exec::user::UserToBitHandshake* Arena::CreateMaybeMessage<::exec::user::UserToBitHandshake>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace exec {
namespace user {
enum RpcType : int {
  HANDSHAKE = 0,
  ACK = 1,
  GOODBYE = 2,
  RUN_QUERY = 3,
  CANCEL_QUERY = 4,
  REQUEST_RESULTS = 5,
  RESUME_PAUSED_QUERY = 11,
  GET_QUERY_PLAN_FRAGMENTS = 12,
  GET_CATALOGS = 14,
  GET_SCHEMAS = 15,
  GET_TABLES = 16,
  GET_COLUMNS = 17,
  CREATE_PREPARED_STATEMENT = 22,
  GET_SERVER_META = 8,
  NEW_SESSION = 1025,
  RUN_QUERY_WITH_SESSION = 1027,
  CLOSE_SESSION = 1028,
  CANCEL_QUERY_WITH_SESSION = 1029,
  QUERY_DATA = 6,
  QUERY_HANDLE = 7,
  QUERY_PLAN_FRAGMENTS = 13,
  CATALOGS = 18,
  SCHEMAS = 19,
  TABLES = 20,
  COLUMNS = 21,
  PREPARED_STATEMENT = 23,
  SERVER_META = 9,
  QUERY_RESULT = 10,
  SESSION_HANDLE = 1026,
  SASL_MESSAGE = 24,
};

bool RpcType_IsValid(int value);
constexpr RpcType RpcType_MIN = static_cast<RpcType>(0);
constexpr RpcType RpcType_MAX = static_cast<RpcType>(1029);
constexpr int RpcType_ARRAYSIZE = 1029 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
RpcType_descriptor();
template <typename T>
const std::string& RpcType_Name(T value) {
  static_assert(std::is_same<T, RpcType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to RpcType_Name().");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(RpcType_descriptor(), value);
}
inline bool RpcType_Parse(absl::string_view name, RpcType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RpcType>(
      RpcType_descriptor(), name, value);
}
enum SaslSupport : int {
  UNKNOWN_SASL_SUPPORT = 0,
  SASL_AUTH = 1,
  SASL_PRIVACY = 2,
};

bool SaslSupport_IsValid(int value);
constexpr SaslSupport SaslSupport_MIN = static_cast<SaslSupport>(0);
constexpr SaslSupport SaslSupport_MAX = static_cast<SaslSupport>(2);
constexpr int SaslSupport_ARRAYSIZE = 2 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
SaslSupport_descriptor();
template <typename T>
const std::string& SaslSupport_Name(T value) {
  static_assert(std::is_same<T, SaslSupport>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SaslSupport_Name().");
  return SaslSupport_Name(static_cast<SaslSupport>(value));
}
template <>
inline const std::string& SaslSupport_Name(SaslSupport value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<SaslSupport_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool SaslSupport_Parse(absl::string_view name, SaslSupport* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SaslSupport>(
      SaslSupport_descriptor(), name, value);
}
enum QueryResultsMode : int {
  STREAM_FULL = 1,
};

bool QueryResultsMode_IsValid(int value);
constexpr QueryResultsMode QueryResultsMode_MIN = static_cast<QueryResultsMode>(1);
constexpr QueryResultsMode QueryResultsMode_MAX = static_cast<QueryResultsMode>(1);
constexpr int QueryResultsMode_ARRAYSIZE = 1 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
QueryResultsMode_descriptor();
template <typename T>
const std::string& QueryResultsMode_Name(T value) {
  static_assert(std::is_same<T, QueryResultsMode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to QueryResultsMode_Name().");
  return QueryResultsMode_Name(static_cast<QueryResultsMode>(value));
}
template <>
inline const std::string& QueryResultsMode_Name(QueryResultsMode value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<QueryResultsMode_descriptor,
                                                 1, 1>(
      static_cast<int>(value));
}
inline bool QueryResultsMode_Parse(absl::string_view name, QueryResultsMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<QueryResultsMode>(
      QueryResultsMode_descriptor(), name, value);
}
enum HandshakeStatus : int {
  SUCCESS = 1,
  RPC_VERSION_MISMATCH = 2,
  AUTH_FAILED = 3,
  UNKNOWN_FAILURE = 4,
  AUTH_REQUIRED = 5,
};

bool HandshakeStatus_IsValid(int value);
constexpr HandshakeStatus HandshakeStatus_MIN = static_cast<HandshakeStatus>(1);
constexpr HandshakeStatus HandshakeStatus_MAX = static_cast<HandshakeStatus>(5);
constexpr int HandshakeStatus_ARRAYSIZE = 5 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
HandshakeStatus_descriptor();
template <typename T>
const std::string& HandshakeStatus_Name(T value) {
  static_assert(std::is_same<T, HandshakeStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to HandshakeStatus_Name().");
  return HandshakeStatus_Name(static_cast<HandshakeStatus>(value));
}
template <>
inline const std::string& HandshakeStatus_Name(HandshakeStatus value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<HandshakeStatus_descriptor,
                                                 1, 5>(
      static_cast<int>(value));
}
inline bool HandshakeStatus_Parse(absl::string_view name, HandshakeStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HandshakeStatus>(
      HandshakeStatus_descriptor(), name, value);
}
enum RequestStatus : int {
  UNKNOWN_STATUS = 0,
  OK = 1,
  FAILED = 2,
  TIMEOUT = 3,
};

bool RequestStatus_IsValid(int value);
constexpr RequestStatus RequestStatus_MIN = static_cast<RequestStatus>(0);
constexpr RequestStatus RequestStatus_MAX = static_cast<RequestStatus>(3);
constexpr int RequestStatus_ARRAYSIZE = 3 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
RequestStatus_descriptor();
template <typename T>
const std::string& RequestStatus_Name(T value) {
  static_assert(std::is_same<T, RequestStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to RequestStatus_Name().");
  return RequestStatus_Name(static_cast<RequestStatus>(value));
}
template <>
inline const std::string& RequestStatus_Name(RequestStatus value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<RequestStatus_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool RequestStatus_Parse(absl::string_view name, RequestStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RequestStatus>(
      RequestStatus_descriptor(), name, value);
}
enum ColumnSearchability : int {
  UNKNOWN_SEARCHABILITY = 0,
  NONE = 1,
  CHAR = 2,
  NUMBER = 3,
  ALL = 4,
};

bool ColumnSearchability_IsValid(int value);
constexpr ColumnSearchability ColumnSearchability_MIN = static_cast<ColumnSearchability>(0);
constexpr ColumnSearchability ColumnSearchability_MAX = static_cast<ColumnSearchability>(4);
constexpr int ColumnSearchability_ARRAYSIZE = 4 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
ColumnSearchability_descriptor();
template <typename T>
const std::string& ColumnSearchability_Name(T value) {
  static_assert(std::is_same<T, ColumnSearchability>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ColumnSearchability_Name().");
  return ColumnSearchability_Name(static_cast<ColumnSearchability>(value));
}
template <>
inline const std::string& ColumnSearchability_Name(ColumnSearchability value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<ColumnSearchability_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool ColumnSearchability_Parse(absl::string_view name, ColumnSearchability* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ColumnSearchability>(
      ColumnSearchability_descriptor(), name, value);
}
enum ColumnUpdatability : int {
  UNKNOWN_UPDATABILITY = 0,
  READ_ONLY = 1,
  WRITABLE = 2,
};

bool ColumnUpdatability_IsValid(int value);
constexpr ColumnUpdatability ColumnUpdatability_MIN = static_cast<ColumnUpdatability>(0);
constexpr ColumnUpdatability ColumnUpdatability_MAX = static_cast<ColumnUpdatability>(2);
constexpr int ColumnUpdatability_ARRAYSIZE = 2 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
ColumnUpdatability_descriptor();
template <typename T>
const std::string& ColumnUpdatability_Name(T value) {
  static_assert(std::is_same<T, ColumnUpdatability>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ColumnUpdatability_Name().");
  return ColumnUpdatability_Name(static_cast<ColumnUpdatability>(value));
}
template <>
inline const std::string& ColumnUpdatability_Name(ColumnUpdatability value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<ColumnUpdatability_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool ColumnUpdatability_Parse(absl::string_view name, ColumnUpdatability* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ColumnUpdatability>(
      ColumnUpdatability_descriptor(), name, value);
}
enum CollateSupport : int {
  CS_UNKNOWN = 0,
  CS_GROUP_BY = 1,
};

bool CollateSupport_IsValid(int value);
constexpr CollateSupport CollateSupport_MIN = static_cast<CollateSupport>(0);
constexpr CollateSupport CollateSupport_MAX = static_cast<CollateSupport>(1);
constexpr int CollateSupport_ARRAYSIZE = 1 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
CollateSupport_descriptor();
template <typename T>
const std::string& CollateSupport_Name(T value) {
  static_assert(std::is_same<T, CollateSupport>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CollateSupport_Name().");
  return CollateSupport_Name(static_cast<CollateSupport>(value));
}
template <>
inline const std::string& CollateSupport_Name(CollateSupport value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<CollateSupport_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool CollateSupport_Parse(absl::string_view name, CollateSupport* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CollateSupport>(
      CollateSupport_descriptor(), name, value);
}
enum CorrelationNamesSupport : int {
  CN_NONE = 1,
  CN_DIFFERENT_NAMES = 2,
  CN_ANY = 3,
};

bool CorrelationNamesSupport_IsValid(int value);
constexpr CorrelationNamesSupport CorrelationNamesSupport_MIN = static_cast<CorrelationNamesSupport>(1);
constexpr CorrelationNamesSupport CorrelationNamesSupport_MAX = static_cast<CorrelationNamesSupport>(3);
constexpr int CorrelationNamesSupport_ARRAYSIZE = 3 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
CorrelationNamesSupport_descriptor();
template <typename T>
const std::string& CorrelationNamesSupport_Name(T value) {
  static_assert(std::is_same<T, CorrelationNamesSupport>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CorrelationNamesSupport_Name().");
  return CorrelationNamesSupport_Name(static_cast<CorrelationNamesSupport>(value));
}
template <>
inline const std::string& CorrelationNamesSupport_Name(CorrelationNamesSupport value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<CorrelationNamesSupport_descriptor,
                                                 1, 3>(
      static_cast<int>(value));
}
inline bool CorrelationNamesSupport_Parse(absl::string_view name, CorrelationNamesSupport* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CorrelationNamesSupport>(
      CorrelationNamesSupport_descriptor(), name, value);
}
enum DateTimeLiteralsSupport : int {
  DL_UNKNOWN = 0,
  DL_DATE = 1,
  DL_TIME = 2,
  DL_TIMESTAMP = 3,
  DL_INTERVAL_YEAR = 4,
  DL_INTERVAL_MONTH = 5,
  DL_INTERVAL_DAY = 6,
  DL_INTERVAL_HOUR = 7,
  DL_INTERVAL_MINUTE = 8,
  DL_INTERVAL_SECOND = 9,
  DL_INTERVAL_YEAR_TO_MONTH = 10,
  DL_INTERVAL_DAY_TO_HOUR = 11,
  DL_INTERVAL_DAY_TO_MINUTE = 12,
  DL_INTERVAL_DAY_TO_SECOND = 13,
  DL_INTERVAL_HOUR_TO_MINUTE = 14,
  DL_INTERVAL_HOUR_TO_SECOND = 15,
  DL_INTERVAL_MINUTE_TO_SECOND = 16,
};

bool DateTimeLiteralsSupport_IsValid(int value);
constexpr DateTimeLiteralsSupport DateTimeLiteralsSupport_MIN = static_cast<DateTimeLiteralsSupport>(0);
constexpr DateTimeLiteralsSupport DateTimeLiteralsSupport_MAX = static_cast<DateTimeLiteralsSupport>(16);
constexpr int DateTimeLiteralsSupport_ARRAYSIZE = 16 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
DateTimeLiteralsSupport_descriptor();
template <typename T>
const std::string& DateTimeLiteralsSupport_Name(T value) {
  static_assert(std::is_same<T, DateTimeLiteralsSupport>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DateTimeLiteralsSupport_Name().");
  return DateTimeLiteralsSupport_Name(static_cast<DateTimeLiteralsSupport>(value));
}
template <>
inline const std::string& DateTimeLiteralsSupport_Name(DateTimeLiteralsSupport value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<DateTimeLiteralsSupport_descriptor,
                                                 0, 16>(
      static_cast<int>(value));
}
inline bool DateTimeLiteralsSupport_Parse(absl::string_view name, DateTimeLiteralsSupport* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DateTimeLiteralsSupport>(
      DateTimeLiteralsSupport_descriptor(), name, value);
}
enum GroupBySupport : int {
  GB_NONE = 1,
  GB_SELECT_ONLY = 2,
  GB_BEYOND_SELECT = 3,
  GB_UNRELATED = 4,
};

bool GroupBySupport_IsValid(int value);
constexpr GroupBySupport GroupBySupport_MIN = static_cast<GroupBySupport>(1);
constexpr GroupBySupport GroupBySupport_MAX = static_cast<GroupBySupport>(4);
constexpr int GroupBySupport_ARRAYSIZE = 4 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
GroupBySupport_descriptor();
template <typename T>
const std::string& GroupBySupport_Name(T value) {
  static_assert(std::is_same<T, GroupBySupport>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to GroupBySupport_Name().");
  return GroupBySupport_Name(static_cast<GroupBySupport>(value));
}
template <>
inline const std::string& GroupBySupport_Name(GroupBySupport value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<GroupBySupport_descriptor,
                                                 1, 4>(
      static_cast<int>(value));
}
inline bool GroupBySupport_Parse(absl::string_view name, GroupBySupport* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GroupBySupport>(
      GroupBySupport_descriptor(), name, value);
}
enum IdentifierCasing : int {
  IC_UNKNOWN = 0,
  IC_STORES_LOWER = 1,
  IC_STORES_MIXED = 2,
  IC_STORES_UPPER = 3,
  IC_SUPPORTS_MIXED = 4,
};

bool IdentifierCasing_IsValid(int value);
constexpr IdentifierCasing IdentifierCasing_MIN = static_cast<IdentifierCasing>(0);
constexpr IdentifierCasing IdentifierCasing_MAX = static_cast<IdentifierCasing>(4);
constexpr int IdentifierCasing_ARRAYSIZE = 4 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
IdentifierCasing_descriptor();
template <typename T>
const std::string& IdentifierCasing_Name(T value) {
  static_assert(std::is_same<T, IdentifierCasing>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to IdentifierCasing_Name().");
  return IdentifierCasing_Name(static_cast<IdentifierCasing>(value));
}
template <>
inline const std::string& IdentifierCasing_Name(IdentifierCasing value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<IdentifierCasing_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool IdentifierCasing_Parse(absl::string_view name, IdentifierCasing* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<IdentifierCasing>(
      IdentifierCasing_descriptor(), name, value);
}
enum NullCollation : int {
  NC_UNKNOWN = 0,
  NC_AT_START = 1,
  NC_AT_END = 2,
  NC_HIGH = 3,
  NC_LOW = 4,
};

bool NullCollation_IsValid(int value);
constexpr NullCollation NullCollation_MIN = static_cast<NullCollation>(0);
constexpr NullCollation NullCollation_MAX = static_cast<NullCollation>(4);
constexpr int NullCollation_ARRAYSIZE = 4 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
NullCollation_descriptor();
template <typename T>
const std::string& NullCollation_Name(T value) {
  static_assert(std::is_same<T, NullCollation>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to NullCollation_Name().");
  return NullCollation_Name(static_cast<NullCollation>(value));
}
template <>
inline const std::string& NullCollation_Name(NullCollation value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<NullCollation_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool NullCollation_Parse(absl::string_view name, NullCollation* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NullCollation>(
      NullCollation_descriptor(), name, value);
}
enum OrderBySupport : int {
  OB_UNKNOWN = 0,
  OB_UNRELATED = 1,
  OB_EXPRESSION = 2,
};

bool OrderBySupport_IsValid(int value);
constexpr OrderBySupport OrderBySupport_MIN = static_cast<OrderBySupport>(0);
constexpr OrderBySupport OrderBySupport_MAX = static_cast<OrderBySupport>(2);
constexpr int OrderBySupport_ARRAYSIZE = 2 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
OrderBySupport_descriptor();
template <typename T>
const std::string& OrderBySupport_Name(T value) {
  static_assert(std::is_same<T, OrderBySupport>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to OrderBySupport_Name().");
  return OrderBySupport_Name(static_cast<OrderBySupport>(value));
}
template <>
inline const std::string& OrderBySupport_Name(OrderBySupport value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<OrderBySupport_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool OrderBySupport_Parse(absl::string_view name, OrderBySupport* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OrderBySupport>(
      OrderBySupport_descriptor(), name, value);
}
enum OuterJoinSupport : int {
  OJ_UNKNOWN = 0,
  OJ_LEFT = 1,
  OJ_RIGHT = 2,
  OJ_FULL = 3,
  OJ_NESTED = 4,
  OJ_NOT_ORDERED = 5,
  OJ_INNER = 6,
  OJ_ALL_COMPARISON_OPS = 7,
};

bool OuterJoinSupport_IsValid(int value);
constexpr OuterJoinSupport OuterJoinSupport_MIN = static_cast<OuterJoinSupport>(0);
constexpr OuterJoinSupport OuterJoinSupport_MAX = static_cast<OuterJoinSupport>(7);
constexpr int OuterJoinSupport_ARRAYSIZE = 7 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
OuterJoinSupport_descriptor();
template <typename T>
const std::string& OuterJoinSupport_Name(T value) {
  static_assert(std::is_same<T, OuterJoinSupport>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to OuterJoinSupport_Name().");
  return OuterJoinSupport_Name(static_cast<OuterJoinSupport>(value));
}
template <>
inline const std::string& OuterJoinSupport_Name(OuterJoinSupport value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<OuterJoinSupport_descriptor,
                                                 0, 7>(
      static_cast<int>(value));
}
inline bool OuterJoinSupport_Parse(absl::string_view name, OuterJoinSupport* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OuterJoinSupport>(
      OuterJoinSupport_descriptor(), name, value);
}
enum SubQuerySupport : int {
  SQ_UNKNOWN = 0,
  SQ_CORRELATED = 1,
  SQ_IN_COMPARISON = 2,
  SQ_IN_EXISTS = 3,
  SQ_IN_INSERT = 4,
  SQ_IN_QUANTIFIED = 5,
};

bool SubQuerySupport_IsValid(int value);
constexpr SubQuerySupport SubQuerySupport_MIN = static_cast<SubQuerySupport>(0);
constexpr SubQuerySupport SubQuerySupport_MAX = static_cast<SubQuerySupport>(5);
constexpr int SubQuerySupport_ARRAYSIZE = 5 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
SubQuerySupport_descriptor();
template <typename T>
const std::string& SubQuerySupport_Name(T value) {
  static_assert(std::is_same<T, SubQuerySupport>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SubQuerySupport_Name().");
  return SubQuerySupport_Name(static_cast<SubQuerySupport>(value));
}
template <>
inline const std::string& SubQuerySupport_Name(SubQuerySupport value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<SubQuerySupport_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool SubQuerySupport_Parse(absl::string_view name, SubQuerySupport* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SubQuerySupport>(
      SubQuerySupport_descriptor(), name, value);
}
enum UnionSupport : int {
  U_UNKNOWN = 0,
  U_UNION = 1,
  U_UNION_ALL = 2,
};

bool UnionSupport_IsValid(int value);
constexpr UnionSupport UnionSupport_MIN = static_cast<UnionSupport>(0);
constexpr UnionSupport UnionSupport_MAX = static_cast<UnionSupport>(2);
constexpr int UnionSupport_ARRAYSIZE = 2 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
UnionSupport_descriptor();
template <typename T>
const std::string& UnionSupport_Name(T value) {
  static_assert(std::is_same<T, UnionSupport>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to UnionSupport_Name().");
  return UnionSupport_Name(static_cast<UnionSupport>(value));
}
template <>
inline const std::string& UnionSupport_Name(UnionSupport value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<UnionSupport_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool UnionSupport_Parse(absl::string_view name, UnionSupport* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UnionSupport>(
      UnionSupport_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Property final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.user.Property) */ {
 public:
  inline Property() : Property(nullptr) {}
  ~Property() override;
  explicit PROTOBUF_CONSTEXPR Property(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Property(const Property& from);
  Property(Property&& from) noexcept
    : Property() {
    *this = ::std::move(from);
  }

  inline Property& operator=(const Property& from) {
    CopyFrom(from);
    return *this;
  }
  inline Property& operator=(Property&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Property& default_instance() {
    return *internal_default_instance();
  }
  static inline const Property* internal_default_instance() {
    return reinterpret_cast<const Property*>(
               &_Property_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Property& a, Property& b) {
    a.Swap(&b);
  }
  inline void Swap(Property* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Property* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Property* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Property>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Property& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Property& from) {
    Property::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Property* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.user.Property";
  }
  protected:
  explicit Property(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // required string key = 1;
  bool has_key() const;
  void clear_key() ;
  const std::string& key() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* ptr);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // required string value = 2;
  bool has_value() const;
  void clear_value() ;
  const std::string& value() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* ptr);

  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
      const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // @@protoc_insertion_point(class_scope:exec.user.Property)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  ::size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_User_2eproto;
};// -------------------------------------------------------------------

class UserProperties final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.user.UserProperties) */ {
 public:
  inline UserProperties() : UserProperties(nullptr) {}
  ~UserProperties() override;
  explicit PROTOBUF_CONSTEXPR UserProperties(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserProperties(const UserProperties& from);
  UserProperties(UserProperties&& from) noexcept
    : UserProperties() {
    *this = ::std::move(from);
  }

  inline UserProperties& operator=(const UserProperties& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserProperties& operator=(UserProperties&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserProperties& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserProperties* internal_default_instance() {
    return reinterpret_cast<const UserProperties*>(
               &_UserProperties_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(UserProperties& a, UserProperties& b) {
    a.Swap(&b);
  }
  inline void Swap(UserProperties* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserProperties* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserProperties* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserProperties>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserProperties& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserProperties& from) {
    UserProperties::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserProperties* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.user.UserProperties";
  }
  protected:
  explicit UserProperties(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPropertiesFieldNumber = 1,
  };
  // repeated .exec.user.Property properties = 1;
  int properties_size() const;
  private:
  int _internal_properties_size() const;

  public:
  void clear_properties() ;
  ::exec::user::Property* mutable_properties(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::user::Property >*
      mutable_properties();
  private:
  const ::exec::user::Property& _internal_properties(int index) const;
  ::exec::user::Property* _internal_add_properties();
  public:
  const ::exec::user::Property& properties(int index) const;
  ::exec::user::Property* add_properties();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::user::Property >&
      properties() const;
  // @@protoc_insertion_point(class_scope:exec.user.UserProperties)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::user::Property > properties_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_User_2eproto;
};// -------------------------------------------------------------------

class RpcEndpointInfos final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.user.RpcEndpointInfos) */ {
 public:
  inline RpcEndpointInfos() : RpcEndpointInfos(nullptr) {}
  ~RpcEndpointInfos() override;
  explicit PROTOBUF_CONSTEXPR RpcEndpointInfos(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RpcEndpointInfos(const RpcEndpointInfos& from);
  RpcEndpointInfos(RpcEndpointInfos&& from) noexcept
    : RpcEndpointInfos() {
    *this = ::std::move(from);
  }

  inline RpcEndpointInfos& operator=(const RpcEndpointInfos& from) {
    CopyFrom(from);
    return *this;
  }
  inline RpcEndpointInfos& operator=(RpcEndpointInfos&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RpcEndpointInfos& default_instance() {
    return *internal_default_instance();
  }
  static inline const RpcEndpointInfos* internal_default_instance() {
    return reinterpret_cast<const RpcEndpointInfos*>(
               &_RpcEndpointInfos_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RpcEndpointInfos& a, RpcEndpointInfos& b) {
    a.Swap(&b);
  }
  inline void Swap(RpcEndpointInfos* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RpcEndpointInfos* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RpcEndpointInfos* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RpcEndpointInfos>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RpcEndpointInfos& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RpcEndpointInfos& from) {
    RpcEndpointInfos::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RpcEndpointInfos* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.user.RpcEndpointInfos";
  }
  protected:
  explicit RpcEndpointInfos(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kVersionFieldNumber = 2,
    kApplicationFieldNumber = 6,
    kVersionQualifierFieldNumber = 8,
    kMajorVersionFieldNumber = 3,
    kMinorVersionFieldNumber = 4,
    kPatchVersionFieldNumber = 5,
    kBuildNumberFieldNumber = 7,
  };
  // optional string name = 1;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // optional string version = 2;
  bool has_version() const;
  void clear_version() ;
  const std::string& version() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_version(Arg_&& arg, Args_... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* ptr);

  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(
      const std::string& value);
  std::string* _internal_mutable_version();

  public:
  // optional string application = 6;
  bool has_application() const;
  void clear_application() ;
  const std::string& application() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_application(Arg_&& arg, Args_... args);
  std::string* mutable_application();
  PROTOBUF_NODISCARD std::string* release_application();
  void set_allocated_application(std::string* ptr);

  private:
  const std::string& _internal_application() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_application(
      const std::string& value);
  std::string* _internal_mutable_application();

  public:
  // optional string versionQualifier = 8;
  bool has_versionqualifier() const;
  void clear_versionqualifier() ;
  const std::string& versionqualifier() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_versionqualifier(Arg_&& arg, Args_... args);
  std::string* mutable_versionqualifier();
  PROTOBUF_NODISCARD std::string* release_versionqualifier();
  void set_allocated_versionqualifier(std::string* ptr);

  private:
  const std::string& _internal_versionqualifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_versionqualifier(
      const std::string& value);
  std::string* _internal_mutable_versionqualifier();

  public:
  // optional uint32 majorVersion = 3;
  bool has_majorversion() const;
  void clear_majorversion() ;
  ::uint32_t majorversion() const;
  void set_majorversion(::uint32_t value);

  private:
  ::uint32_t _internal_majorversion() const;
  void _internal_set_majorversion(::uint32_t value);

  public:
  // optional uint32 minorVersion = 4;
  bool has_minorversion() const;
  void clear_minorversion() ;
  ::uint32_t minorversion() const;
  void set_minorversion(::uint32_t value);

  private:
  ::uint32_t _internal_minorversion() const;
  void _internal_set_minorversion(::uint32_t value);

  public:
  // optional uint32 patchVersion = 5;
  bool has_patchversion() const;
  void clear_patchversion() ;
  ::uint32_t patchversion() const;
  void set_patchversion(::uint32_t value);

  private:
  ::uint32_t _internal_patchversion() const;
  void _internal_set_patchversion(::uint32_t value);

  public:
  // optional uint32 buildNumber = 7;
  bool has_buildnumber() const;
  void clear_buildnumber() ;
  ::uint32_t buildnumber() const;
  void set_buildnumber(::uint32_t value);

  private:
  ::uint32_t _internal_buildnumber() const;
  void _internal_set_buildnumber(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:exec.user.RpcEndpointInfos)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr application_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr versionqualifier_;
    ::uint32_t majorversion_;
    ::uint32_t minorversion_;
    ::uint32_t patchversion_;
    ::uint32_t buildnumber_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_User_2eproto;
};// -------------------------------------------------------------------

class UserToBitHandshake final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.user.UserToBitHandshake) */ {
 public:
  inline UserToBitHandshake() : UserToBitHandshake(nullptr) {}
  ~UserToBitHandshake() override;
  explicit PROTOBUF_CONSTEXPR UserToBitHandshake(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserToBitHandshake(const UserToBitHandshake& from);
  UserToBitHandshake(UserToBitHandshake&& from) noexcept
    : UserToBitHandshake() {
    *this = ::std::move(from);
  }

  inline UserToBitHandshake& operator=(const UserToBitHandshake& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserToBitHandshake& operator=(UserToBitHandshake&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserToBitHandshake& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserToBitHandshake* internal_default_instance() {
    return reinterpret_cast<const UserToBitHandshake*>(
               &_UserToBitHandshake_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(UserToBitHandshake& a, UserToBitHandshake& b) {
    a.Swap(&b);
  }
  inline void Swap(UserToBitHandshake* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserToBitHandshake* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserToBitHandshake* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserToBitHandshake>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserToBitHandshake& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserToBitHandshake& from) {
    UserToBitHandshake::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserToBitHandshake* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.user.UserToBitHandshake";
  }
  protected:
  explicit UserToBitHandshake(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCredentialsFieldNumber = 4,
    kPropertiesFieldNumber = 5,
    kClientInfosFieldNumber = 8,
    kRpcVersionFieldNumber = 3,
    kSupportListeningFieldNumber = 2,
    kSupportComplexTypesFieldNumber = 6,
    kSupportTimeoutFieldNumber = 7,
    kEnableMultiplexFieldNumber = 10,
    kSaslSupportFieldNumber = 9,
    kCapabilitiesVersionFieldNumber = 11,
    kChannelFieldNumber = 1,
  };
  // optional .exec.shared.UserCredentials credentials = 4;
  bool has_credentials() const;
  void clear_credentials() ;
  const ::exec::shared::UserCredentials& credentials() const;
  PROTOBUF_NODISCARD ::exec::shared::UserCredentials* release_credentials();
  ::exec::shared::UserCredentials* mutable_credentials();
  void set_allocated_credentials(::exec::shared::UserCredentials* credentials);
  private:
  const ::exec::shared::UserCredentials& _internal_credentials() const;
  ::exec::shared::UserCredentials* _internal_mutable_credentials();
  public:
  void unsafe_arena_set_allocated_credentials(
      ::exec::shared::UserCredentials* credentials);
  ::exec::shared::UserCredentials* unsafe_arena_release_credentials();
  // optional .exec.user.UserProperties properties = 5;
  bool has_properties() const;
  void clear_properties() ;
  const ::exec::user::UserProperties& properties() const;
  PROTOBUF_NODISCARD ::exec::user::UserProperties* release_properties();
  ::exec::user::UserProperties* mutable_properties();
  void set_allocated_properties(::exec::user::UserProperties* properties);
  private:
  const ::exec::user::UserProperties& _internal_properties() const;
  ::exec::user::UserProperties* _internal_mutable_properties();
  public:
  void unsafe_arena_set_allocated_properties(
      ::exec::user::UserProperties* properties);
  ::exec::user::UserProperties* unsafe_arena_release_properties();
  // optional .exec.user.RpcEndpointInfos client_infos = 8;
  bool has_client_infos() const;
  void clear_client_infos() ;
  const ::exec::user::RpcEndpointInfos& client_infos() const;
  PROTOBUF_NODISCARD ::exec::user::RpcEndpointInfos* release_client_infos();
  ::exec::user::RpcEndpointInfos* mutable_client_infos();
  void set_allocated_client_infos(::exec::user::RpcEndpointInfos* client_infos);
  private:
  const ::exec::user::RpcEndpointInfos& _internal_client_infos() const;
  ::exec::user::RpcEndpointInfos* _internal_mutable_client_infos();
  public:
  void unsafe_arena_set_allocated_client_infos(
      ::exec::user::RpcEndpointInfos* client_infos);
  ::exec::user::RpcEndpointInfos* unsafe_arena_release_client_infos();
  // optional int32 rpc_version = 3;
  bool has_rpc_version() const;
  void clear_rpc_version() ;
  ::int32_t rpc_version() const;
  void set_rpc_version(::int32_t value);

  private:
  ::int32_t _internal_rpc_version() const;
  void _internal_set_rpc_version(::int32_t value);

  public:
  // optional bool support_listening = 2;
  bool has_support_listening() const;
  void clear_support_listening() ;
  bool support_listening() const;
  void set_support_listening(bool value);

  private:
  bool _internal_support_listening() const;
  void _internal_set_support_listening(bool value);

  public:
  // optional bool support_complex_types = 6 [default = false];
  bool has_support_complex_types() const;
  void clear_support_complex_types() ;
  bool support_complex_types() const;
  void set_support_complex_types(bool value);

  private:
  bool _internal_support_complex_types() const;
  void _internal_set_support_complex_types(bool value);

  public:
  // optional bool support_timeout = 7 [default = false];
  bool has_support_timeout() const;
  void clear_support_timeout() ;
  bool support_timeout() const;
  void set_support_timeout(bool value);

  private:
  bool _internal_support_timeout() const;
  void _internal_set_support_timeout(bool value);

  public:
  // optional bool enable_multiplex = 10 [default = false];
  bool has_enable_multiplex() const;
  void clear_enable_multiplex() ;
  bool enable_multiplex() const;
  void set_enable_multiplex(bool value);

  private:
  bool _internal_enable_multiplex() const;
  void _internal_set_enable_multiplex(bool value);

  public:
  // optional .exec.user.SaslSupport sasl_support = 9;
  bool has_sasl_support() const;
  void clear_sasl_support() ;
  ::exec::user::SaslSupport sasl_support() const;
  void set_sasl_support(::exec::user::SaslSupport value);

  private:
  ::exec::user::SaslSupport _internal_sasl_support() const;
  void _internal_set_sasl_support(::exec::user::SaslSupport value);

  public:
  // optional int32 capabilities_version = 11 [default = 0];
  bool has_capabilities_version() const;
  void clear_capabilities_version() ;
  ::int32_t capabilities_version() const;
  void set_capabilities_version(::int32_t value);

  private:
  ::int32_t _internal_capabilities_version() const;
  void _internal_set_capabilities_version(::int32_t value);

  public:
  // optional .exec.shared.RpcChannel channel = 1 [default = USER];
  bool has_channel() const;
  void clear_channel() ;
  ::exec::shared::RpcChannel channel() const;
  void set_channel(::exec::shared::RpcChannel value);

  private:
  ::exec::shared::RpcChannel _internal_channel() const;
  void _internal_set_channel(::exec::shared::RpcChannel value);

  public:
  // @@protoc_insertion_point(class_scope:exec.user.UserToBitHandshake)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::exec::shared::UserCredentials* credentials_;
    ::exec::user::UserProperties* properties_;
    ::exec::user::RpcEndpointInfos* client_infos_;
    ::int32_t rpc_version_;
    bool support_listening_;
    bool support_complex_types_;
    bool support_timeout_;
    bool enable_multiplex_;
    int sasl_support_;
    ::int32_t capabilities_version_;
    int channel_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_User_2eproto;
};// -------------------------------------------------------------------

class RequestResults final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.user.RequestResults) */ {
 public:
  inline RequestResults() : RequestResults(nullptr) {}
  ~RequestResults() override;
  explicit PROTOBUF_CONSTEXPR RequestResults(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestResults(const RequestResults& from);
  RequestResults(RequestResults&& from) noexcept
    : RequestResults() {
    *this = ::std::move(from);
  }

  inline RequestResults& operator=(const RequestResults& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestResults& operator=(RequestResults&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestResults& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestResults* internal_default_instance() {
    return reinterpret_cast<const RequestResults*>(
               &_RequestResults_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RequestResults& a, RequestResults& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestResults* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestResults* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestResults* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestResults>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestResults& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestResults& from) {
    RequestResults::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestResults* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.user.RequestResults";
  }
  protected:
  explicit RequestResults(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQueryIdFieldNumber = 1,
    kMaximumResponsesFieldNumber = 2,
  };
  // optional .exec.shared.QueryId query_id = 1;
  bool has_query_id() const;
  void clear_query_id() ;
  const ::exec::shared::QueryId& query_id() const;
  PROTOBUF_NODISCARD ::exec::shared::QueryId* release_query_id();
  ::exec::shared::QueryId* mutable_query_id();
  void set_allocated_query_id(::exec::shared::QueryId* query_id);
  private:
  const ::exec::shared::QueryId& _internal_query_id() const;
  ::exec::shared::QueryId* _internal_mutable_query_id();
  public:
  void unsafe_arena_set_allocated_query_id(
      ::exec::shared::QueryId* query_id);
  ::exec::shared::QueryId* unsafe_arena_release_query_id();
  // optional int32 maximum_responses = 2;
  bool has_maximum_responses() const;
  void clear_maximum_responses() ;
  ::int32_t maximum_responses() const;
  void set_maximum_responses(::int32_t value);

  private:
  ::int32_t _internal_maximum_responses() const;
  void _internal_set_maximum_responses(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:exec.user.RequestResults)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::exec::shared::QueryId* query_id_;
    ::int32_t maximum_responses_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_User_2eproto;
};// -------------------------------------------------------------------

class GetQueryPlanFragments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.user.GetQueryPlanFragments) */ {
 public:
  inline GetQueryPlanFragments() : GetQueryPlanFragments(nullptr) {}
  ~GetQueryPlanFragments() override;
  explicit PROTOBUF_CONSTEXPR GetQueryPlanFragments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetQueryPlanFragments(const GetQueryPlanFragments& from);
  GetQueryPlanFragments(GetQueryPlanFragments&& from) noexcept
    : GetQueryPlanFragments() {
    *this = ::std::move(from);
  }

  inline GetQueryPlanFragments& operator=(const GetQueryPlanFragments& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetQueryPlanFragments& operator=(GetQueryPlanFragments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetQueryPlanFragments& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetQueryPlanFragments* internal_default_instance() {
    return reinterpret_cast<const GetQueryPlanFragments*>(
               &_GetQueryPlanFragments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GetQueryPlanFragments& a, GetQueryPlanFragments& b) {
    a.Swap(&b);
  }
  inline void Swap(GetQueryPlanFragments* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetQueryPlanFragments* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetQueryPlanFragments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetQueryPlanFragments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetQueryPlanFragments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetQueryPlanFragments& from) {
    GetQueryPlanFragments::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetQueryPlanFragments* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.user.GetQueryPlanFragments";
  }
  protected:
  explicit GetQueryPlanFragments(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQueryFieldNumber = 1,
    kSplitPlanFieldNumber = 3,
    kTypeFieldNumber = 2,
  };
  // required string query = 1;
  bool has_query() const;
  void clear_query() ;
  const std::string& query() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_query(Arg_&& arg, Args_... args);
  std::string* mutable_query();
  PROTOBUF_NODISCARD std::string* release_query();
  void set_allocated_query(std::string* ptr);

  private:
  const std::string& _internal_query() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_query(
      const std::string& value);
  std::string* _internal_mutable_query();

  public:
  // optional bool split_plan = 3 [default = false];
  bool has_split_plan() const;
  void clear_split_plan() ;
  bool split_plan() const;
  void set_split_plan(bool value);

  private:
  bool _internal_split_plan() const;
  void _internal_set_split_plan(bool value);

  public:
  // optional .exec.shared.QueryType type = 2;
  bool has_type() const;
  void clear_type() ;
  ::exec::shared::QueryType type() const;
  void set_type(::exec::shared::QueryType value);

  private:
  ::exec::shared::QueryType _internal_type() const;
  void _internal_set_type(::exec::shared::QueryType value);

  public:
  // @@protoc_insertion_point(class_scope:exec.user.GetQueryPlanFragments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr query_;
    bool split_plan_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_User_2eproto;
};// -------------------------------------------------------------------

class QueryPlanFragments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.user.QueryPlanFragments) */ {
 public:
  inline QueryPlanFragments() : QueryPlanFragments(nullptr) {}
  ~QueryPlanFragments() override;
  explicit PROTOBUF_CONSTEXPR QueryPlanFragments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryPlanFragments(const QueryPlanFragments& from);
  QueryPlanFragments(QueryPlanFragments&& from) noexcept
    : QueryPlanFragments() {
    *this = ::std::move(from);
  }

  inline QueryPlanFragments& operator=(const QueryPlanFragments& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryPlanFragments& operator=(QueryPlanFragments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryPlanFragments& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryPlanFragments* internal_default_instance() {
    return reinterpret_cast<const QueryPlanFragments*>(
               &_QueryPlanFragments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(QueryPlanFragments& a, QueryPlanFragments& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryPlanFragments* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryPlanFragments* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryPlanFragments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryPlanFragments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryPlanFragments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryPlanFragments& from) {
    QueryPlanFragments::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryPlanFragments* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.user.QueryPlanFragments";
  }
  protected:
  explicit QueryPlanFragments(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFragmentsFieldNumber = 3,
    kQueryIdFieldNumber = 2,
    kErrorFieldNumber = 4,
    kStatusFieldNumber = 1,
  };
  // repeated .exec.bit.control.PlanFragment fragments = 3;
  int fragments_size() const;
  private:
  int _internal_fragments_size() const;

  public:
  void clear_fragments() ;
  ::exec::bit::control::PlanFragment* mutable_fragments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::bit::control::PlanFragment >*
      mutable_fragments();
  private:
  const ::exec::bit::control::PlanFragment& _internal_fragments(int index) const;
  ::exec::bit::control::PlanFragment* _internal_add_fragments();
  public:
  const ::exec::bit::control::PlanFragment& fragments(int index) const;
  ::exec::bit::control::PlanFragment* add_fragments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::bit::control::PlanFragment >&
      fragments() const;
  // optional .exec.shared.QueryId query_id = 2;
  bool has_query_id() const;
  void clear_query_id() ;
  const ::exec::shared::QueryId& query_id() const;
  PROTOBUF_NODISCARD ::exec::shared::QueryId* release_query_id();
  ::exec::shared::QueryId* mutable_query_id();
  void set_allocated_query_id(::exec::shared::QueryId* query_id);
  private:
  const ::exec::shared::QueryId& _internal_query_id() const;
  ::exec::shared::QueryId* _internal_mutable_query_id();
  public:
  void unsafe_arena_set_allocated_query_id(
      ::exec::shared::QueryId* query_id);
  ::exec::shared::QueryId* unsafe_arena_release_query_id();
  // optional .exec.shared.DrillPBError error = 4;
  bool has_error() const;
  void clear_error() ;
  const ::exec::shared::DrillPBError& error() const;
  PROTOBUF_NODISCARD ::exec::shared::DrillPBError* release_error();
  ::exec::shared::DrillPBError* mutable_error();
  void set_allocated_error(::exec::shared::DrillPBError* error);
  private:
  const ::exec::shared::DrillPBError& _internal_error() const;
  ::exec::shared::DrillPBError* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::exec::shared::DrillPBError* error);
  ::exec::shared::DrillPBError* unsafe_arena_release_error();
  // required .exec.shared.QueryResult.QueryState status = 1;
  bool has_status() const;
  void clear_status() ;
  ::exec::shared::QueryResult_QueryState status() const;
  void set_status(::exec::shared::QueryResult_QueryState value);

  private:
  ::exec::shared::QueryResult_QueryState _internal_status() const;
  void _internal_set_status(::exec::shared::QueryResult_QueryState value);

  public:
  // @@protoc_insertion_point(class_scope:exec.user.QueryPlanFragments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::bit::control::PlanFragment > fragments_;
    ::exec::shared::QueryId* query_id_;
    ::exec::shared::DrillPBError* error_;
    int status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_User_2eproto;
};// -------------------------------------------------------------------

class BitToUserHandshake final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.user.BitToUserHandshake) */ {
 public:
  inline BitToUserHandshake() : BitToUserHandshake(nullptr) {}
  ~BitToUserHandshake() override;
  explicit PROTOBUF_CONSTEXPR BitToUserHandshake(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BitToUserHandshake(const BitToUserHandshake& from);
  BitToUserHandshake(BitToUserHandshake&& from) noexcept
    : BitToUserHandshake() {
    *this = ::std::move(from);
  }

  inline BitToUserHandshake& operator=(const BitToUserHandshake& from) {
    CopyFrom(from);
    return *this;
  }
  inline BitToUserHandshake& operator=(BitToUserHandshake&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BitToUserHandshake& default_instance() {
    return *internal_default_instance();
  }
  static inline const BitToUserHandshake* internal_default_instance() {
    return reinterpret_cast<const BitToUserHandshake*>(
               &_BitToUserHandshake_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(BitToUserHandshake& a, BitToUserHandshake& b) {
    a.Swap(&b);
  }
  inline void Swap(BitToUserHandshake* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BitToUserHandshake* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BitToUserHandshake* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BitToUserHandshake>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BitToUserHandshake& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BitToUserHandshake& from) {
    BitToUserHandshake::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BitToUserHandshake* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.user.BitToUserHandshake";
  }
  protected:
  explicit BitToUserHandshake(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthenticationMechanismsFieldNumber = 7,
    kSupportedMethodsFieldNumber = 8,
    kErrorIdFieldNumber = 4,
    kErrorMessageFieldNumber = 5,
    kServerInfosFieldNumber = 6,
    kRpcVersionFieldNumber = 2,
    kEncryptedFieldNumber = 9,
    kMaxWrappedSizeFieldNumber = 10,
    kStatusFieldNumber = 3,
  };
  // repeated string authenticationMechanisms = 7;
  int authenticationmechanisms_size() const;
  private:
  int _internal_authenticationmechanisms_size() const;

  public:
  void clear_authenticationmechanisms() ;
  const std::string& authenticationmechanisms(int index) const;
  std::string* mutable_authenticationmechanisms(int index);
  void set_authenticationmechanisms(int index, const std::string& value);
  void set_authenticationmechanisms(int index, std::string&& value);
  void set_authenticationmechanisms(int index, const char* value);
  void set_authenticationmechanisms(int index, const char* value, std::size_t size);
  void set_authenticationmechanisms(int index, absl::string_view value);
  std::string* add_authenticationmechanisms();
  void add_authenticationmechanisms(const std::string& value);
  void add_authenticationmechanisms(std::string&& value);
  void add_authenticationmechanisms(const char* value);
  void add_authenticationmechanisms(const char* value, std::size_t size);
  void add_authenticationmechanisms(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& authenticationmechanisms() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_authenticationmechanisms();

  private:
  const std::string& _internal_authenticationmechanisms(int index) const;
  std::string* _internal_add_authenticationmechanisms();

  public:
  // repeated .exec.user.RpcType supported_methods = 8;
  int supported_methods_size() const;
  private:
  int _internal_supported_methods_size() const;

  public:
  void clear_supported_methods() ;
  public:
  ::exec::user::RpcType supported_methods(int index) const;
  void set_supported_methods(int index, ::exec::user::RpcType value);
  void add_supported_methods(::exec::user::RpcType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& supported_methods() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_supported_methods();

  private:
  ::exec::user::RpcType _internal_supported_methods(int index) const;
  void _internal_add_supported_methods(::exec::user::RpcType value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_supported_methods();

  public:
  // optional string errorId = 4;
  bool has_errorid() const;
  void clear_errorid() ;
  const std::string& errorid() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_errorid(Arg_&& arg, Args_... args);
  std::string* mutable_errorid();
  PROTOBUF_NODISCARD std::string* release_errorid();
  void set_allocated_errorid(std::string* ptr);

  private:
  const std::string& _internal_errorid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errorid(
      const std::string& value);
  std::string* _internal_mutable_errorid();

  public:
  // optional string errorMessage = 5;
  bool has_errormessage() const;
  void clear_errormessage() ;
  const std::string& errormessage() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_errormessage(Arg_&& arg, Args_... args);
  std::string* mutable_errormessage();
  PROTOBUF_NODISCARD std::string* release_errormessage();
  void set_allocated_errormessage(std::string* ptr);

  private:
  const std::string& _internal_errormessage() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errormessage(
      const std::string& value);
  std::string* _internal_mutable_errormessage();

  public:
  // optional .exec.user.RpcEndpointInfos server_infos = 6;
  bool has_server_infos() const;
  void clear_server_infos() ;
  const ::exec::user::RpcEndpointInfos& server_infos() const;
  PROTOBUF_NODISCARD ::exec::user::RpcEndpointInfos* release_server_infos();
  ::exec::user::RpcEndpointInfos* mutable_server_infos();
  void set_allocated_server_infos(::exec::user::RpcEndpointInfos* server_infos);
  private:
  const ::exec::user::RpcEndpointInfos& _internal_server_infos() const;
  ::exec::user::RpcEndpointInfos* _internal_mutable_server_infos();
  public:
  void unsafe_arena_set_allocated_server_infos(
      ::exec::user::RpcEndpointInfos* server_infos);
  ::exec::user::RpcEndpointInfos* unsafe_arena_release_server_infos();
  // optional int32 rpc_version = 2;
  bool has_rpc_version() const;
  void clear_rpc_version() ;
  ::int32_t rpc_version() const;
  void set_rpc_version(::int32_t value);

  private:
  ::int32_t _internal_rpc_version() const;
  void _internal_set_rpc_version(::int32_t value);

  public:
  // optional bool encrypted = 9;
  bool has_encrypted() const;
  void clear_encrypted() ;
  bool encrypted() const;
  void set_encrypted(bool value);

  private:
  bool _internal_encrypted() const;
  void _internal_set_encrypted(bool value);

  public:
  // optional int32 maxWrappedSize = 10;
  bool has_maxwrappedsize() const;
  void clear_maxwrappedsize() ;
  ::int32_t maxwrappedsize() const;
  void set_maxwrappedsize(::int32_t value);

  private:
  ::int32_t _internal_maxwrappedsize() const;
  void _internal_set_maxwrappedsize(::int32_t value);

  public:
  // optional .exec.user.HandshakeStatus status = 3;
  bool has_status() const;
  void clear_status() ;
  ::exec::user::HandshakeStatus status() const;
  void set_status(::exec::user::HandshakeStatus value);

  private:
  ::exec::user::HandshakeStatus _internal_status() const;
  void _internal_set_status(::exec::user::HandshakeStatus value);

  public:
  // @@protoc_insertion_point(class_scope:exec.user.BitToUserHandshake)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> authenticationmechanisms_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> supported_methods_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errorid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errormessage_;
    ::exec::user::RpcEndpointInfos* server_infos_;
    ::int32_t rpc_version_;
    bool encrypted_;
    ::int32_t maxwrappedsize_;
    int status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_User_2eproto;
};// -------------------------------------------------------------------

class LikeFilter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.user.LikeFilter) */ {
 public:
  inline LikeFilter() : LikeFilter(nullptr) {}
  ~LikeFilter() override;
  explicit PROTOBUF_CONSTEXPR LikeFilter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LikeFilter(const LikeFilter& from);
  LikeFilter(LikeFilter&& from) noexcept
    : LikeFilter() {
    *this = ::std::move(from);
  }

  inline LikeFilter& operator=(const LikeFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline LikeFilter& operator=(LikeFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LikeFilter& default_instance() {
    return *internal_default_instance();
  }
  static inline const LikeFilter* internal_default_instance() {
    return reinterpret_cast<const LikeFilter*>(
               &_LikeFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(LikeFilter& a, LikeFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(LikeFilter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LikeFilter* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LikeFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LikeFilter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LikeFilter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LikeFilter& from) {
    LikeFilter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LikeFilter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.user.LikeFilter";
  }
  protected:
  explicit LikeFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPatternFieldNumber = 1,
    kEscapeFieldNumber = 2,
  };
  // optional string pattern = 1;
  bool has_pattern() const;
  void clear_pattern() ;
  const std::string& pattern() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_pattern(Arg_&& arg, Args_... args);
  std::string* mutable_pattern();
  PROTOBUF_NODISCARD std::string* release_pattern();
  void set_allocated_pattern(std::string* ptr);

  private:
  const std::string& _internal_pattern() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pattern(
      const std::string& value);
  std::string* _internal_mutable_pattern();

  public:
  // optional string escape = 2;
  bool has_escape() const;
  void clear_escape() ;
  const std::string& escape() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_escape(Arg_&& arg, Args_... args);
  std::string* mutable_escape();
  PROTOBUF_NODISCARD std::string* release_escape();
  void set_allocated_escape(std::string* ptr);

  private:
  const std::string& _internal_escape() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_escape(
      const std::string& value);
  std::string* _internal_mutable_escape();

  public:
  // @@protoc_insertion_point(class_scope:exec.user.LikeFilter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pattern_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr escape_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_User_2eproto;
};// -------------------------------------------------------------------

class GetCatalogsReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.user.GetCatalogsReq) */ {
 public:
  inline GetCatalogsReq() : GetCatalogsReq(nullptr) {}
  ~GetCatalogsReq() override;
  explicit PROTOBUF_CONSTEXPR GetCatalogsReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetCatalogsReq(const GetCatalogsReq& from);
  GetCatalogsReq(GetCatalogsReq&& from) noexcept
    : GetCatalogsReq() {
    *this = ::std::move(from);
  }

  inline GetCatalogsReq& operator=(const GetCatalogsReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetCatalogsReq& operator=(GetCatalogsReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetCatalogsReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetCatalogsReq* internal_default_instance() {
    return reinterpret_cast<const GetCatalogsReq*>(
               &_GetCatalogsReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(GetCatalogsReq& a, GetCatalogsReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetCatalogsReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetCatalogsReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetCatalogsReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetCatalogsReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetCatalogsReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetCatalogsReq& from) {
    GetCatalogsReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetCatalogsReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.user.GetCatalogsReq";
  }
  protected:
  explicit GetCatalogsReq(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCatalogNameFilterFieldNumber = 1,
  };
  // optional .exec.user.LikeFilter catalog_name_filter = 1;
  bool has_catalog_name_filter() const;
  void clear_catalog_name_filter() ;
  const ::exec::user::LikeFilter& catalog_name_filter() const;
  PROTOBUF_NODISCARD ::exec::user::LikeFilter* release_catalog_name_filter();
  ::exec::user::LikeFilter* mutable_catalog_name_filter();
  void set_allocated_catalog_name_filter(::exec::user::LikeFilter* catalog_name_filter);
  private:
  const ::exec::user::LikeFilter& _internal_catalog_name_filter() const;
  ::exec::user::LikeFilter* _internal_mutable_catalog_name_filter();
  public:
  void unsafe_arena_set_allocated_catalog_name_filter(
      ::exec::user::LikeFilter* catalog_name_filter);
  ::exec::user::LikeFilter* unsafe_arena_release_catalog_name_filter();
  // @@protoc_insertion_point(class_scope:exec.user.GetCatalogsReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::exec::user::LikeFilter* catalog_name_filter_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_User_2eproto;
};// -------------------------------------------------------------------

class CatalogMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.user.CatalogMetadata) */ {
 public:
  inline CatalogMetadata() : CatalogMetadata(nullptr) {}
  ~CatalogMetadata() override;
  explicit PROTOBUF_CONSTEXPR CatalogMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CatalogMetadata(const CatalogMetadata& from);
  CatalogMetadata(CatalogMetadata&& from) noexcept
    : CatalogMetadata() {
    *this = ::std::move(from);
  }

  inline CatalogMetadata& operator=(const CatalogMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline CatalogMetadata& operator=(CatalogMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CatalogMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const CatalogMetadata* internal_default_instance() {
    return reinterpret_cast<const CatalogMetadata*>(
               &_CatalogMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CatalogMetadata& a, CatalogMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(CatalogMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CatalogMetadata* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CatalogMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CatalogMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CatalogMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CatalogMetadata& from) {
    CatalogMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CatalogMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.user.CatalogMetadata";
  }
  protected:
  explicit CatalogMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCatalogNameFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kConnectFieldNumber = 3,
  };
  // optional string catalog_name = 1;
  bool has_catalog_name() const;
  void clear_catalog_name() ;
  const std::string& catalog_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_catalog_name(Arg_&& arg, Args_... args);
  std::string* mutable_catalog_name();
  PROTOBUF_NODISCARD std::string* release_catalog_name();
  void set_allocated_catalog_name(std::string* ptr);

  private:
  const std::string& _internal_catalog_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_catalog_name(
      const std::string& value);
  std::string* _internal_mutable_catalog_name();

  public:
  // optional string description = 2;
  bool has_description() const;
  void clear_description() ;
  const std::string& description() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* ptr);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // optional string connect = 3;
  bool has_connect() const;
  void clear_connect() ;
  const std::string& connect() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_connect(Arg_&& arg, Args_... args);
  std::string* mutable_connect();
  PROTOBUF_NODISCARD std::string* release_connect();
  void set_allocated_connect(std::string* ptr);

  private:
  const std::string& _internal_connect() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_connect(
      const std::string& value);
  std::string* _internal_mutable_connect();

  public:
  // @@protoc_insertion_point(class_scope:exec.user.CatalogMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr catalog_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr connect_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_User_2eproto;
};// -------------------------------------------------------------------

class GetCatalogsResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.user.GetCatalogsResp) */ {
 public:
  inline GetCatalogsResp() : GetCatalogsResp(nullptr) {}
  ~GetCatalogsResp() override;
  explicit PROTOBUF_CONSTEXPR GetCatalogsResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetCatalogsResp(const GetCatalogsResp& from);
  GetCatalogsResp(GetCatalogsResp&& from) noexcept
    : GetCatalogsResp() {
    *this = ::std::move(from);
  }

  inline GetCatalogsResp& operator=(const GetCatalogsResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetCatalogsResp& operator=(GetCatalogsResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetCatalogsResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetCatalogsResp* internal_default_instance() {
    return reinterpret_cast<const GetCatalogsResp*>(
               &_GetCatalogsResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GetCatalogsResp& a, GetCatalogsResp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetCatalogsResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetCatalogsResp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetCatalogsResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetCatalogsResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetCatalogsResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetCatalogsResp& from) {
    GetCatalogsResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetCatalogsResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.user.GetCatalogsResp";
  }
  protected:
  explicit GetCatalogsResp(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCatalogsFieldNumber = 2,
    kErrorFieldNumber = 3,
    kStatusFieldNumber = 1,
  };
  // repeated .exec.user.CatalogMetadata catalogs = 2;
  int catalogs_size() const;
  private:
  int _internal_catalogs_size() const;

  public:
  void clear_catalogs() ;
  ::exec::user::CatalogMetadata* mutable_catalogs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::user::CatalogMetadata >*
      mutable_catalogs();
  private:
  const ::exec::user::CatalogMetadata& _internal_catalogs(int index) const;
  ::exec::user::CatalogMetadata* _internal_add_catalogs();
  public:
  const ::exec::user::CatalogMetadata& catalogs(int index) const;
  ::exec::user::CatalogMetadata* add_catalogs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::user::CatalogMetadata >&
      catalogs() const;
  // optional .exec.shared.DrillPBError error = 3;
  bool has_error() const;
  void clear_error() ;
  const ::exec::shared::DrillPBError& error() const;
  PROTOBUF_NODISCARD ::exec::shared::DrillPBError* release_error();
  ::exec::shared::DrillPBError* mutable_error();
  void set_allocated_error(::exec::shared::DrillPBError* error);
  private:
  const ::exec::shared::DrillPBError& _internal_error() const;
  ::exec::shared::DrillPBError* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::exec::shared::DrillPBError* error);
  ::exec::shared::DrillPBError* unsafe_arena_release_error();
  // optional .exec.user.RequestStatus status = 1;
  bool has_status() const;
  void clear_status() ;
  ::exec::user::RequestStatus status() const;
  void set_status(::exec::user::RequestStatus value);

  private:
  ::exec::user::RequestStatus _internal_status() const;
  void _internal_set_status(::exec::user::RequestStatus value);

  public:
  // @@protoc_insertion_point(class_scope:exec.user.GetCatalogsResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::user::CatalogMetadata > catalogs_;
    ::exec::shared::DrillPBError* error_;
    int status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_User_2eproto;
};// -------------------------------------------------------------------

class GetSchemasReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.user.GetSchemasReq) */ {
 public:
  inline GetSchemasReq() : GetSchemasReq(nullptr) {}
  ~GetSchemasReq() override;
  explicit PROTOBUF_CONSTEXPR GetSchemasReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSchemasReq(const GetSchemasReq& from);
  GetSchemasReq(GetSchemasReq&& from) noexcept
    : GetSchemasReq() {
    *this = ::std::move(from);
  }

  inline GetSchemasReq& operator=(const GetSchemasReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSchemasReq& operator=(GetSchemasReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSchemasReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSchemasReq* internal_default_instance() {
    return reinterpret_cast<const GetSchemasReq*>(
               &_GetSchemasReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GetSchemasReq& a, GetSchemasReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSchemasReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSchemasReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSchemasReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSchemasReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSchemasReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetSchemasReq& from) {
    GetSchemasReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSchemasReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.user.GetSchemasReq";
  }
  protected:
  explicit GetSchemasReq(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCatalogNameFilterFieldNumber = 1,
    kSchemaNameFilterFieldNumber = 2,
  };
  // optional .exec.user.LikeFilter catalog_name_filter = 1;
  bool has_catalog_name_filter() const;
  void clear_catalog_name_filter() ;
  const ::exec::user::LikeFilter& catalog_name_filter() const;
  PROTOBUF_NODISCARD ::exec::user::LikeFilter* release_catalog_name_filter();
  ::exec::user::LikeFilter* mutable_catalog_name_filter();
  void set_allocated_catalog_name_filter(::exec::user::LikeFilter* catalog_name_filter);
  private:
  const ::exec::user::LikeFilter& _internal_catalog_name_filter() const;
  ::exec::user::LikeFilter* _internal_mutable_catalog_name_filter();
  public:
  void unsafe_arena_set_allocated_catalog_name_filter(
      ::exec::user::LikeFilter* catalog_name_filter);
  ::exec::user::LikeFilter* unsafe_arena_release_catalog_name_filter();
  // optional .exec.user.LikeFilter schema_name_filter = 2;
  bool has_schema_name_filter() const;
  void clear_schema_name_filter() ;
  const ::exec::user::LikeFilter& schema_name_filter() const;
  PROTOBUF_NODISCARD ::exec::user::LikeFilter* release_schema_name_filter();
  ::exec::user::LikeFilter* mutable_schema_name_filter();
  void set_allocated_schema_name_filter(::exec::user::LikeFilter* schema_name_filter);
  private:
  const ::exec::user::LikeFilter& _internal_schema_name_filter() const;
  ::exec::user::LikeFilter* _internal_mutable_schema_name_filter();
  public:
  void unsafe_arena_set_allocated_schema_name_filter(
      ::exec::user::LikeFilter* schema_name_filter);
  ::exec::user::LikeFilter* unsafe_arena_release_schema_name_filter();
  // @@protoc_insertion_point(class_scope:exec.user.GetSchemasReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::exec::user::LikeFilter* catalog_name_filter_;
    ::exec::user::LikeFilter* schema_name_filter_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_User_2eproto;
};// -------------------------------------------------------------------

class SchemaMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.user.SchemaMetadata) */ {
 public:
  inline SchemaMetadata() : SchemaMetadata(nullptr) {}
  ~SchemaMetadata() override;
  explicit PROTOBUF_CONSTEXPR SchemaMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SchemaMetadata(const SchemaMetadata& from);
  SchemaMetadata(SchemaMetadata&& from) noexcept
    : SchemaMetadata() {
    *this = ::std::move(from);
  }

  inline SchemaMetadata& operator=(const SchemaMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchemaMetadata& operator=(SchemaMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SchemaMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const SchemaMetadata* internal_default_instance() {
    return reinterpret_cast<const SchemaMetadata*>(
               &_SchemaMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SchemaMetadata& a, SchemaMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(SchemaMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SchemaMetadata* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SchemaMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SchemaMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SchemaMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SchemaMetadata& from) {
    SchemaMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SchemaMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.user.SchemaMetadata";
  }
  protected:
  explicit SchemaMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCatalogNameFieldNumber = 1,
    kSchemaNameFieldNumber = 2,
    kOwnerFieldNumber = 3,
    kTypeFieldNumber = 4,
    kMutableFieldNumber = 5,
  };
  // optional string catalog_name = 1;
  bool has_catalog_name() const;
  void clear_catalog_name() ;
  const std::string& catalog_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_catalog_name(Arg_&& arg, Args_... args);
  std::string* mutable_catalog_name();
  PROTOBUF_NODISCARD std::string* release_catalog_name();
  void set_allocated_catalog_name(std::string* ptr);

  private:
  const std::string& _internal_catalog_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_catalog_name(
      const std::string& value);
  std::string* _internal_mutable_catalog_name();

  public:
  // optional string schema_name = 2;
  bool has_schema_name() const;
  void clear_schema_name() ;
  const std::string& schema_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_schema_name(Arg_&& arg, Args_... args);
  std::string* mutable_schema_name();
  PROTOBUF_NODISCARD std::string* release_schema_name();
  void set_allocated_schema_name(std::string* ptr);

  private:
  const std::string& _internal_schema_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_name(
      const std::string& value);
  std::string* _internal_mutable_schema_name();

  public:
  // optional string owner = 3;
  bool has_owner() const;
  void clear_owner() ;
  const std::string& owner() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_owner(Arg_&& arg, Args_... args);
  std::string* mutable_owner();
  PROTOBUF_NODISCARD std::string* release_owner();
  void set_allocated_owner(std::string* ptr);

  private:
  const std::string& _internal_owner() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_owner(
      const std::string& value);
  std::string* _internal_mutable_owner();

  public:
  // optional string type = 4;
  bool has_type() const;
  void clear_type() ;
  const std::string& type() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_type(Arg_&& arg, Args_... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* ptr);

  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(
      const std::string& value);
  std::string* _internal_mutable_type();

  public:
  // optional string mutable = 5;
  bool has_mutable_() const;
  void clear_mutable_() ;
  const std::string& mutable_() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mutable_(Arg_&& arg, Args_... args);
  std::string* mutable_mutable_();
  PROTOBUF_NODISCARD std::string* release_mutable_();
  void set_allocated_mutable_(std::string* ptr);

  private:
  const std::string& _internal_mutable_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mutable_(
      const std::string& value);
  std::string* _internal_mutable_mutable_();

  public:
  // @@protoc_insertion_point(class_scope:exec.user.SchemaMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr catalog_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mutable__;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_User_2eproto;
};// -------------------------------------------------------------------

class GetSchemasResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.user.GetSchemasResp) */ {
 public:
  inline GetSchemasResp() : GetSchemasResp(nullptr) {}
  ~GetSchemasResp() override;
  explicit PROTOBUF_CONSTEXPR GetSchemasResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSchemasResp(const GetSchemasResp& from);
  GetSchemasResp(GetSchemasResp&& from) noexcept
    : GetSchemasResp() {
    *this = ::std::move(from);
  }

  inline GetSchemasResp& operator=(const GetSchemasResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSchemasResp& operator=(GetSchemasResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSchemasResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSchemasResp* internal_default_instance() {
    return reinterpret_cast<const GetSchemasResp*>(
               &_GetSchemasResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GetSchemasResp& a, GetSchemasResp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSchemasResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSchemasResp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSchemasResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSchemasResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSchemasResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetSchemasResp& from) {
    GetSchemasResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSchemasResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.user.GetSchemasResp";
  }
  protected:
  explicit GetSchemasResp(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSchemasFieldNumber = 2,
    kErrorFieldNumber = 3,
    kStatusFieldNumber = 1,
  };
  // repeated .exec.user.SchemaMetadata schemas = 2;
  int schemas_size() const;
  private:
  int _internal_schemas_size() const;

  public:
  void clear_schemas() ;
  ::exec::user::SchemaMetadata* mutable_schemas(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::user::SchemaMetadata >*
      mutable_schemas();
  private:
  const ::exec::user::SchemaMetadata& _internal_schemas(int index) const;
  ::exec::user::SchemaMetadata* _internal_add_schemas();
  public:
  const ::exec::user::SchemaMetadata& schemas(int index) const;
  ::exec::user::SchemaMetadata* add_schemas();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::user::SchemaMetadata >&
      schemas() const;
  // optional .exec.shared.DrillPBError error = 3;
  bool has_error() const;
  void clear_error() ;
  const ::exec::shared::DrillPBError& error() const;
  PROTOBUF_NODISCARD ::exec::shared::DrillPBError* release_error();
  ::exec::shared::DrillPBError* mutable_error();
  void set_allocated_error(::exec::shared::DrillPBError* error);
  private:
  const ::exec::shared::DrillPBError& _internal_error() const;
  ::exec::shared::DrillPBError* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::exec::shared::DrillPBError* error);
  ::exec::shared::DrillPBError* unsafe_arena_release_error();
  // optional .exec.user.RequestStatus status = 1;
  bool has_status() const;
  void clear_status() ;
  ::exec::user::RequestStatus status() const;
  void set_status(::exec::user::RequestStatus value);

  private:
  ::exec::user::RequestStatus _internal_status() const;
  void _internal_set_status(::exec::user::RequestStatus value);

  public:
  // @@protoc_insertion_point(class_scope:exec.user.GetSchemasResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::user::SchemaMetadata > schemas_;
    ::exec::shared::DrillPBError* error_;
    int status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_User_2eproto;
};// -------------------------------------------------------------------

class GetTablesReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.user.GetTablesReq) */ {
 public:
  inline GetTablesReq() : GetTablesReq(nullptr) {}
  ~GetTablesReq() override;
  explicit PROTOBUF_CONSTEXPR GetTablesReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTablesReq(const GetTablesReq& from);
  GetTablesReq(GetTablesReq&& from) noexcept
    : GetTablesReq() {
    *this = ::std::move(from);
  }

  inline GetTablesReq& operator=(const GetTablesReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTablesReq& operator=(GetTablesReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTablesReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTablesReq* internal_default_instance() {
    return reinterpret_cast<const GetTablesReq*>(
               &_GetTablesReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(GetTablesReq& a, GetTablesReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTablesReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTablesReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTablesReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTablesReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTablesReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetTablesReq& from) {
    GetTablesReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTablesReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.user.GetTablesReq";
  }
  protected:
  explicit GetTablesReq(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTableTypeFilterFieldNumber = 4,
    kCatalogNameFilterFieldNumber = 1,
    kSchemaNameFilterFieldNumber = 2,
    kTableNameFilterFieldNumber = 3,
  };
  // repeated string table_type_filter = 4;
  int table_type_filter_size() const;
  private:
  int _internal_table_type_filter_size() const;

  public:
  void clear_table_type_filter() ;
  const std::string& table_type_filter(int index) const;
  std::string* mutable_table_type_filter(int index);
  void set_table_type_filter(int index, const std::string& value);
  void set_table_type_filter(int index, std::string&& value);
  void set_table_type_filter(int index, const char* value);
  void set_table_type_filter(int index, const char* value, std::size_t size);
  void set_table_type_filter(int index, absl::string_view value);
  std::string* add_table_type_filter();
  void add_table_type_filter(const std::string& value);
  void add_table_type_filter(std::string&& value);
  void add_table_type_filter(const char* value);
  void add_table_type_filter(const char* value, std::size_t size);
  void add_table_type_filter(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& table_type_filter() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_table_type_filter();

  private:
  const std::string& _internal_table_type_filter(int index) const;
  std::string* _internal_add_table_type_filter();

  public:
  // optional .exec.user.LikeFilter catalog_name_filter = 1;
  bool has_catalog_name_filter() const;
  void clear_catalog_name_filter() ;
  const ::exec::user::LikeFilter& catalog_name_filter() const;
  PROTOBUF_NODISCARD ::exec::user::LikeFilter* release_catalog_name_filter();
  ::exec::user::LikeFilter* mutable_catalog_name_filter();
  void set_allocated_catalog_name_filter(::exec::user::LikeFilter* catalog_name_filter);
  private:
  const ::exec::user::LikeFilter& _internal_catalog_name_filter() const;
  ::exec::user::LikeFilter* _internal_mutable_catalog_name_filter();
  public:
  void unsafe_arena_set_allocated_catalog_name_filter(
      ::exec::user::LikeFilter* catalog_name_filter);
  ::exec::user::LikeFilter* unsafe_arena_release_catalog_name_filter();
  // optional .exec.user.LikeFilter schema_name_filter = 2;
  bool has_schema_name_filter() const;
  void clear_schema_name_filter() ;
  const ::exec::user::LikeFilter& schema_name_filter() const;
  PROTOBUF_NODISCARD ::exec::user::LikeFilter* release_schema_name_filter();
  ::exec::user::LikeFilter* mutable_schema_name_filter();
  void set_allocated_schema_name_filter(::exec::user::LikeFilter* schema_name_filter);
  private:
  const ::exec::user::LikeFilter& _internal_schema_name_filter() const;
  ::exec::user::LikeFilter* _internal_mutable_schema_name_filter();
  public:
  void unsafe_arena_set_allocated_schema_name_filter(
      ::exec::user::LikeFilter* schema_name_filter);
  ::exec::user::LikeFilter* unsafe_arena_release_schema_name_filter();
  // optional .exec.user.LikeFilter table_name_filter = 3;
  bool has_table_name_filter() const;
  void clear_table_name_filter() ;
  const ::exec::user::LikeFilter& table_name_filter() const;
  PROTOBUF_NODISCARD ::exec::user::LikeFilter* release_table_name_filter();
  ::exec::user::LikeFilter* mutable_table_name_filter();
  void set_allocated_table_name_filter(::exec::user::LikeFilter* table_name_filter);
  private:
  const ::exec::user::LikeFilter& _internal_table_name_filter() const;
  ::exec::user::LikeFilter* _internal_mutable_table_name_filter();
  public:
  void unsafe_arena_set_allocated_table_name_filter(
      ::exec::user::LikeFilter* table_name_filter);
  ::exec::user::LikeFilter* unsafe_arena_release_table_name_filter();
  // @@protoc_insertion_point(class_scope:exec.user.GetTablesReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> table_type_filter_;
    ::exec::user::LikeFilter* catalog_name_filter_;
    ::exec::user::LikeFilter* schema_name_filter_;
    ::exec::user::LikeFilter* table_name_filter_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_User_2eproto;
};// -------------------------------------------------------------------

class TableMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.user.TableMetadata) */ {
 public:
  inline TableMetadata() : TableMetadata(nullptr) {}
  ~TableMetadata() override;
  explicit PROTOBUF_CONSTEXPR TableMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TableMetadata(const TableMetadata& from);
  TableMetadata(TableMetadata&& from) noexcept
    : TableMetadata() {
    *this = ::std::move(from);
  }

  inline TableMetadata& operator=(const TableMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline TableMetadata& operator=(TableMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TableMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const TableMetadata* internal_default_instance() {
    return reinterpret_cast<const TableMetadata*>(
               &_TableMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(TableMetadata& a, TableMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(TableMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TableMetadata* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TableMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TableMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TableMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TableMetadata& from) {
    TableMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.user.TableMetadata";
  }
  protected:
  explicit TableMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCatalogNameFieldNumber = 1,
    kSchemaNameFieldNumber = 2,
    kTableNameFieldNumber = 3,
    kTypeFieldNumber = 4,
  };
  // optional string catalog_name = 1;
  bool has_catalog_name() const;
  void clear_catalog_name() ;
  const std::string& catalog_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_catalog_name(Arg_&& arg, Args_... args);
  std::string* mutable_catalog_name();
  PROTOBUF_NODISCARD std::string* release_catalog_name();
  void set_allocated_catalog_name(std::string* ptr);

  private:
  const std::string& _internal_catalog_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_catalog_name(
      const std::string& value);
  std::string* _internal_mutable_catalog_name();

  public:
  // optional string schema_name = 2;
  bool has_schema_name() const;
  void clear_schema_name() ;
  const std::string& schema_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_schema_name(Arg_&& arg, Args_... args);
  std::string* mutable_schema_name();
  PROTOBUF_NODISCARD std::string* release_schema_name();
  void set_allocated_schema_name(std::string* ptr);

  private:
  const std::string& _internal_schema_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_name(
      const std::string& value);
  std::string* _internal_mutable_schema_name();

  public:
  // optional string table_name = 3;
  bool has_table_name() const;
  void clear_table_name() ;
  const std::string& table_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_table_name(Arg_&& arg, Args_... args);
  std::string* mutable_table_name();
  PROTOBUF_NODISCARD std::string* release_table_name();
  void set_allocated_table_name(std::string* ptr);

  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(
      const std::string& value);
  std::string* _internal_mutable_table_name();

  public:
  // optional string type = 4;
  bool has_type() const;
  void clear_type() ;
  const std::string& type() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_type(Arg_&& arg, Args_... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* ptr);

  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(
      const std::string& value);
  std::string* _internal_mutable_type();

  public:
  // @@protoc_insertion_point(class_scope:exec.user.TableMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr catalog_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_User_2eproto;
};// -------------------------------------------------------------------

class GetTablesResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.user.GetTablesResp) */ {
 public:
  inline GetTablesResp() : GetTablesResp(nullptr) {}
  ~GetTablesResp() override;
  explicit PROTOBUF_CONSTEXPR GetTablesResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTablesResp(const GetTablesResp& from);
  GetTablesResp(GetTablesResp&& from) noexcept
    : GetTablesResp() {
    *this = ::std::move(from);
  }

  inline GetTablesResp& operator=(const GetTablesResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTablesResp& operator=(GetTablesResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTablesResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTablesResp* internal_default_instance() {
    return reinterpret_cast<const GetTablesResp*>(
               &_GetTablesResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(GetTablesResp& a, GetTablesResp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTablesResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTablesResp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTablesResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTablesResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTablesResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetTablesResp& from) {
    GetTablesResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTablesResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.user.GetTablesResp";
  }
  protected:
  explicit GetTablesResp(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTablesFieldNumber = 2,
    kErrorFieldNumber = 3,
    kStatusFieldNumber = 1,
  };
  // repeated .exec.user.TableMetadata tables = 2;
  int tables_size() const;
  private:
  int _internal_tables_size() const;

  public:
  void clear_tables() ;
  ::exec::user::TableMetadata* mutable_tables(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::user::TableMetadata >*
      mutable_tables();
  private:
  const ::exec::user::TableMetadata& _internal_tables(int index) const;
  ::exec::user::TableMetadata* _internal_add_tables();
  public:
  const ::exec::user::TableMetadata& tables(int index) const;
  ::exec::user::TableMetadata* add_tables();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::user::TableMetadata >&
      tables() const;
  // optional .exec.shared.DrillPBError error = 3;
  bool has_error() const;
  void clear_error() ;
  const ::exec::shared::DrillPBError& error() const;
  PROTOBUF_NODISCARD ::exec::shared::DrillPBError* release_error();
  ::exec::shared::DrillPBError* mutable_error();
  void set_allocated_error(::exec::shared::DrillPBError* error);
  private:
  const ::exec::shared::DrillPBError& _internal_error() const;
  ::exec::shared::DrillPBError* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::exec::shared::DrillPBError* error);
  ::exec::shared::DrillPBError* unsafe_arena_release_error();
  // optional .exec.user.RequestStatus status = 1;
  bool has_status() const;
  void clear_status() ;
  ::exec::user::RequestStatus status() const;
  void set_status(::exec::user::RequestStatus value);

  private:
  ::exec::user::RequestStatus _internal_status() const;
  void _internal_set_status(::exec::user::RequestStatus value);

  public:
  // @@protoc_insertion_point(class_scope:exec.user.GetTablesResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::user::TableMetadata > tables_;
    ::exec::shared::DrillPBError* error_;
    int status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_User_2eproto;
};// -------------------------------------------------------------------

class GetColumnsReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.user.GetColumnsReq) */ {
 public:
  inline GetColumnsReq() : GetColumnsReq(nullptr) {}
  ~GetColumnsReq() override;
  explicit PROTOBUF_CONSTEXPR GetColumnsReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetColumnsReq(const GetColumnsReq& from);
  GetColumnsReq(GetColumnsReq&& from) noexcept
    : GetColumnsReq() {
    *this = ::std::move(from);
  }

  inline GetColumnsReq& operator=(const GetColumnsReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetColumnsReq& operator=(GetColumnsReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetColumnsReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetColumnsReq* internal_default_instance() {
    return reinterpret_cast<const GetColumnsReq*>(
               &_GetColumnsReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(GetColumnsReq& a, GetColumnsReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetColumnsReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetColumnsReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetColumnsReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetColumnsReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetColumnsReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetColumnsReq& from) {
    GetColumnsReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetColumnsReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.user.GetColumnsReq";
  }
  protected:
  explicit GetColumnsReq(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCatalogNameFilterFieldNumber = 1,
    kSchemaNameFilterFieldNumber = 2,
    kTableNameFilterFieldNumber = 3,
    kColumnNameFilterFieldNumber = 4,
  };
  // optional .exec.user.LikeFilter catalog_name_filter = 1;
  bool has_catalog_name_filter() const;
  void clear_catalog_name_filter() ;
  const ::exec::user::LikeFilter& catalog_name_filter() const;
  PROTOBUF_NODISCARD ::exec::user::LikeFilter* release_catalog_name_filter();
  ::exec::user::LikeFilter* mutable_catalog_name_filter();
  void set_allocated_catalog_name_filter(::exec::user::LikeFilter* catalog_name_filter);
  private:
  const ::exec::user::LikeFilter& _internal_catalog_name_filter() const;
  ::exec::user::LikeFilter* _internal_mutable_catalog_name_filter();
  public:
  void unsafe_arena_set_allocated_catalog_name_filter(
      ::exec::user::LikeFilter* catalog_name_filter);
  ::exec::user::LikeFilter* unsafe_arena_release_catalog_name_filter();
  // optional .exec.user.LikeFilter schema_name_filter = 2;
  bool has_schema_name_filter() const;
  void clear_schema_name_filter() ;
  const ::exec::user::LikeFilter& schema_name_filter() const;
  PROTOBUF_NODISCARD ::exec::user::LikeFilter* release_schema_name_filter();
  ::exec::user::LikeFilter* mutable_schema_name_filter();
  void set_allocated_schema_name_filter(::exec::user::LikeFilter* schema_name_filter);
  private:
  const ::exec::user::LikeFilter& _internal_schema_name_filter() const;
  ::exec::user::LikeFilter* _internal_mutable_schema_name_filter();
  public:
  void unsafe_arena_set_allocated_schema_name_filter(
      ::exec::user::LikeFilter* schema_name_filter);
  ::exec::user::LikeFilter* unsafe_arena_release_schema_name_filter();
  // optional .exec.user.LikeFilter table_name_filter = 3;
  bool has_table_name_filter() const;
  void clear_table_name_filter() ;
  const ::exec::user::LikeFilter& table_name_filter() const;
  PROTOBUF_NODISCARD ::exec::user::LikeFilter* release_table_name_filter();
  ::exec::user::LikeFilter* mutable_table_name_filter();
  void set_allocated_table_name_filter(::exec::user::LikeFilter* table_name_filter);
  private:
  const ::exec::user::LikeFilter& _internal_table_name_filter() const;
  ::exec::user::LikeFilter* _internal_mutable_table_name_filter();
  public:
  void unsafe_arena_set_allocated_table_name_filter(
      ::exec::user::LikeFilter* table_name_filter);
  ::exec::user::LikeFilter* unsafe_arena_release_table_name_filter();
  // optional .exec.user.LikeFilter column_name_filter = 4;
  bool has_column_name_filter() const;
  void clear_column_name_filter() ;
  const ::exec::user::LikeFilter& column_name_filter() const;
  PROTOBUF_NODISCARD ::exec::user::LikeFilter* release_column_name_filter();
  ::exec::user::LikeFilter* mutable_column_name_filter();
  void set_allocated_column_name_filter(::exec::user::LikeFilter* column_name_filter);
  private:
  const ::exec::user::LikeFilter& _internal_column_name_filter() const;
  ::exec::user::LikeFilter* _internal_mutable_column_name_filter();
  public:
  void unsafe_arena_set_allocated_column_name_filter(
      ::exec::user::LikeFilter* column_name_filter);
  ::exec::user::LikeFilter* unsafe_arena_release_column_name_filter();
  // @@protoc_insertion_point(class_scope:exec.user.GetColumnsReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::exec::user::LikeFilter* catalog_name_filter_;
    ::exec::user::LikeFilter* schema_name_filter_;
    ::exec::user::LikeFilter* table_name_filter_;
    ::exec::user::LikeFilter* column_name_filter_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_User_2eproto;
};// -------------------------------------------------------------------

class ColumnMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.user.ColumnMetadata) */ {
 public:
  inline ColumnMetadata() : ColumnMetadata(nullptr) {}
  ~ColumnMetadata() override;
  explicit PROTOBUF_CONSTEXPR ColumnMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ColumnMetadata(const ColumnMetadata& from);
  ColumnMetadata(ColumnMetadata&& from) noexcept
    : ColumnMetadata() {
    *this = ::std::move(from);
  }

  inline ColumnMetadata& operator=(const ColumnMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline ColumnMetadata& operator=(ColumnMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ColumnMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const ColumnMetadata* internal_default_instance() {
    return reinterpret_cast<const ColumnMetadata*>(
               &_ColumnMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ColumnMetadata& a, ColumnMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(ColumnMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ColumnMetadata* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ColumnMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ColumnMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ColumnMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ColumnMetadata& from) {
    ColumnMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ColumnMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.user.ColumnMetadata";
  }
  protected:
  explicit ColumnMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCatalogNameFieldNumber = 1,
    kSchemaNameFieldNumber = 2,
    kTableNameFieldNumber = 3,
    kColumnNameFieldNumber = 4,
    kDefaultValueFieldNumber = 6,
    kDataTypeFieldNumber = 8,
    kIntervalTypeFieldNumber = 15,
    kOrdinalPositionFieldNumber = 5,
    kIsNullableFieldNumber = 7,
    kCharMaxLengthFieldNumber = 9,
    kCharOctetLengthFieldNumber = 10,
    kNumericPrecisionFieldNumber = 11,
    kNumericPrecisionRadixFieldNumber = 12,
    kNumericScaleFieldNumber = 13,
    kDateTimePrecisionFieldNumber = 14,
    kIntervalPrecisionFieldNumber = 16,
    kColumnSizeFieldNumber = 17,
  };
  // optional string catalog_name = 1;
  bool has_catalog_name() const;
  void clear_catalog_name() ;
  const std::string& catalog_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_catalog_name(Arg_&& arg, Args_... args);
  std::string* mutable_catalog_name();
  PROTOBUF_NODISCARD std::string* release_catalog_name();
  void set_allocated_catalog_name(std::string* ptr);

  private:
  const std::string& _internal_catalog_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_catalog_name(
      const std::string& value);
  std::string* _internal_mutable_catalog_name();

  public:
  // optional string schema_name = 2;
  bool has_schema_name() const;
  void clear_schema_name() ;
  const std::string& schema_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_schema_name(Arg_&& arg, Args_... args);
  std::string* mutable_schema_name();
  PROTOBUF_NODISCARD std::string* release_schema_name();
  void set_allocated_schema_name(std::string* ptr);

  private:
  const std::string& _internal_schema_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_name(
      const std::string& value);
  std::string* _internal_mutable_schema_name();

  public:
  // optional string table_name = 3;
  bool has_table_name() const;
  void clear_table_name() ;
  const std::string& table_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_table_name(Arg_&& arg, Args_... args);
  std::string* mutable_table_name();
  PROTOBUF_NODISCARD std::string* release_table_name();
  void set_allocated_table_name(std::string* ptr);

  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(
      const std::string& value);
  std::string* _internal_mutable_table_name();

  public:
  // optional string column_name = 4;
  bool has_column_name() const;
  void clear_column_name() ;
  const std::string& column_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_column_name(Arg_&& arg, Args_... args);
  std::string* mutable_column_name();
  PROTOBUF_NODISCARD std::string* release_column_name();
  void set_allocated_column_name(std::string* ptr);

  private:
  const std::string& _internal_column_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_column_name(
      const std::string& value);
  std::string* _internal_mutable_column_name();

  public:
  // optional string default_value = 6;
  bool has_default_value() const;
  void clear_default_value() ;
  const std::string& default_value() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_default_value(Arg_&& arg, Args_... args);
  std::string* mutable_default_value();
  PROTOBUF_NODISCARD std::string* release_default_value();
  void set_allocated_default_value(std::string* ptr);

  private:
  const std::string& _internal_default_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_default_value(
      const std::string& value);
  std::string* _internal_mutable_default_value();

  public:
  // optional string data_type = 8;
  bool has_data_type() const;
  void clear_data_type() ;
  const std::string& data_type() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data_type(Arg_&& arg, Args_... args);
  std::string* mutable_data_type();
  PROTOBUF_NODISCARD std::string* release_data_type();
  void set_allocated_data_type(std::string* ptr);

  private:
  const std::string& _internal_data_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data_type(
      const std::string& value);
  std::string* _internal_mutable_data_type();

  public:
  // optional string interval_type = 15;
  bool has_interval_type() const;
  void clear_interval_type() ;
  const std::string& interval_type() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_interval_type(Arg_&& arg, Args_... args);
  std::string* mutable_interval_type();
  PROTOBUF_NODISCARD std::string* release_interval_type();
  void set_allocated_interval_type(std::string* ptr);

  private:
  const std::string& _internal_interval_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_interval_type(
      const std::string& value);
  std::string* _internal_mutable_interval_type();

  public:
  // optional int32 ordinal_position = 5;
  bool has_ordinal_position() const;
  void clear_ordinal_position() ;
  ::int32_t ordinal_position() const;
  void set_ordinal_position(::int32_t value);

  private:
  ::int32_t _internal_ordinal_position() const;
  void _internal_set_ordinal_position(::int32_t value);

  public:
  // optional bool is_nullable = 7;
  bool has_is_nullable() const;
  void clear_is_nullable() ;
  bool is_nullable() const;
  void set_is_nullable(bool value);

  private:
  bool _internal_is_nullable() const;
  void _internal_set_is_nullable(bool value);

  public:
  // optional int32 char_max_length = 9;
  bool has_char_max_length() const;
  void clear_char_max_length() ;
  ::int32_t char_max_length() const;
  void set_char_max_length(::int32_t value);

  private:
  ::int32_t _internal_char_max_length() const;
  void _internal_set_char_max_length(::int32_t value);

  public:
  // optional int32 char_octet_length = 10;
  bool has_char_octet_length() const;
  void clear_char_octet_length() ;
  ::int32_t char_octet_length() const;
  void set_char_octet_length(::int32_t value);

  private:
  ::int32_t _internal_char_octet_length() const;
  void _internal_set_char_octet_length(::int32_t value);

  public:
  // optional int32 numeric_precision = 11;
  bool has_numeric_precision() const;
  void clear_numeric_precision() ;
  ::int32_t numeric_precision() const;
  void set_numeric_precision(::int32_t value);

  private:
  ::int32_t _internal_numeric_precision() const;
  void _internal_set_numeric_precision(::int32_t value);

  public:
  // optional int32 numeric_precision_radix = 12;
  bool has_numeric_precision_radix() const;
  void clear_numeric_precision_radix() ;
  ::int32_t numeric_precision_radix() const;
  void set_numeric_precision_radix(::int32_t value);

  private:
  ::int32_t _internal_numeric_precision_radix() const;
  void _internal_set_numeric_precision_radix(::int32_t value);

  public:
  // optional int32 numeric_scale = 13;
  bool has_numeric_scale() const;
  void clear_numeric_scale() ;
  ::int32_t numeric_scale() const;
  void set_numeric_scale(::int32_t value);

  private:
  ::int32_t _internal_numeric_scale() const;
  void _internal_set_numeric_scale(::int32_t value);

  public:
  // optional int32 date_time_precision = 14;
  bool has_date_time_precision() const;
  void clear_date_time_precision() ;
  ::int32_t date_time_precision() const;
  void set_date_time_precision(::int32_t value);

  private:
  ::int32_t _internal_date_time_precision() const;
  void _internal_set_date_time_precision(::int32_t value);

  public:
  // optional int32 interval_precision = 16;
  bool has_interval_precision() const;
  void clear_interval_precision() ;
  ::int32_t interval_precision() const;
  void set_interval_precision(::int32_t value);

  private:
  ::int32_t _internal_interval_precision() const;
  void _internal_set_interval_precision(::int32_t value);

  public:
  // optional int32 column_size = 17;
  bool has_column_size() const;
  void clear_column_size() ;
  ::int32_t column_size() const;
  void set_column_size(::int32_t value);

  private:
  ::int32_t _internal_column_size() const;
  void _internal_set_column_size(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:exec.user.ColumnMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr catalog_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr column_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr default_value_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr interval_type_;
    ::int32_t ordinal_position_;
    bool is_nullable_;
    ::int32_t char_max_length_;
    ::int32_t char_octet_length_;
    ::int32_t numeric_precision_;
    ::int32_t numeric_precision_radix_;
    ::int32_t numeric_scale_;
    ::int32_t date_time_precision_;
    ::int32_t interval_precision_;
    ::int32_t column_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_User_2eproto;
};// -------------------------------------------------------------------

class GetColumnsResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.user.GetColumnsResp) */ {
 public:
  inline GetColumnsResp() : GetColumnsResp(nullptr) {}
  ~GetColumnsResp() override;
  explicit PROTOBUF_CONSTEXPR GetColumnsResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetColumnsResp(const GetColumnsResp& from);
  GetColumnsResp(GetColumnsResp&& from) noexcept
    : GetColumnsResp() {
    *this = ::std::move(from);
  }

  inline GetColumnsResp& operator=(const GetColumnsResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetColumnsResp& operator=(GetColumnsResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetColumnsResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetColumnsResp* internal_default_instance() {
    return reinterpret_cast<const GetColumnsResp*>(
               &_GetColumnsResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(GetColumnsResp& a, GetColumnsResp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetColumnsResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetColumnsResp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetColumnsResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetColumnsResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetColumnsResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetColumnsResp& from) {
    GetColumnsResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetColumnsResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.user.GetColumnsResp";
  }
  protected:
  explicit GetColumnsResp(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnsFieldNumber = 2,
    kErrorFieldNumber = 3,
    kStatusFieldNumber = 1,
  };
  // repeated .exec.user.ColumnMetadata columns = 2;
  int columns_size() const;
  private:
  int _internal_columns_size() const;

  public:
  void clear_columns() ;
  ::exec::user::ColumnMetadata* mutable_columns(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::user::ColumnMetadata >*
      mutable_columns();
  private:
  const ::exec::user::ColumnMetadata& _internal_columns(int index) const;
  ::exec::user::ColumnMetadata* _internal_add_columns();
  public:
  const ::exec::user::ColumnMetadata& columns(int index) const;
  ::exec::user::ColumnMetadata* add_columns();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::user::ColumnMetadata >&
      columns() const;
  // optional .exec.shared.DrillPBError error = 3;
  bool has_error() const;
  void clear_error() ;
  const ::exec::shared::DrillPBError& error() const;
  PROTOBUF_NODISCARD ::exec::shared::DrillPBError* release_error();
  ::exec::shared::DrillPBError* mutable_error();
  void set_allocated_error(::exec::shared::DrillPBError* error);
  private:
  const ::exec::shared::DrillPBError& _internal_error() const;
  ::exec::shared::DrillPBError* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::exec::shared::DrillPBError* error);
  ::exec::shared::DrillPBError* unsafe_arena_release_error();
  // optional .exec.user.RequestStatus status = 1;
  bool has_status() const;
  void clear_status() ;
  ::exec::user::RequestStatus status() const;
  void set_status(::exec::user::RequestStatus value);

  private:
  ::exec::user::RequestStatus _internal_status() const;
  void _internal_set_status(::exec::user::RequestStatus value);

  public:
  // @@protoc_insertion_point(class_scope:exec.user.GetColumnsResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::user::ColumnMetadata > columns_;
    ::exec::shared::DrillPBError* error_;
    int status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_User_2eproto;
};// -------------------------------------------------------------------

class CreatePreparedStatementReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.user.CreatePreparedStatementReq) */ {
 public:
  inline CreatePreparedStatementReq() : CreatePreparedStatementReq(nullptr) {}
  ~CreatePreparedStatementReq() override;
  explicit PROTOBUF_CONSTEXPR CreatePreparedStatementReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreatePreparedStatementReq(const CreatePreparedStatementReq& from);
  CreatePreparedStatementReq(CreatePreparedStatementReq&& from) noexcept
    : CreatePreparedStatementReq() {
    *this = ::std::move(from);
  }

  inline CreatePreparedStatementReq& operator=(const CreatePreparedStatementReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreatePreparedStatementReq& operator=(CreatePreparedStatementReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreatePreparedStatementReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreatePreparedStatementReq* internal_default_instance() {
    return reinterpret_cast<const CreatePreparedStatementReq*>(
               &_CreatePreparedStatementReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(CreatePreparedStatementReq& a, CreatePreparedStatementReq& b) {
    a.Swap(&b);
  }
  inline void Swap(CreatePreparedStatementReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreatePreparedStatementReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreatePreparedStatementReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreatePreparedStatementReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreatePreparedStatementReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreatePreparedStatementReq& from) {
    CreatePreparedStatementReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreatePreparedStatementReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.user.CreatePreparedStatementReq";
  }
  protected:
  explicit CreatePreparedStatementReq(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSqlQueryFieldNumber = 1,
  };
  // optional string sql_query = 1;
  bool has_sql_query() const;
  void clear_sql_query() ;
  const std::string& sql_query() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sql_query(Arg_&& arg, Args_... args);
  std::string* mutable_sql_query();
  PROTOBUF_NODISCARD std::string* release_sql_query();
  void set_allocated_sql_query(std::string* ptr);

  private:
  const std::string& _internal_sql_query() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sql_query(
      const std::string& value);
  std::string* _internal_mutable_sql_query();

  public:
  // @@protoc_insertion_point(class_scope:exec.user.CreatePreparedStatementReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sql_query_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_User_2eproto;
};// -------------------------------------------------------------------

class ResultColumnMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.user.ResultColumnMetadata) */ {
 public:
  inline ResultColumnMetadata() : ResultColumnMetadata(nullptr) {}
  ~ResultColumnMetadata() override;
  explicit PROTOBUF_CONSTEXPR ResultColumnMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResultColumnMetadata(const ResultColumnMetadata& from);
  ResultColumnMetadata(ResultColumnMetadata&& from) noexcept
    : ResultColumnMetadata() {
    *this = ::std::move(from);
  }

  inline ResultColumnMetadata& operator=(const ResultColumnMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResultColumnMetadata& operator=(ResultColumnMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResultColumnMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResultColumnMetadata* internal_default_instance() {
    return reinterpret_cast<const ResultColumnMetadata*>(
               &_ResultColumnMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(ResultColumnMetadata& a, ResultColumnMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(ResultColumnMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResultColumnMetadata* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResultColumnMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResultColumnMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResultColumnMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResultColumnMetadata& from) {
    ResultColumnMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResultColumnMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.user.ResultColumnMetadata";
  }
  protected:
  explicit ResultColumnMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCatalogNameFieldNumber = 1,
    kSchemaNameFieldNumber = 2,
    kTableNameFieldNumber = 3,
    kColumnNameFieldNumber = 4,
    kLabelFieldNumber = 5,
    kDataTypeFieldNumber = 6,
    kClassNameFieldNumber = 18,
    kPrecisionFieldNumber = 8,
    kScaleFieldNumber = 9,
    kDisplaySizeFieldNumber = 11,
    kIsNullableFieldNumber = 7,
    kSignedFieldNumber = 10,
    kIsAliasedFieldNumber = 12,
    kAutoIncrementFieldNumber = 15,
    kSearchabilityFieldNumber = 13,
    kUpdatabilityFieldNumber = 14,
    kCaseSensitivityFieldNumber = 16,
    kSortableFieldNumber = 17,
    kIsCurrencyFieldNumber = 20,
  };
  // optional string catalog_name = 1;
  bool has_catalog_name() const;
  void clear_catalog_name() ;
  const std::string& catalog_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_catalog_name(Arg_&& arg, Args_... args);
  std::string* mutable_catalog_name();
  PROTOBUF_NODISCARD std::string* release_catalog_name();
  void set_allocated_catalog_name(std::string* ptr);

  private:
  const std::string& _internal_catalog_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_catalog_name(
      const std::string& value);
  std::string* _internal_mutable_catalog_name();

  public:
  // optional string schema_name = 2;
  bool has_schema_name() const;
  void clear_schema_name() ;
  const std::string& schema_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_schema_name(Arg_&& arg, Args_... args);
  std::string* mutable_schema_name();
  PROTOBUF_NODISCARD std::string* release_schema_name();
  void set_allocated_schema_name(std::string* ptr);

  private:
  const std::string& _internal_schema_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_name(
      const std::string& value);
  std::string* _internal_mutable_schema_name();

  public:
  // optional string table_name = 3;
  bool has_table_name() const;
  void clear_table_name() ;
  const std::string& table_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_table_name(Arg_&& arg, Args_... args);
  std::string* mutable_table_name();
  PROTOBUF_NODISCARD std::string* release_table_name();
  void set_allocated_table_name(std::string* ptr);

  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(
      const std::string& value);
  std::string* _internal_mutable_table_name();

  public:
  // optional string column_name = 4;
  bool has_column_name() const;
  void clear_column_name() ;
  const std::string& column_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_column_name(Arg_&& arg, Args_... args);
  std::string* mutable_column_name();
  PROTOBUF_NODISCARD std::string* release_column_name();
  void set_allocated_column_name(std::string* ptr);

  private:
  const std::string& _internal_column_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_column_name(
      const std::string& value);
  std::string* _internal_mutable_column_name();

  public:
  // optional string label = 5;
  bool has_label() const;
  void clear_label() ;
  const std::string& label() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_label(Arg_&& arg, Args_... args);
  std::string* mutable_label();
  PROTOBUF_NODISCARD std::string* release_label();
  void set_allocated_label(std::string* ptr);

  private:
  const std::string& _internal_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_label(
      const std::string& value);
  std::string* _internal_mutable_label();

  public:
  // optional string data_type = 6;
  bool has_data_type() const;
  void clear_data_type() ;
  const std::string& data_type() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data_type(Arg_&& arg, Args_... args);
  std::string* mutable_data_type();
  PROTOBUF_NODISCARD std::string* release_data_type();
  void set_allocated_data_type(std::string* ptr);

  private:
  const std::string& _internal_data_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data_type(
      const std::string& value);
  std::string* _internal_mutable_data_type();

  public:
  // optional string class_name = 18;
  bool has_class_name() const;
  void clear_class_name() ;
  const std::string& class_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_class_name(Arg_&& arg, Args_... args);
  std::string* mutable_class_name();
  PROTOBUF_NODISCARD std::string* release_class_name();
  void set_allocated_class_name(std::string* ptr);

  private:
  const std::string& _internal_class_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_class_name(
      const std::string& value);
  std::string* _internal_mutable_class_name();

  public:
  // optional int32 precision = 8;
  bool has_precision() const;
  void clear_precision() ;
  ::int32_t precision() const;
  void set_precision(::int32_t value);

  private:
  ::int32_t _internal_precision() const;
  void _internal_set_precision(::int32_t value);

  public:
  // optional int32 scale = 9;
  bool has_scale() const;
  void clear_scale() ;
  ::int32_t scale() const;
  void set_scale(::int32_t value);

  private:
  ::int32_t _internal_scale() const;
  void _internal_set_scale(::int32_t value);

  public:
  // optional int32 display_size = 11;
  bool has_display_size() const;
  void clear_display_size() ;
  ::int32_t display_size() const;
  void set_display_size(::int32_t value);

  private:
  ::int32_t _internal_display_size() const;
  void _internal_set_display_size(::int32_t value);

  public:
  // optional bool is_nullable = 7;
  bool has_is_nullable() const;
  void clear_is_nullable() ;
  bool is_nullable() const;
  void set_is_nullable(bool value);

  private:
  bool _internal_is_nullable() const;
  void _internal_set_is_nullable(bool value);

  public:
  // optional bool signed = 10;
  bool has_signed_() const;
  void clear_signed_() ;
  bool signed_() const;
  void set_signed_(bool value);

  private:
  bool _internal_signed_() const;
  void _internal_set_signed_(bool value);

  public:
  // optional bool is_aliased = 12;
  bool has_is_aliased() const;
  void clear_is_aliased() ;
  bool is_aliased() const;
  void set_is_aliased(bool value);

  private:
  bool _internal_is_aliased() const;
  void _internal_set_is_aliased(bool value);

  public:
  // optional bool auto_increment = 15;
  bool has_auto_increment() const;
  void clear_auto_increment() ;
  bool auto_increment() const;
  void set_auto_increment(bool value);

  private:
  bool _internal_auto_increment() const;
  void _internal_set_auto_increment(bool value);

  public:
  // optional .exec.user.ColumnSearchability searchability = 13;
  bool has_searchability() const;
  void clear_searchability() ;
  ::exec::user::ColumnSearchability searchability() const;
  void set_searchability(::exec::user::ColumnSearchability value);

  private:
  ::exec::user::ColumnSearchability _internal_searchability() const;
  void _internal_set_searchability(::exec::user::ColumnSearchability value);

  public:
  // optional .exec.user.ColumnUpdatability updatability = 14;
  bool has_updatability() const;
  void clear_updatability() ;
  ::exec::user::ColumnUpdatability updatability() const;
  void set_updatability(::exec::user::ColumnUpdatability value);

  private:
  ::exec::user::ColumnUpdatability _internal_updatability() const;
  void _internal_set_updatability(::exec::user::ColumnUpdatability value);

  public:
  // optional bool case_sensitivity = 16;
  bool has_case_sensitivity() const;
  void clear_case_sensitivity() ;
  bool case_sensitivity() const;
  void set_case_sensitivity(bool value);

  private:
  bool _internal_case_sensitivity() const;
  void _internal_set_case_sensitivity(bool value);

  public:
  // optional bool sortable = 17;
  bool has_sortable() const;
  void clear_sortable() ;
  bool sortable() const;
  void set_sortable(bool value);

  private:
  bool _internal_sortable() const;
  void _internal_set_sortable(bool value);

  public:
  // optional bool is_currency = 20;
  bool has_is_currency() const;
  void clear_is_currency() ;
  bool is_currency() const;
  void set_is_currency(bool value);

  private:
  bool _internal_is_currency() const;
  void _internal_set_is_currency(bool value);

  public:
  // @@protoc_insertion_point(class_scope:exec.user.ResultColumnMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr catalog_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr column_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr class_name_;
    ::int32_t precision_;
    ::int32_t scale_;
    ::int32_t display_size_;
    bool is_nullable_;
    bool signed__;
    bool is_aliased_;
    bool auto_increment_;
    int searchability_;
    int updatability_;
    bool case_sensitivity_;
    bool sortable_;
    bool is_currency_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_User_2eproto;
};// -------------------------------------------------------------------

class PreparedStatementHandle final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.user.PreparedStatementHandle) */ {
 public:
  inline PreparedStatementHandle() : PreparedStatementHandle(nullptr) {}
  ~PreparedStatementHandle() override;
  explicit PROTOBUF_CONSTEXPR PreparedStatementHandle(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PreparedStatementHandle(const PreparedStatementHandle& from);
  PreparedStatementHandle(PreparedStatementHandle&& from) noexcept
    : PreparedStatementHandle() {
    *this = ::std::move(from);
  }

  inline PreparedStatementHandle& operator=(const PreparedStatementHandle& from) {
    CopyFrom(from);
    return *this;
  }
  inline PreparedStatementHandle& operator=(PreparedStatementHandle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PreparedStatementHandle& default_instance() {
    return *internal_default_instance();
  }
  static inline const PreparedStatementHandle* internal_default_instance() {
    return reinterpret_cast<const PreparedStatementHandle*>(
               &_PreparedStatementHandle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(PreparedStatementHandle& a, PreparedStatementHandle& b) {
    a.Swap(&b);
  }
  inline void Swap(PreparedStatementHandle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PreparedStatementHandle* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PreparedStatementHandle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PreparedStatementHandle>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PreparedStatementHandle& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PreparedStatementHandle& from) {
    PreparedStatementHandle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PreparedStatementHandle* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.user.PreparedStatementHandle";
  }
  protected:
  explicit PreparedStatementHandle(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerInfoFieldNumber = 1,
  };
  // optional bytes server_info = 1;
  bool has_server_info() const;
  void clear_server_info() ;
  const std::string& server_info() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_server_info(Arg_&& arg, Args_... args);
  std::string* mutable_server_info();
  PROTOBUF_NODISCARD std::string* release_server_info();
  void set_allocated_server_info(std::string* ptr);

  private:
  const std::string& _internal_server_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server_info(
      const std::string& value);
  std::string* _internal_mutable_server_info();

  public:
  // @@protoc_insertion_point(class_scope:exec.user.PreparedStatementHandle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr server_info_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_User_2eproto;
};// -------------------------------------------------------------------

class PreparedStatement final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.user.PreparedStatement) */ {
 public:
  inline PreparedStatement() : PreparedStatement(nullptr) {}
  ~PreparedStatement() override;
  explicit PROTOBUF_CONSTEXPR PreparedStatement(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PreparedStatement(const PreparedStatement& from);
  PreparedStatement(PreparedStatement&& from) noexcept
    : PreparedStatement() {
    *this = ::std::move(from);
  }

  inline PreparedStatement& operator=(const PreparedStatement& from) {
    CopyFrom(from);
    return *this;
  }
  inline PreparedStatement& operator=(PreparedStatement&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PreparedStatement& default_instance() {
    return *internal_default_instance();
  }
  static inline const PreparedStatement* internal_default_instance() {
    return reinterpret_cast<const PreparedStatement*>(
               &_PreparedStatement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(PreparedStatement& a, PreparedStatement& b) {
    a.Swap(&b);
  }
  inline void Swap(PreparedStatement* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PreparedStatement* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PreparedStatement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PreparedStatement>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PreparedStatement& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PreparedStatement& from) {
    PreparedStatement::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PreparedStatement* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.user.PreparedStatement";
  }
  protected:
  explicit PreparedStatement(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnsFieldNumber = 1,
    kServerHandleFieldNumber = 2,
  };
  // repeated .exec.user.ResultColumnMetadata columns = 1;
  int columns_size() const;
  private:
  int _internal_columns_size() const;

  public:
  void clear_columns() ;
  ::exec::user::ResultColumnMetadata* mutable_columns(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::user::ResultColumnMetadata >*
      mutable_columns();
  private:
  const ::exec::user::ResultColumnMetadata& _internal_columns(int index) const;
  ::exec::user::ResultColumnMetadata* _internal_add_columns();
  public:
  const ::exec::user::ResultColumnMetadata& columns(int index) const;
  ::exec::user::ResultColumnMetadata* add_columns();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::user::ResultColumnMetadata >&
      columns() const;
  // optional .exec.user.PreparedStatementHandle server_handle = 2;
  bool has_server_handle() const;
  void clear_server_handle() ;
  const ::exec::user::PreparedStatementHandle& server_handle() const;
  PROTOBUF_NODISCARD ::exec::user::PreparedStatementHandle* release_server_handle();
  ::exec::user::PreparedStatementHandle* mutable_server_handle();
  void set_allocated_server_handle(::exec::user::PreparedStatementHandle* server_handle);
  private:
  const ::exec::user::PreparedStatementHandle& _internal_server_handle() const;
  ::exec::user::PreparedStatementHandle* _internal_mutable_server_handle();
  public:
  void unsafe_arena_set_allocated_server_handle(
      ::exec::user::PreparedStatementHandle* server_handle);
  ::exec::user::PreparedStatementHandle* unsafe_arena_release_server_handle();
  // @@protoc_insertion_point(class_scope:exec.user.PreparedStatement)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::user::ResultColumnMetadata > columns_;
    ::exec::user::PreparedStatementHandle* server_handle_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_User_2eproto;
};// -------------------------------------------------------------------

class CreatePreparedStatementResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.user.CreatePreparedStatementResp) */ {
 public:
  inline CreatePreparedStatementResp() : CreatePreparedStatementResp(nullptr) {}
  ~CreatePreparedStatementResp() override;
  explicit PROTOBUF_CONSTEXPR CreatePreparedStatementResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreatePreparedStatementResp(const CreatePreparedStatementResp& from);
  CreatePreparedStatementResp(CreatePreparedStatementResp&& from) noexcept
    : CreatePreparedStatementResp() {
    *this = ::std::move(from);
  }

  inline CreatePreparedStatementResp& operator=(const CreatePreparedStatementResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreatePreparedStatementResp& operator=(CreatePreparedStatementResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreatePreparedStatementResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreatePreparedStatementResp* internal_default_instance() {
    return reinterpret_cast<const CreatePreparedStatementResp*>(
               &_CreatePreparedStatementResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(CreatePreparedStatementResp& a, CreatePreparedStatementResp& b) {
    a.Swap(&b);
  }
  inline void Swap(CreatePreparedStatementResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreatePreparedStatementResp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreatePreparedStatementResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreatePreparedStatementResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreatePreparedStatementResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreatePreparedStatementResp& from) {
    CreatePreparedStatementResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreatePreparedStatementResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.user.CreatePreparedStatementResp";
  }
  protected:
  explicit CreatePreparedStatementResp(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPreparedStatementFieldNumber = 2,
    kErrorFieldNumber = 3,
    kStatusFieldNumber = 1,
  };
  // optional .exec.user.PreparedStatement prepared_statement = 2;
  bool has_prepared_statement() const;
  void clear_prepared_statement() ;
  const ::exec::user::PreparedStatement& prepared_statement() const;
  PROTOBUF_NODISCARD ::exec::user::PreparedStatement* release_prepared_statement();
  ::exec::user::PreparedStatement* mutable_prepared_statement();
  void set_allocated_prepared_statement(::exec::user::PreparedStatement* prepared_statement);
  private:
  const ::exec::user::PreparedStatement& _internal_prepared_statement() const;
  ::exec::user::PreparedStatement* _internal_mutable_prepared_statement();
  public:
  void unsafe_arena_set_allocated_prepared_statement(
      ::exec::user::PreparedStatement* prepared_statement);
  ::exec::user::PreparedStatement* unsafe_arena_release_prepared_statement();
  // optional .exec.shared.DrillPBError error = 3;
  bool has_error() const;
  void clear_error() ;
  const ::exec::shared::DrillPBError& error() const;
  PROTOBUF_NODISCARD ::exec::shared::DrillPBError* release_error();
  ::exec::shared::DrillPBError* mutable_error();
  void set_allocated_error(::exec::shared::DrillPBError* error);
  private:
  const ::exec::shared::DrillPBError& _internal_error() const;
  ::exec::shared::DrillPBError* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::exec::shared::DrillPBError* error);
  ::exec::shared::DrillPBError* unsafe_arena_release_error();
  // optional .exec.user.RequestStatus status = 1;
  bool has_status() const;
  void clear_status() ;
  ::exec::user::RequestStatus status() const;
  void set_status(::exec::user::RequestStatus value);

  private:
  ::exec::user::RequestStatus _internal_status() const;
  void _internal_set_status(::exec::user::RequestStatus value);

  public:
  // @@protoc_insertion_point(class_scope:exec.user.CreatePreparedStatementResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::exec::user::PreparedStatement* prepared_statement_;
    ::exec::shared::DrillPBError* error_;
    int status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_User_2eproto;
};// -------------------------------------------------------------------

class GetServerMetaReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:exec.user.GetServerMetaReq) */ {
 public:
  inline GetServerMetaReq() : GetServerMetaReq(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetServerMetaReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetServerMetaReq(const GetServerMetaReq& from);
  GetServerMetaReq(GetServerMetaReq&& from) noexcept
    : GetServerMetaReq() {
    *this = ::std::move(from);
  }

  inline GetServerMetaReq& operator=(const GetServerMetaReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetServerMetaReq& operator=(GetServerMetaReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetServerMetaReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetServerMetaReq* internal_default_instance() {
    return reinterpret_cast<const GetServerMetaReq*>(
               &_GetServerMetaReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(GetServerMetaReq& a, GetServerMetaReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetServerMetaReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetServerMetaReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetServerMetaReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetServerMetaReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetServerMetaReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetServerMetaReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.user.GetServerMetaReq";
  }
  protected:
  explicit GetServerMetaReq(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:exec.user.GetServerMetaReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_User_2eproto;
};// -------------------------------------------------------------------

class ConvertSupport final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.user.ConvertSupport) */ {
 public:
  inline ConvertSupport() : ConvertSupport(nullptr) {}
  ~ConvertSupport() override;
  explicit PROTOBUF_CONSTEXPR ConvertSupport(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConvertSupport(const ConvertSupport& from);
  ConvertSupport(ConvertSupport&& from) noexcept
    : ConvertSupport() {
    *this = ::std::move(from);
  }

  inline ConvertSupport& operator=(const ConvertSupport& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConvertSupport& operator=(ConvertSupport&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConvertSupport& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConvertSupport* internal_default_instance() {
    return reinterpret_cast<const ConvertSupport*>(
               &_ConvertSupport_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(ConvertSupport& a, ConvertSupport& b) {
    a.Swap(&b);
  }
  inline void Swap(ConvertSupport* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConvertSupport* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConvertSupport* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConvertSupport>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConvertSupport& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConvertSupport& from) {
    ConvertSupport::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConvertSupport* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.user.ConvertSupport";
  }
  protected:
  explicit ConvertSupport(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromFieldNumber = 1,
    kToFieldNumber = 2,
  };
  // required .common.MinorType from = 1;
  bool has_from() const;
  void clear_from() ;
  ::common::MinorType from() const;
  void set_from(::common::MinorType value);

  private:
  ::common::MinorType _internal_from() const;
  void _internal_set_from(::common::MinorType value);

  public:
  // required .common.MinorType to = 2;
  bool has_to() const;
  void clear_to() ;
  ::common::MinorType to() const;
  void set_to(::common::MinorType value);

  private:
  ::common::MinorType _internal_to() const;
  void _internal_set_to(::common::MinorType value);

  public:
  // @@protoc_insertion_point(class_scope:exec.user.ConvertSupport)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  ::size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int from_;
    int to_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_User_2eproto;
};// -------------------------------------------------------------------

class GetServerMetaResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.user.GetServerMetaResp) */ {
 public:
  inline GetServerMetaResp() : GetServerMetaResp(nullptr) {}
  ~GetServerMetaResp() override;
  explicit PROTOBUF_CONSTEXPR GetServerMetaResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetServerMetaResp(const GetServerMetaResp& from);
  GetServerMetaResp(GetServerMetaResp&& from) noexcept
    : GetServerMetaResp() {
    *this = ::std::move(from);
  }

  inline GetServerMetaResp& operator=(const GetServerMetaResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetServerMetaResp& operator=(GetServerMetaResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetServerMetaResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetServerMetaResp* internal_default_instance() {
    return reinterpret_cast<const GetServerMetaResp*>(
               &_GetServerMetaResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(GetServerMetaResp& a, GetServerMetaResp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetServerMetaResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetServerMetaResp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetServerMetaResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetServerMetaResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetServerMetaResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetServerMetaResp& from) {
    GetServerMetaResp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetServerMetaResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.user.GetServerMetaResp";
  }
  protected:
  explicit GetServerMetaResp(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerMetaFieldNumber = 2,
    kErrorFieldNumber = 3,
    kStatusFieldNumber = 1,
  };
  // optional .exec.user.ServerMeta server_meta = 2;
  bool has_server_meta() const;
  void clear_server_meta() ;
  const ::exec::user::ServerMeta& server_meta() const;
  PROTOBUF_NODISCARD ::exec::user::ServerMeta* release_server_meta();
  ::exec::user::ServerMeta* mutable_server_meta();
  void set_allocated_server_meta(::exec::user::ServerMeta* server_meta);
  private:
  const ::exec::user::ServerMeta& _internal_server_meta() const;
  ::exec::user::ServerMeta* _internal_mutable_server_meta();
  public:
  void unsafe_arena_set_allocated_server_meta(
      ::exec::user::ServerMeta* server_meta);
  ::exec::user::ServerMeta* unsafe_arena_release_server_meta();
  // optional .exec.shared.DrillPBError error = 3;
  bool has_error() const;
  void clear_error() ;
  const ::exec::shared::DrillPBError& error() const;
  PROTOBUF_NODISCARD ::exec::shared::DrillPBError* release_error();
  ::exec::shared::DrillPBError* mutable_error();
  void set_allocated_error(::exec::shared::DrillPBError* error);
  private:
  const ::exec::shared::DrillPBError& _internal_error() const;
  ::exec::shared::DrillPBError* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::exec::shared::DrillPBError* error);
  ::exec::shared::DrillPBError* unsafe_arena_release_error();
  // optional .exec.user.RequestStatus status = 1;
  bool has_status() const;
  void clear_status() ;
  ::exec::user::RequestStatus status() const;
  void set_status(::exec::user::RequestStatus value);

  private:
  ::exec::user::RequestStatus _internal_status() const;
  void _internal_set_status(::exec::user::RequestStatus value);

  public:
  // @@protoc_insertion_point(class_scope:exec.user.GetServerMetaResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::exec::user::ServerMeta* server_meta_;
    ::exec::shared::DrillPBError* error_;
    int status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_User_2eproto;
};// -------------------------------------------------------------------

class ServerMeta final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.user.ServerMeta) */ {
 public:
  inline ServerMeta() : ServerMeta(nullptr) {}
  ~ServerMeta() override;
  explicit PROTOBUF_CONSTEXPR ServerMeta(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServerMeta(const ServerMeta& from);
  ServerMeta(ServerMeta&& from) noexcept
    : ServerMeta() {
    *this = ::std::move(from);
  }

  inline ServerMeta& operator=(const ServerMeta& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerMeta& operator=(ServerMeta&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerMeta& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServerMeta* internal_default_instance() {
    return reinterpret_cast<const ServerMeta*>(
               &_ServerMeta_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(ServerMeta& a, ServerMeta& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerMeta* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerMeta* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerMeta* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServerMeta>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServerMeta& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ServerMeta& from) {
    ServerMeta::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerMeta* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.user.ServerMeta";
  }
  protected:
  explicit ServerMeta(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCollateSupportFieldNumber = 6,
    kConvertSupportFieldNumber = 8,
    kDateTimeFunctionsFieldNumber = 10,
    kDateTimeLiteralsSupportFieldNumber = 11,
    kNumericFunctionsFieldNumber = 34,
    kOrderBySupportFieldNumber = 35,
    kOuterJoinSupportFieldNumber = 36,
    kSqlKeywordsFieldNumber = 43,
    kStringFunctionsFieldNumber = 44,
    kSubquerySupportFieldNumber = 45,
    kSystemFunctionsFieldNumber = 46,
    kUnionSupportFieldNumber = 49,
    kCatalogSeparatorFieldNumber = 4,
    kCatalogTermFieldNumber = 5,
    kIdentifierQuoteStringFieldNumber = 14,
    kSchemaTermFieldNumber = 39,
    kSearchEscapeStringFieldNumber = 40,
    kSpecialCharactersFieldNumber = 42,
    kTableTermFieldNumber = 47,
    kCurrentSchemaFieldNumber = 50,
    kAllTablesSelectableFieldNumber = 1,
    kBlobIncludedInMaxRowSizeFieldNumber = 2,
    kCatalogAtStartFieldNumber = 3,
    kColumnAliasingSupportedFieldNumber = 7,
    kIdentifierCasingFieldNumber = 13,
    kMaxBinaryLiteralLengthFieldNumber = 16,
    kMaxCatalogNameLengthFieldNumber = 17,
    kMaxCharLiteralLengthFieldNumber = 18,
    kMaxColumnNameLengthFieldNumber = 19,
    kMaxColumnsInGroupByFieldNumber = 20,
    kMaxColumnsInOrderByFieldNumber = 21,
    kMaxColumnsInSelectFieldNumber = 22,
    kMaxCursorNameLengthFieldNumber = 23,
    kMaxLogicalLobSizeFieldNumber = 24,
    kMaxRowSizeFieldNumber = 25,
    kMaxSchemaNameLengthFieldNumber = 26,
    kMaxStatementLengthFieldNumber = 27,
    kMaxStatementsFieldNumber = 28,
    kMaxTableNameLengthFieldNumber = 29,
    kMaxTablesInSelectFieldNumber = 30,
    kMaxUserNameLengthFieldNumber = 31,
    kLikeEscapeClauseSupportedFieldNumber = 15,
    kNullPlusNonNullEqualsNullFieldNumber = 33,
    kReadOnlyFieldNumber = 38,
    kSelectForUpdateSupportedFieldNumber = 41,
    kNullCollationFieldNumber = 32,
    kQuotedIdentifierCasingFieldNumber = 37,
    kTransactionSupportedFieldNumber = 48,
    kCorrelationNamesSupportFieldNumber = 9,
    kGroupBySupportFieldNumber = 12,
  };
  // repeated .exec.user.CollateSupport collate_support = 6;
  int collate_support_size() const;
  private:
  int _internal_collate_support_size() const;

  public:
  void clear_collate_support() ;
  public:
  ::exec::user::CollateSupport collate_support(int index) const;
  void set_collate_support(int index, ::exec::user::CollateSupport value);
  void add_collate_support(::exec::user::CollateSupport value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& collate_support() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_collate_support();

  private:
  ::exec::user::CollateSupport _internal_collate_support(int index) const;
  void _internal_add_collate_support(::exec::user::CollateSupport value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_collate_support();

  public:
  // repeated .exec.user.ConvertSupport convert_support = 8;
  int convert_support_size() const;
  private:
  int _internal_convert_support_size() const;

  public:
  void clear_convert_support() ;
  ::exec::user::ConvertSupport* mutable_convert_support(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::user::ConvertSupport >*
      mutable_convert_support();
  private:
  const ::exec::user::ConvertSupport& _internal_convert_support(int index) const;
  ::exec::user::ConvertSupport* _internal_add_convert_support();
  public:
  const ::exec::user::ConvertSupport& convert_support(int index) const;
  ::exec::user::ConvertSupport* add_convert_support();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::user::ConvertSupport >&
      convert_support() const;
  // repeated string date_time_functions = 10;
  int date_time_functions_size() const;
  private:
  int _internal_date_time_functions_size() const;

  public:
  void clear_date_time_functions() ;
  const std::string& date_time_functions(int index) const;
  std::string* mutable_date_time_functions(int index);
  void set_date_time_functions(int index, const std::string& value);
  void set_date_time_functions(int index, std::string&& value);
  void set_date_time_functions(int index, const char* value);
  void set_date_time_functions(int index, const char* value, std::size_t size);
  void set_date_time_functions(int index, absl::string_view value);
  std::string* add_date_time_functions();
  void add_date_time_functions(const std::string& value);
  void add_date_time_functions(std::string&& value);
  void add_date_time_functions(const char* value);
  void add_date_time_functions(const char* value, std::size_t size);
  void add_date_time_functions(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& date_time_functions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_date_time_functions();

  private:
  const std::string& _internal_date_time_functions(int index) const;
  std::string* _internal_add_date_time_functions();

  public:
  // repeated .exec.user.DateTimeLiteralsSupport date_time_literals_support = 11;
  int date_time_literals_support_size() const;
  private:
  int _internal_date_time_literals_support_size() const;

  public:
  void clear_date_time_literals_support() ;
  public:
  ::exec::user::DateTimeLiteralsSupport date_time_literals_support(int index) const;
  void set_date_time_literals_support(int index, ::exec::user::DateTimeLiteralsSupport value);
  void add_date_time_literals_support(::exec::user::DateTimeLiteralsSupport value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& date_time_literals_support() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_date_time_literals_support();

  private:
  ::exec::user::DateTimeLiteralsSupport _internal_date_time_literals_support(int index) const;
  void _internal_add_date_time_literals_support(::exec::user::DateTimeLiteralsSupport value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_date_time_literals_support();

  public:
  // repeated string numeric_functions = 34;
  int numeric_functions_size() const;
  private:
  int _internal_numeric_functions_size() const;

  public:
  void clear_numeric_functions() ;
  const std::string& numeric_functions(int index) const;
  std::string* mutable_numeric_functions(int index);
  void set_numeric_functions(int index, const std::string& value);
  void set_numeric_functions(int index, std::string&& value);
  void set_numeric_functions(int index, const char* value);
  void set_numeric_functions(int index, const char* value, std::size_t size);
  void set_numeric_functions(int index, absl::string_view value);
  std::string* add_numeric_functions();
  void add_numeric_functions(const std::string& value);
  void add_numeric_functions(std::string&& value);
  void add_numeric_functions(const char* value);
  void add_numeric_functions(const char* value, std::size_t size);
  void add_numeric_functions(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& numeric_functions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_numeric_functions();

  private:
  const std::string& _internal_numeric_functions(int index) const;
  std::string* _internal_add_numeric_functions();

  public:
  // repeated .exec.user.OrderBySupport order_by_support = 35;
  int order_by_support_size() const;
  private:
  int _internal_order_by_support_size() const;

  public:
  void clear_order_by_support() ;
  public:
  ::exec::user::OrderBySupport order_by_support(int index) const;
  void set_order_by_support(int index, ::exec::user::OrderBySupport value);
  void add_order_by_support(::exec::user::OrderBySupport value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& order_by_support() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_order_by_support();

  private:
  ::exec::user::OrderBySupport _internal_order_by_support(int index) const;
  void _internal_add_order_by_support(::exec::user::OrderBySupport value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_order_by_support();

  public:
  // repeated .exec.user.OuterJoinSupport outer_join_support = 36;
  int outer_join_support_size() const;
  private:
  int _internal_outer_join_support_size() const;

  public:
  void clear_outer_join_support() ;
  public:
  ::exec::user::OuterJoinSupport outer_join_support(int index) const;
  void set_outer_join_support(int index, ::exec::user::OuterJoinSupport value);
  void add_outer_join_support(::exec::user::OuterJoinSupport value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& outer_join_support() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_outer_join_support();

  private:
  ::exec::user::OuterJoinSupport _internal_outer_join_support(int index) const;
  void _internal_add_outer_join_support(::exec::user::OuterJoinSupport value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_outer_join_support();

  public:
  // repeated string sql_keywords = 43;
  int sql_keywords_size() const;
  private:
  int _internal_sql_keywords_size() const;

  public:
  void clear_sql_keywords() ;
  const std::string& sql_keywords(int index) const;
  std::string* mutable_sql_keywords(int index);
  void set_sql_keywords(int index, const std::string& value);
  void set_sql_keywords(int index, std::string&& value);
  void set_sql_keywords(int index, const char* value);
  void set_sql_keywords(int index, const char* value, std::size_t size);
  void set_sql_keywords(int index, absl::string_view value);
  std::string* add_sql_keywords();
  void add_sql_keywords(const std::string& value);
  void add_sql_keywords(std::string&& value);
  void add_sql_keywords(const char* value);
  void add_sql_keywords(const char* value, std::size_t size);
  void add_sql_keywords(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& sql_keywords() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_sql_keywords();

  private:
  const std::string& _internal_sql_keywords(int index) const;
  std::string* _internal_add_sql_keywords();

  public:
  // repeated string string_functions = 44;
  int string_functions_size() const;
  private:
  int _internal_string_functions_size() const;

  public:
  void clear_string_functions() ;
  const std::string& string_functions(int index) const;
  std::string* mutable_string_functions(int index);
  void set_string_functions(int index, const std::string& value);
  void set_string_functions(int index, std::string&& value);
  void set_string_functions(int index, const char* value);
  void set_string_functions(int index, const char* value, std::size_t size);
  void set_string_functions(int index, absl::string_view value);
  std::string* add_string_functions();
  void add_string_functions(const std::string& value);
  void add_string_functions(std::string&& value);
  void add_string_functions(const char* value);
  void add_string_functions(const char* value, std::size_t size);
  void add_string_functions(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& string_functions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_string_functions();

  private:
  const std::string& _internal_string_functions(int index) const;
  std::string* _internal_add_string_functions();

  public:
  // repeated .exec.user.SubQuerySupport subquery_support = 45;
  int subquery_support_size() const;
  private:
  int _internal_subquery_support_size() const;

  public:
  void clear_subquery_support() ;
  public:
  ::exec::user::SubQuerySupport subquery_support(int index) const;
  void set_subquery_support(int index, ::exec::user::SubQuerySupport value);
  void add_subquery_support(::exec::user::SubQuerySupport value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& subquery_support() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_subquery_support();

  private:
  ::exec::user::SubQuerySupport _internal_subquery_support(int index) const;
  void _internal_add_subquery_support(::exec::user::SubQuerySupport value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_subquery_support();

  public:
  // repeated string system_functions = 46;
  int system_functions_size() const;
  private:
  int _internal_system_functions_size() const;

  public:
  void clear_system_functions() ;
  const std::string& system_functions(int index) const;
  std::string* mutable_system_functions(int index);
  void set_system_functions(int index, const std::string& value);
  void set_system_functions(int index, std::string&& value);
  void set_system_functions(int index, const char* value);
  void set_system_functions(int index, const char* value, std::size_t size);
  void set_system_functions(int index, absl::string_view value);
  std::string* add_system_functions();
  void add_system_functions(const std::string& value);
  void add_system_functions(std::string&& value);
  void add_system_functions(const char* value);
  void add_system_functions(const char* value, std::size_t size);
  void add_system_functions(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& system_functions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_system_functions();

  private:
  const std::string& _internal_system_functions(int index) const;
  std::string* _internal_add_system_functions();

  public:
  // repeated .exec.user.UnionSupport union_support = 49;
  int union_support_size() const;
  private:
  int _internal_union_support_size() const;

  public:
  void clear_union_support() ;
  public:
  ::exec::user::UnionSupport union_support(int index) const;
  void set_union_support(int index, ::exec::user::UnionSupport value);
  void add_union_support(::exec::user::UnionSupport value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& union_support() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_union_support();

  private:
  ::exec::user::UnionSupport _internal_union_support(int index) const;
  void _internal_add_union_support(::exec::user::UnionSupport value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_union_support();

  public:
  // optional string catalog_separator = 4;
  bool has_catalog_separator() const;
  void clear_catalog_separator() ;
  const std::string& catalog_separator() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_catalog_separator(Arg_&& arg, Args_... args);
  std::string* mutable_catalog_separator();
  PROTOBUF_NODISCARD std::string* release_catalog_separator();
  void set_allocated_catalog_separator(std::string* ptr);

  private:
  const std::string& _internal_catalog_separator() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_catalog_separator(
      const std::string& value);
  std::string* _internal_mutable_catalog_separator();

  public:
  // optional string catalog_term = 5;
  bool has_catalog_term() const;
  void clear_catalog_term() ;
  const std::string& catalog_term() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_catalog_term(Arg_&& arg, Args_... args);
  std::string* mutable_catalog_term();
  PROTOBUF_NODISCARD std::string* release_catalog_term();
  void set_allocated_catalog_term(std::string* ptr);

  private:
  const std::string& _internal_catalog_term() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_catalog_term(
      const std::string& value);
  std::string* _internal_mutable_catalog_term();

  public:
  // optional string identifier_quote_string = 14;
  bool has_identifier_quote_string() const;
  void clear_identifier_quote_string() ;
  const std::string& identifier_quote_string() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_identifier_quote_string(Arg_&& arg, Args_... args);
  std::string* mutable_identifier_quote_string();
  PROTOBUF_NODISCARD std::string* release_identifier_quote_string();
  void set_allocated_identifier_quote_string(std::string* ptr);

  private:
  const std::string& _internal_identifier_quote_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_identifier_quote_string(
      const std::string& value);
  std::string* _internal_mutable_identifier_quote_string();

  public:
  // optional string schema_term = 39;
  bool has_schema_term() const;
  void clear_schema_term() ;
  const std::string& schema_term() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_schema_term(Arg_&& arg, Args_... args);
  std::string* mutable_schema_term();
  PROTOBUF_NODISCARD std::string* release_schema_term();
  void set_allocated_schema_term(std::string* ptr);

  private:
  const std::string& _internal_schema_term() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_term(
      const std::string& value);
  std::string* _internal_mutable_schema_term();

  public:
  // optional string search_escape_string = 40;
  bool has_search_escape_string() const;
  void clear_search_escape_string() ;
  const std::string& search_escape_string() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_search_escape_string(Arg_&& arg, Args_... args);
  std::string* mutable_search_escape_string();
  PROTOBUF_NODISCARD std::string* release_search_escape_string();
  void set_allocated_search_escape_string(std::string* ptr);

  private:
  const std::string& _internal_search_escape_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_search_escape_string(
      const std::string& value);
  std::string* _internal_mutable_search_escape_string();

  public:
  // optional string special_characters = 42;
  bool has_special_characters() const;
  void clear_special_characters() ;
  const std::string& special_characters() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_special_characters(Arg_&& arg, Args_... args);
  std::string* mutable_special_characters();
  PROTOBUF_NODISCARD std::string* release_special_characters();
  void set_allocated_special_characters(std::string* ptr);

  private:
  const std::string& _internal_special_characters() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_special_characters(
      const std::string& value);
  std::string* _internal_mutable_special_characters();

  public:
  // optional string table_term = 47;
  bool has_table_term() const;
  void clear_table_term() ;
  const std::string& table_term() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_table_term(Arg_&& arg, Args_... args);
  std::string* mutable_table_term();
  PROTOBUF_NODISCARD std::string* release_table_term();
  void set_allocated_table_term(std::string* ptr);

  private:
  const std::string& _internal_table_term() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_term(
      const std::string& value);
  std::string* _internal_mutable_table_term();

  public:
  // optional string current_schema = 50;
  bool has_current_schema() const;
  void clear_current_schema() ;
  const std::string& current_schema() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_current_schema(Arg_&& arg, Args_... args);
  std::string* mutable_current_schema();
  PROTOBUF_NODISCARD std::string* release_current_schema();
  void set_allocated_current_schema(std::string* ptr);

  private:
  const std::string& _internal_current_schema() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_current_schema(
      const std::string& value);
  std::string* _internal_mutable_current_schema();

  public:
  // optional bool all_tables_selectable = 1;
  bool has_all_tables_selectable() const;
  void clear_all_tables_selectable() ;
  bool all_tables_selectable() const;
  void set_all_tables_selectable(bool value);

  private:
  bool _internal_all_tables_selectable() const;
  void _internal_set_all_tables_selectable(bool value);

  public:
  // optional bool blob_included_in_max_row_size = 2;
  bool has_blob_included_in_max_row_size() const;
  void clear_blob_included_in_max_row_size() ;
  bool blob_included_in_max_row_size() const;
  void set_blob_included_in_max_row_size(bool value);

  private:
  bool _internal_blob_included_in_max_row_size() const;
  void _internal_set_blob_included_in_max_row_size(bool value);

  public:
  // optional bool catalog_at_start = 3;
  bool has_catalog_at_start() const;
  void clear_catalog_at_start() ;
  bool catalog_at_start() const;
  void set_catalog_at_start(bool value);

  private:
  bool _internal_catalog_at_start() const;
  void _internal_set_catalog_at_start(bool value);

  public:
  // optional bool column_aliasing_supported = 7;
  bool has_column_aliasing_supported() const;
  void clear_column_aliasing_supported() ;
  bool column_aliasing_supported() const;
  void set_column_aliasing_supported(bool value);

  private:
  bool _internal_column_aliasing_supported() const;
  void _internal_set_column_aliasing_supported(bool value);

  public:
  // optional .exec.user.IdentifierCasing identifier_casing = 13;
  bool has_identifier_casing() const;
  void clear_identifier_casing() ;
  ::exec::user::IdentifierCasing identifier_casing() const;
  void set_identifier_casing(::exec::user::IdentifierCasing value);

  private:
  ::exec::user::IdentifierCasing _internal_identifier_casing() const;
  void _internal_set_identifier_casing(::exec::user::IdentifierCasing value);

  public:
  // optional uint32 max_binary_literal_length = 16;
  bool has_max_binary_literal_length() const;
  void clear_max_binary_literal_length() ;
  ::uint32_t max_binary_literal_length() const;
  void set_max_binary_literal_length(::uint32_t value);

  private:
  ::uint32_t _internal_max_binary_literal_length() const;
  void _internal_set_max_binary_literal_length(::uint32_t value);

  public:
  // optional uint32 max_catalog_name_length = 17;
  bool has_max_catalog_name_length() const;
  void clear_max_catalog_name_length() ;
  ::uint32_t max_catalog_name_length() const;
  void set_max_catalog_name_length(::uint32_t value);

  private:
  ::uint32_t _internal_max_catalog_name_length() const;
  void _internal_set_max_catalog_name_length(::uint32_t value);

  public:
  // optional uint32 max_char_literal_length = 18;
  bool has_max_char_literal_length() const;
  void clear_max_char_literal_length() ;
  ::uint32_t max_char_literal_length() const;
  void set_max_char_literal_length(::uint32_t value);

  private:
  ::uint32_t _internal_max_char_literal_length() const;
  void _internal_set_max_char_literal_length(::uint32_t value);

  public:
  // optional uint32 max_column_name_length = 19;
  bool has_max_column_name_length() const;
  void clear_max_column_name_length() ;
  ::uint32_t max_column_name_length() const;
  void set_max_column_name_length(::uint32_t value);

  private:
  ::uint32_t _internal_max_column_name_length() const;
  void _internal_set_max_column_name_length(::uint32_t value);

  public:
  // optional uint32 max_columns_in_group_by = 20;
  bool has_max_columns_in_group_by() const;
  void clear_max_columns_in_group_by() ;
  ::uint32_t max_columns_in_group_by() const;
  void set_max_columns_in_group_by(::uint32_t value);

  private:
  ::uint32_t _internal_max_columns_in_group_by() const;
  void _internal_set_max_columns_in_group_by(::uint32_t value);

  public:
  // optional uint32 max_columns_in_order_by = 21;
  bool has_max_columns_in_order_by() const;
  void clear_max_columns_in_order_by() ;
  ::uint32_t max_columns_in_order_by() const;
  void set_max_columns_in_order_by(::uint32_t value);

  private:
  ::uint32_t _internal_max_columns_in_order_by() const;
  void _internal_set_max_columns_in_order_by(::uint32_t value);

  public:
  // optional uint32 max_columns_in_select = 22;
  bool has_max_columns_in_select() const;
  void clear_max_columns_in_select() ;
  ::uint32_t max_columns_in_select() const;
  void set_max_columns_in_select(::uint32_t value);

  private:
  ::uint32_t _internal_max_columns_in_select() const;
  void _internal_set_max_columns_in_select(::uint32_t value);

  public:
  // optional uint32 max_cursor_name_length = 23;
  bool has_max_cursor_name_length() const;
  void clear_max_cursor_name_length() ;
  ::uint32_t max_cursor_name_length() const;
  void set_max_cursor_name_length(::uint32_t value);

  private:
  ::uint32_t _internal_max_cursor_name_length() const;
  void _internal_set_max_cursor_name_length(::uint32_t value);

  public:
  // optional uint32 max_logical_lob_size = 24;
  bool has_max_logical_lob_size() const;
  void clear_max_logical_lob_size() ;
  ::uint32_t max_logical_lob_size() const;
  void set_max_logical_lob_size(::uint32_t value);

  private:
  ::uint32_t _internal_max_logical_lob_size() const;
  void _internal_set_max_logical_lob_size(::uint32_t value);

  public:
  // optional uint32 max_row_size = 25;
  bool has_max_row_size() const;
  void clear_max_row_size() ;
  ::uint32_t max_row_size() const;
  void set_max_row_size(::uint32_t value);

  private:
  ::uint32_t _internal_max_row_size() const;
  void _internal_set_max_row_size(::uint32_t value);

  public:
  // optional uint32 max_schema_name_length = 26;
  bool has_max_schema_name_length() const;
  void clear_max_schema_name_length() ;
  ::uint32_t max_schema_name_length() const;
  void set_max_schema_name_length(::uint32_t value);

  private:
  ::uint32_t _internal_max_schema_name_length() const;
  void _internal_set_max_schema_name_length(::uint32_t value);

  public:
  // optional uint32 max_statement_length = 27;
  bool has_max_statement_length() const;
  void clear_max_statement_length() ;
  ::uint32_t max_statement_length() const;
  void set_max_statement_length(::uint32_t value);

  private:
  ::uint32_t _internal_max_statement_length() const;
  void _internal_set_max_statement_length(::uint32_t value);

  public:
  // optional uint32 max_statements = 28;
  bool has_max_statements() const;
  void clear_max_statements() ;
  ::uint32_t max_statements() const;
  void set_max_statements(::uint32_t value);

  private:
  ::uint32_t _internal_max_statements() const;
  void _internal_set_max_statements(::uint32_t value);

  public:
  // optional uint32 max_table_name_length = 29;
  bool has_max_table_name_length() const;
  void clear_max_table_name_length() ;
  ::uint32_t max_table_name_length() const;
  void set_max_table_name_length(::uint32_t value);

  private:
  ::uint32_t _internal_max_table_name_length() const;
  void _internal_set_max_table_name_length(::uint32_t value);

  public:
  // optional uint32 max_tables_in_select = 30;
  bool has_max_tables_in_select() const;
  void clear_max_tables_in_select() ;
  ::uint32_t max_tables_in_select() const;
  void set_max_tables_in_select(::uint32_t value);

  private:
  ::uint32_t _internal_max_tables_in_select() const;
  void _internal_set_max_tables_in_select(::uint32_t value);

  public:
  // optional uint32 max_user_name_length = 31;
  bool has_max_user_name_length() const;
  void clear_max_user_name_length() ;
  ::uint32_t max_user_name_length() const;
  void set_max_user_name_length(::uint32_t value);

  private:
  ::uint32_t _internal_max_user_name_length() const;
  void _internal_set_max_user_name_length(::uint32_t value);

  public:
  // optional bool like_escape_clause_supported = 15;
  bool has_like_escape_clause_supported() const;
  void clear_like_escape_clause_supported() ;
  bool like_escape_clause_supported() const;
  void set_like_escape_clause_supported(bool value);

  private:
  bool _internal_like_escape_clause_supported() const;
  void _internal_set_like_escape_clause_supported(bool value);

  public:
  // optional bool null_plus_non_null_equals_null = 33;
  bool has_null_plus_non_null_equals_null() const;
  void clear_null_plus_non_null_equals_null() ;
  bool null_plus_non_null_equals_null() const;
  void set_null_plus_non_null_equals_null(bool value);

  private:
  bool _internal_null_plus_non_null_equals_null() const;
  void _internal_set_null_plus_non_null_equals_null(bool value);

  public:
  // optional bool read_only = 38;
  bool has_read_only() const;
  void clear_read_only() ;
  bool read_only() const;
  void set_read_only(bool value);

  private:
  bool _internal_read_only() const;
  void _internal_set_read_only(bool value);

  public:
  // optional bool select_for_update_supported = 41;
  bool has_select_for_update_supported() const;
  void clear_select_for_update_supported() ;
  bool select_for_update_supported() const;
  void set_select_for_update_supported(bool value);

  private:
  bool _internal_select_for_update_supported() const;
  void _internal_set_select_for_update_supported(bool value);

  public:
  // optional .exec.user.NullCollation null_collation = 32;
  bool has_null_collation() const;
  void clear_null_collation() ;
  ::exec::user::NullCollation null_collation() const;
  void set_null_collation(::exec::user::NullCollation value);

  private:
  ::exec::user::NullCollation _internal_null_collation() const;
  void _internal_set_null_collation(::exec::user::NullCollation value);

  public:
  // optional .exec.user.IdentifierCasing quoted_identifier_casing = 37;
  bool has_quoted_identifier_casing() const;
  void clear_quoted_identifier_casing() ;
  ::exec::user::IdentifierCasing quoted_identifier_casing() const;
  void set_quoted_identifier_casing(::exec::user::IdentifierCasing value);

  private:
  ::exec::user::IdentifierCasing _internal_quoted_identifier_casing() const;
  void _internal_set_quoted_identifier_casing(::exec::user::IdentifierCasing value);

  public:
  // optional bool transaction_supported = 48;
  bool has_transaction_supported() const;
  void clear_transaction_supported() ;
  bool transaction_supported() const;
  void set_transaction_supported(bool value);

  private:
  bool _internal_transaction_supported() const;
  void _internal_set_transaction_supported(bool value);

  public:
  // optional .exec.user.CorrelationNamesSupport correlation_names_support = 9;
  bool has_correlation_names_support() const;
  void clear_correlation_names_support() ;
  ::exec::user::CorrelationNamesSupport correlation_names_support() const;
  void set_correlation_names_support(::exec::user::CorrelationNamesSupport value);

  private:
  ::exec::user::CorrelationNamesSupport _internal_correlation_names_support() const;
  void _internal_set_correlation_names_support(::exec::user::CorrelationNamesSupport value);

  public:
  // optional .exec.user.GroupBySupport group_by_support = 12;
  bool has_group_by_support() const;
  void clear_group_by_support() ;
  ::exec::user::GroupBySupport group_by_support() const;
  void set_group_by_support(::exec::user::GroupBySupport value);

  private:
  ::exec::user::GroupBySupport _internal_group_by_support() const;
  void _internal_set_group_by_support(::exec::user::GroupBySupport value);

  public:
  // @@protoc_insertion_point(class_scope:exec.user.ServerMeta)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<2> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> collate_support_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::user::ConvertSupport > convert_support_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> date_time_functions_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> date_time_literals_support_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> numeric_functions_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> order_by_support_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> outer_join_support_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> sql_keywords_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> string_functions_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> subquery_support_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> system_functions_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> union_support_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr catalog_separator_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr catalog_term_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identifier_quote_string_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_term_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr search_escape_string_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr special_characters_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_term_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr current_schema_;
    bool all_tables_selectable_;
    bool blob_included_in_max_row_size_;
    bool catalog_at_start_;
    bool column_aliasing_supported_;
    int identifier_casing_;
    ::uint32_t max_binary_literal_length_;
    ::uint32_t max_catalog_name_length_;
    ::uint32_t max_char_literal_length_;
    ::uint32_t max_column_name_length_;
    ::uint32_t max_columns_in_group_by_;
    ::uint32_t max_columns_in_order_by_;
    ::uint32_t max_columns_in_select_;
    ::uint32_t max_cursor_name_length_;
    ::uint32_t max_logical_lob_size_;
    ::uint32_t max_row_size_;
    ::uint32_t max_schema_name_length_;
    ::uint32_t max_statement_length_;
    ::uint32_t max_statements_;
    ::uint32_t max_table_name_length_;
    ::uint32_t max_tables_in_select_;
    ::uint32_t max_user_name_length_;
    bool like_escape_clause_supported_;
    bool null_plus_non_null_equals_null_;
    bool read_only_;
    bool select_for_update_supported_;
    int null_collation_;
    int quoted_identifier_casing_;
    bool transaction_supported_;
    int correlation_names_support_;
    int group_by_support_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_User_2eproto;
};// -------------------------------------------------------------------

class RunQuery final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.user.RunQuery) */ {
 public:
  inline RunQuery() : RunQuery(nullptr) {}
  ~RunQuery() override;
  explicit PROTOBUF_CONSTEXPR RunQuery(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RunQuery(const RunQuery& from);
  RunQuery(RunQuery&& from) noexcept
    : RunQuery() {
    *this = ::std::move(from);
  }

  inline RunQuery& operator=(const RunQuery& from) {
    CopyFrom(from);
    return *this;
  }
  inline RunQuery& operator=(RunQuery&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RunQuery& default_instance() {
    return *internal_default_instance();
  }
  static inline const RunQuery* internal_default_instance() {
    return reinterpret_cast<const RunQuery*>(
               &_RunQuery_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(RunQuery& a, RunQuery& b) {
    a.Swap(&b);
  }
  inline void Swap(RunQuery* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RunQuery* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RunQuery* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RunQuery>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RunQuery& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RunQuery& from) {
    RunQuery::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RunQuery* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.user.RunQuery";
  }
  protected:
  explicit RunQuery(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFragmentsFieldNumber = 4,
    kPlanFieldNumber = 3,
    kPreparedStatementHandleFieldNumber = 5,
    kAutolimitRowcountFieldNumber = 6,
    kResultsModeFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // repeated .exec.bit.control.PlanFragment fragments = 4;
  int fragments_size() const;
  private:
  int _internal_fragments_size() const;

  public:
  void clear_fragments() ;
  ::exec::bit::control::PlanFragment* mutable_fragments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::bit::control::PlanFragment >*
      mutable_fragments();
  private:
  const ::exec::bit::control::PlanFragment& _internal_fragments(int index) const;
  ::exec::bit::control::PlanFragment* _internal_add_fragments();
  public:
  const ::exec::bit::control::PlanFragment& fragments(int index) const;
  ::exec::bit::control::PlanFragment* add_fragments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::bit::control::PlanFragment >&
      fragments() const;
  // optional string plan = 3;
  bool has_plan() const;
  void clear_plan() ;
  const std::string& plan() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_plan(Arg_&& arg, Args_... args);
  std::string* mutable_plan();
  PROTOBUF_NODISCARD std::string* release_plan();
  void set_allocated_plan(std::string* ptr);

  private:
  const std::string& _internal_plan() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_plan(
      const std::string& value);
  std::string* _internal_mutable_plan();

  public:
  // optional .exec.user.PreparedStatementHandle prepared_statement_handle = 5;
  bool has_prepared_statement_handle() const;
  void clear_prepared_statement_handle() ;
  const ::exec::user::PreparedStatementHandle& prepared_statement_handle() const;
  PROTOBUF_NODISCARD ::exec::user::PreparedStatementHandle* release_prepared_statement_handle();
  ::exec::user::PreparedStatementHandle* mutable_prepared_statement_handle();
  void set_allocated_prepared_statement_handle(::exec::user::PreparedStatementHandle* prepared_statement_handle);
  private:
  const ::exec::user::PreparedStatementHandle& _internal_prepared_statement_handle() const;
  ::exec::user::PreparedStatementHandle* _internal_mutable_prepared_statement_handle();
  public:
  void unsafe_arena_set_allocated_prepared_statement_handle(
      ::exec::user::PreparedStatementHandle* prepared_statement_handle);
  ::exec::user::PreparedStatementHandle* unsafe_arena_release_prepared_statement_handle();
  // optional int32 autolimit_rowcount = 6;
  bool has_autolimit_rowcount() const;
  void clear_autolimit_rowcount() ;
  ::int32_t autolimit_rowcount() const;
  void set_autolimit_rowcount(::int32_t value);

  private:
  ::int32_t _internal_autolimit_rowcount() const;
  void _internal_set_autolimit_rowcount(::int32_t value);

  public:
  // optional .exec.user.QueryResultsMode results_mode = 1;
  bool has_results_mode() const;
  void clear_results_mode() ;
  ::exec::user::QueryResultsMode results_mode() const;
  void set_results_mode(::exec::user::QueryResultsMode value);

  private:
  ::exec::user::QueryResultsMode _internal_results_mode() const;
  void _internal_set_results_mode(::exec::user::QueryResultsMode value);

  public:
  // optional .exec.shared.QueryType type = 2;
  bool has_type() const;
  void clear_type() ;
  ::exec::shared::QueryType type() const;
  void set_type(::exec::shared::QueryType value);

  private:
  ::exec::shared::QueryType _internal_type() const;
  void _internal_set_type(::exec::shared::QueryType value);

  public:
  // @@protoc_insertion_point(class_scope:exec.user.RunQuery)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::bit::control::PlanFragment > fragments_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr plan_;
    ::exec::user::PreparedStatementHandle* prepared_statement_handle_;
    ::int32_t autolimit_rowcount_;
    int results_mode_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_User_2eproto;
};// -------------------------------------------------------------------

class NewSessionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.user.NewSessionRequest) */ {
 public:
  inline NewSessionRequest() : NewSessionRequest(nullptr) {}
  ~NewSessionRequest() override;
  explicit PROTOBUF_CONSTEXPR NewSessionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NewSessionRequest(const NewSessionRequest& from);
  NewSessionRequest(NewSessionRequest&& from) noexcept
    : NewSessionRequest() {
    *this = ::std::move(from);
  }

  inline NewSessionRequest& operator=(const NewSessionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewSessionRequest& operator=(NewSessionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NewSessionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NewSessionRequest* internal_default_instance() {
    return reinterpret_cast<const NewSessionRequest*>(
               &_NewSessionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(NewSessionRequest& a, NewSessionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NewSessionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewSessionRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NewSessionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NewSessionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NewSessionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NewSessionRequest& from) {
    NewSessionRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewSessionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.user.NewSessionRequest";
  }
  protected:
  explicit NewSessionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPropertiesFieldNumber = 1,
  };
  // optional .exec.user.UserProperties properties = 1;
  bool has_properties() const;
  void clear_properties() ;
  const ::exec::user::UserProperties& properties() const;
  PROTOBUF_NODISCARD ::exec::user::UserProperties* release_properties();
  ::exec::user::UserProperties* mutable_properties();
  void set_allocated_properties(::exec::user::UserProperties* properties);
  private:
  const ::exec::user::UserProperties& _internal_properties() const;
  ::exec::user::UserProperties* _internal_mutable_properties();
  public:
  void unsafe_arena_set_allocated_properties(
      ::exec::user::UserProperties* properties);
  ::exec::user::UserProperties* unsafe_arena_release_properties();
  // @@protoc_insertion_point(class_scope:exec.user.NewSessionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::exec::user::UserProperties* properties_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_User_2eproto;
};// -------------------------------------------------------------------

class SessionHandle final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.user.SessionHandle) */ {
 public:
  inline SessionHandle() : SessionHandle(nullptr) {}
  ~SessionHandle() override;
  explicit PROTOBUF_CONSTEXPR SessionHandle(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SessionHandle(const SessionHandle& from);
  SessionHandle(SessionHandle&& from) noexcept
    : SessionHandle() {
    *this = ::std::move(from);
  }

  inline SessionHandle& operator=(const SessionHandle& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionHandle& operator=(SessionHandle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SessionHandle& default_instance() {
    return *internal_default_instance();
  }
  static inline const SessionHandle* internal_default_instance() {
    return reinterpret_cast<const SessionHandle*>(
               &_SessionHandle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(SessionHandle& a, SessionHandle& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionHandle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionHandle* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SessionHandle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SessionHandle>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SessionHandle& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SessionHandle& from) {
    SessionHandle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SessionHandle* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.user.SessionHandle";
  }
  protected:
  explicit SessionHandle(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
  };
  // optional string session_id = 1;
  bool has_session_id() const;
  void clear_session_id() ;
  const std::string& session_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_session_id(Arg_&& arg, Args_... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* ptr);

  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(
      const std::string& value);
  std::string* _internal_mutable_session_id();

  public:
  // @@protoc_insertion_point(class_scope:exec.user.SessionHandle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_User_2eproto;
};// -------------------------------------------------------------------

class RunQueryWithSessionHandle final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.user.RunQueryWithSessionHandle) */ {
 public:
  inline RunQueryWithSessionHandle() : RunQueryWithSessionHandle(nullptr) {}
  ~RunQueryWithSessionHandle() override;
  explicit PROTOBUF_CONSTEXPR RunQueryWithSessionHandle(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RunQueryWithSessionHandle(const RunQueryWithSessionHandle& from);
  RunQueryWithSessionHandle(RunQueryWithSessionHandle&& from) noexcept
    : RunQueryWithSessionHandle() {
    *this = ::std::move(from);
  }

  inline RunQueryWithSessionHandle& operator=(const RunQueryWithSessionHandle& from) {
    CopyFrom(from);
    return *this;
  }
  inline RunQueryWithSessionHandle& operator=(RunQueryWithSessionHandle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RunQueryWithSessionHandle& default_instance() {
    return *internal_default_instance();
  }
  static inline const RunQueryWithSessionHandle* internal_default_instance() {
    return reinterpret_cast<const RunQueryWithSessionHandle*>(
               &_RunQueryWithSessionHandle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(RunQueryWithSessionHandle& a, RunQueryWithSessionHandle& b) {
    a.Swap(&b);
  }
  inline void Swap(RunQueryWithSessionHandle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RunQueryWithSessionHandle* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RunQueryWithSessionHandle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RunQueryWithSessionHandle>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RunQueryWithSessionHandle& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RunQueryWithSessionHandle& from) {
    RunQueryWithSessionHandle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RunQueryWithSessionHandle* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.user.RunQueryWithSessionHandle";
  }
  protected:
  explicit RunQueryWithSessionHandle(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRunQueryFieldNumber = 1,
    kSessionHandleFieldNumber = 2,
  };
  // optional .exec.user.RunQuery runQuery = 1;
  bool has_runquery() const;
  void clear_runquery() ;
  const ::exec::user::RunQuery& runquery() const;
  PROTOBUF_NODISCARD ::exec::user::RunQuery* release_runquery();
  ::exec::user::RunQuery* mutable_runquery();
  void set_allocated_runquery(::exec::user::RunQuery* runquery);
  private:
  const ::exec::user::RunQuery& _internal_runquery() const;
  ::exec::user::RunQuery* _internal_mutable_runquery();
  public:
  void unsafe_arena_set_allocated_runquery(
      ::exec::user::RunQuery* runquery);
  ::exec::user::RunQuery* unsafe_arena_release_runquery();
  // optional .exec.user.SessionHandle sessionHandle = 2;
  bool has_sessionhandle() const;
  void clear_sessionhandle() ;
  const ::exec::user::SessionHandle& sessionhandle() const;
  PROTOBUF_NODISCARD ::exec::user::SessionHandle* release_sessionhandle();
  ::exec::user::SessionHandle* mutable_sessionhandle();
  void set_allocated_sessionhandle(::exec::user::SessionHandle* sessionhandle);
  private:
  const ::exec::user::SessionHandle& _internal_sessionhandle() const;
  ::exec::user::SessionHandle* _internal_mutable_sessionhandle();
  public:
  void unsafe_arena_set_allocated_sessionhandle(
      ::exec::user::SessionHandle* sessionhandle);
  ::exec::user::SessionHandle* unsafe_arena_release_sessionhandle();
  // @@protoc_insertion_point(class_scope:exec.user.RunQueryWithSessionHandle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::exec::user::RunQuery* runquery_;
    ::exec::user::SessionHandle* sessionhandle_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_User_2eproto;
};// -------------------------------------------------------------------

class CancelQueryWithSessionHandle final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.user.CancelQueryWithSessionHandle) */ {
 public:
  inline CancelQueryWithSessionHandle() : CancelQueryWithSessionHandle(nullptr) {}
  ~CancelQueryWithSessionHandle() override;
  explicit PROTOBUF_CONSTEXPR CancelQueryWithSessionHandle(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CancelQueryWithSessionHandle(const CancelQueryWithSessionHandle& from);
  CancelQueryWithSessionHandle(CancelQueryWithSessionHandle&& from) noexcept
    : CancelQueryWithSessionHandle() {
    *this = ::std::move(from);
  }

  inline CancelQueryWithSessionHandle& operator=(const CancelQueryWithSessionHandle& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelQueryWithSessionHandle& operator=(CancelQueryWithSessionHandle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CancelQueryWithSessionHandle& default_instance() {
    return *internal_default_instance();
  }
  static inline const CancelQueryWithSessionHandle* internal_default_instance() {
    return reinterpret_cast<const CancelQueryWithSessionHandle*>(
               &_CancelQueryWithSessionHandle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(CancelQueryWithSessionHandle& a, CancelQueryWithSessionHandle& b) {
    a.Swap(&b);
  }
  inline void Swap(CancelQueryWithSessionHandle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelQueryWithSessionHandle* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CancelQueryWithSessionHandle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CancelQueryWithSessionHandle>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CancelQueryWithSessionHandle& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CancelQueryWithSessionHandle& from) {
    CancelQueryWithSessionHandle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CancelQueryWithSessionHandle* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.user.CancelQueryWithSessionHandle";
  }
  protected:
  explicit CancelQueryWithSessionHandle(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQueryIdFieldNumber = 1,
    kSessionHandleFieldNumber = 2,
  };
  // optional .exec.shared.QueryId query_id = 1;
  bool has_query_id() const;
  void clear_query_id() ;
  const ::exec::shared::QueryId& query_id() const;
  PROTOBUF_NODISCARD ::exec::shared::QueryId* release_query_id();
  ::exec::shared::QueryId* mutable_query_id();
  void set_allocated_query_id(::exec::shared::QueryId* query_id);
  private:
  const ::exec::shared::QueryId& _internal_query_id() const;
  ::exec::shared::QueryId* _internal_mutable_query_id();
  public:
  void unsafe_arena_set_allocated_query_id(
      ::exec::shared::QueryId* query_id);
  ::exec::shared::QueryId* unsafe_arena_release_query_id();
  // optional .exec.user.SessionHandle session_handle = 2;
  bool has_session_handle() const;
  void clear_session_handle() ;
  const ::exec::user::SessionHandle& session_handle() const;
  PROTOBUF_NODISCARD ::exec::user::SessionHandle* release_session_handle();
  ::exec::user::SessionHandle* mutable_session_handle();
  void set_allocated_session_handle(::exec::user::SessionHandle* session_handle);
  private:
  const ::exec::user::SessionHandle& _internal_session_handle() const;
  ::exec::user::SessionHandle* _internal_mutable_session_handle();
  public:
  void unsafe_arena_set_allocated_session_handle(
      ::exec::user::SessionHandle* session_handle);
  ::exec::user::SessionHandle* unsafe_arena_release_session_handle();
  // @@protoc_insertion_point(class_scope:exec.user.CancelQueryWithSessionHandle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::exec::shared::QueryId* query_id_;
    ::exec::user::SessionHandle* session_handle_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_User_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Property

// required string key = 1;
inline bool Property::has_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Property::clear_key() {
  _impl_.key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Property::key() const {
  // @@protoc_insertion_point(field_get:exec.user.Property.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Property::set_key(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.user.Property.key)
}
inline std::string* Property::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:exec.user.Property.key)
  return _s;
}
inline const std::string& Property::_internal_key() const {
  return _impl_.key_.Get();
}
inline void Property::_internal_set_key(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* Property::_internal_mutable_key() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.key_.Mutable( GetArenaForAllocation());
}
inline std::string* Property::release_key() {
  // @@protoc_insertion_point(field_release:exec.user.Property.key)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.key_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.key_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Property::set_allocated_key(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.user.Property.key)
}

// required string value = 2;
inline bool Property::has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Property::clear_value() {
  _impl_.value_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Property::value() const {
  // @@protoc_insertion_point(field_get:exec.user.Property.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Property::set_value(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.value_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.user.Property.value)
}
inline std::string* Property::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:exec.user.Property.value)
  return _s;
}
inline const std::string& Property::_internal_value() const {
  return _impl_.value_.Get();
}
inline void Property::_internal_set_value(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* Property::_internal_mutable_value() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.value_.Mutable( GetArenaForAllocation());
}
inline std::string* Property::release_value() {
  // @@protoc_insertion_point(field_release:exec.user.Property.value)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.value_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.value_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Property::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.value_.IsDefault()) {
          _impl_.value_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.user.Property.value)
}

// -------------------------------------------------------------------

// UserProperties

// repeated .exec.user.Property properties = 1;
inline int UserProperties::_internal_properties_size() const {
  return _impl_.properties_.size();
}
inline int UserProperties::properties_size() const {
  return _internal_properties_size();
}
inline void UserProperties::clear_properties() {
  _impl_.properties_.Clear();
}
inline ::exec::user::Property* UserProperties::mutable_properties(int index) {
  // @@protoc_insertion_point(field_mutable:exec.user.UserProperties.properties)
  return _impl_.properties_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::user::Property >*
UserProperties::mutable_properties() {
  // @@protoc_insertion_point(field_mutable_list:exec.user.UserProperties.properties)
  return &_impl_.properties_;
}
inline const ::exec::user::Property& UserProperties::_internal_properties(int index) const {
  return _impl_.properties_.Get(index);
}
inline const ::exec::user::Property& UserProperties::properties(int index) const {
  // @@protoc_insertion_point(field_get:exec.user.UserProperties.properties)
  return _internal_properties(index);
}
inline ::exec::user::Property* UserProperties::_internal_add_properties() {
  return _impl_.properties_.Add();
}
inline ::exec::user::Property* UserProperties::add_properties() {
  ::exec::user::Property* _add = _internal_add_properties();
  // @@protoc_insertion_point(field_add:exec.user.UserProperties.properties)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::user::Property >&
UserProperties::properties() const {
  // @@protoc_insertion_point(field_list:exec.user.UserProperties.properties)
  return _impl_.properties_;
}

// -------------------------------------------------------------------

// RpcEndpointInfos

// optional string name = 1;
inline bool RpcEndpointInfos::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RpcEndpointInfos::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RpcEndpointInfos::name() const {
  // @@protoc_insertion_point(field_get:exec.user.RpcEndpointInfos.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RpcEndpointInfos::set_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.user.RpcEndpointInfos.name)
}
inline std::string* RpcEndpointInfos::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:exec.user.RpcEndpointInfos.name)
  return _s;
}
inline const std::string& RpcEndpointInfos::_internal_name() const {
  return _impl_.name_.Get();
}
inline void RpcEndpointInfos::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* RpcEndpointInfos::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* RpcEndpointInfos::release_name() {
  // @@protoc_insertion_point(field_release:exec.user.RpcEndpointInfos.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RpcEndpointInfos::set_allocated_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.user.RpcEndpointInfos.name)
}

// optional string version = 2;
inline bool RpcEndpointInfos::has_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RpcEndpointInfos::clear_version() {
  _impl_.version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RpcEndpointInfos::version() const {
  // @@protoc_insertion_point(field_get:exec.user.RpcEndpointInfos.version)
  return _internal_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RpcEndpointInfos::set_version(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.version_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.user.RpcEndpointInfos.version)
}
inline std::string* RpcEndpointInfos::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:exec.user.RpcEndpointInfos.version)
  return _s;
}
inline const std::string& RpcEndpointInfos::_internal_version() const {
  return _impl_.version_.Get();
}
inline void RpcEndpointInfos::_internal_set_version(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* RpcEndpointInfos::_internal_mutable_version() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.version_.Mutable( GetArenaForAllocation());
}
inline std::string* RpcEndpointInfos::release_version() {
  // @@protoc_insertion_point(field_release:exec.user.RpcEndpointInfos.version)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.version_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.version_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RpcEndpointInfos::set_allocated_version(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.version_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.version_.IsDefault()) {
          _impl_.version_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.user.RpcEndpointInfos.version)
}

// optional uint32 majorVersion = 3;
inline bool RpcEndpointInfos::has_majorversion() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void RpcEndpointInfos::clear_majorversion() {
  _impl_.majorversion_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t RpcEndpointInfos::majorversion() const {
  // @@protoc_insertion_point(field_get:exec.user.RpcEndpointInfos.majorVersion)
  return _internal_majorversion();
}
inline void RpcEndpointInfos::set_majorversion(::uint32_t value) {
  _internal_set_majorversion(value);
  // @@protoc_insertion_point(field_set:exec.user.RpcEndpointInfos.majorVersion)
}
inline ::uint32_t RpcEndpointInfos::_internal_majorversion() const {
  return _impl_.majorversion_;
}
inline void RpcEndpointInfos::_internal_set_majorversion(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.majorversion_ = value;
}

// optional uint32 minorVersion = 4;
inline bool RpcEndpointInfos::has_minorversion() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void RpcEndpointInfos::clear_minorversion() {
  _impl_.minorversion_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint32_t RpcEndpointInfos::minorversion() const {
  // @@protoc_insertion_point(field_get:exec.user.RpcEndpointInfos.minorVersion)
  return _internal_minorversion();
}
inline void RpcEndpointInfos::set_minorversion(::uint32_t value) {
  _internal_set_minorversion(value);
  // @@protoc_insertion_point(field_set:exec.user.RpcEndpointInfos.minorVersion)
}
inline ::uint32_t RpcEndpointInfos::_internal_minorversion() const {
  return _impl_.minorversion_;
}
inline void RpcEndpointInfos::_internal_set_minorversion(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.minorversion_ = value;
}

// optional uint32 patchVersion = 5;
inline bool RpcEndpointInfos::has_patchversion() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void RpcEndpointInfos::clear_patchversion() {
  _impl_.patchversion_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint32_t RpcEndpointInfos::patchversion() const {
  // @@protoc_insertion_point(field_get:exec.user.RpcEndpointInfos.patchVersion)
  return _internal_patchversion();
}
inline void RpcEndpointInfos::set_patchversion(::uint32_t value) {
  _internal_set_patchversion(value);
  // @@protoc_insertion_point(field_set:exec.user.RpcEndpointInfos.patchVersion)
}
inline ::uint32_t RpcEndpointInfos::_internal_patchversion() const {
  return _impl_.patchversion_;
}
inline void RpcEndpointInfos::_internal_set_patchversion(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.patchversion_ = value;
}

// optional string application = 6;
inline bool RpcEndpointInfos::has_application() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void RpcEndpointInfos::clear_application() {
  _impl_.application_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& RpcEndpointInfos::application() const {
  // @@protoc_insertion_point(field_get:exec.user.RpcEndpointInfos.application)
  return _internal_application();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RpcEndpointInfos::set_application(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.application_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.user.RpcEndpointInfos.application)
}
inline std::string* RpcEndpointInfos::mutable_application() {
  std::string* _s = _internal_mutable_application();
  // @@protoc_insertion_point(field_mutable:exec.user.RpcEndpointInfos.application)
  return _s;
}
inline const std::string& RpcEndpointInfos::_internal_application() const {
  return _impl_.application_.Get();
}
inline void RpcEndpointInfos::_internal_set_application(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;


  _impl_.application_.Set(value, GetArenaForAllocation());
}
inline std::string* RpcEndpointInfos::_internal_mutable_application() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.application_.Mutable( GetArenaForAllocation());
}
inline std::string* RpcEndpointInfos::release_application() {
  // @@protoc_insertion_point(field_release:exec.user.RpcEndpointInfos.application)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.application_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.application_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RpcEndpointInfos::set_allocated_application(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.application_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.application_.IsDefault()) {
          _impl_.application_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.user.RpcEndpointInfos.application)
}

// optional uint32 buildNumber = 7;
inline bool RpcEndpointInfos::has_buildnumber() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void RpcEndpointInfos::clear_buildnumber() {
  _impl_.buildnumber_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::uint32_t RpcEndpointInfos::buildnumber() const {
  // @@protoc_insertion_point(field_get:exec.user.RpcEndpointInfos.buildNumber)
  return _internal_buildnumber();
}
inline void RpcEndpointInfos::set_buildnumber(::uint32_t value) {
  _internal_set_buildnumber(value);
  // @@protoc_insertion_point(field_set:exec.user.RpcEndpointInfos.buildNumber)
}
inline ::uint32_t RpcEndpointInfos::_internal_buildnumber() const {
  return _impl_.buildnumber_;
}
inline void RpcEndpointInfos::_internal_set_buildnumber(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.buildnumber_ = value;
}

// optional string versionQualifier = 8;
inline bool RpcEndpointInfos::has_versionqualifier() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void RpcEndpointInfos::clear_versionqualifier() {
  _impl_.versionqualifier_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& RpcEndpointInfos::versionqualifier() const {
  // @@protoc_insertion_point(field_get:exec.user.RpcEndpointInfos.versionQualifier)
  return _internal_versionqualifier();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RpcEndpointInfos::set_versionqualifier(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.versionqualifier_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.user.RpcEndpointInfos.versionQualifier)
}
inline std::string* RpcEndpointInfos::mutable_versionqualifier() {
  std::string* _s = _internal_mutable_versionqualifier();
  // @@protoc_insertion_point(field_mutable:exec.user.RpcEndpointInfos.versionQualifier)
  return _s;
}
inline const std::string& RpcEndpointInfos::_internal_versionqualifier() const {
  return _impl_.versionqualifier_.Get();
}
inline void RpcEndpointInfos::_internal_set_versionqualifier(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;


  _impl_.versionqualifier_.Set(value, GetArenaForAllocation());
}
inline std::string* RpcEndpointInfos::_internal_mutable_versionqualifier() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.versionqualifier_.Mutable( GetArenaForAllocation());
}
inline std::string* RpcEndpointInfos::release_versionqualifier() {
  // @@protoc_insertion_point(field_release:exec.user.RpcEndpointInfos.versionQualifier)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.versionqualifier_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.versionqualifier_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RpcEndpointInfos::set_allocated_versionqualifier(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.versionqualifier_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.versionqualifier_.IsDefault()) {
          _impl_.versionqualifier_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.user.RpcEndpointInfos.versionQualifier)
}

// -------------------------------------------------------------------

// UserToBitHandshake

// optional .exec.shared.RpcChannel channel = 1 [default = USER];
inline bool UserToBitHandshake::has_channel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void UserToBitHandshake::clear_channel() {
  _impl_.channel_ = 2;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::exec::shared::RpcChannel UserToBitHandshake::channel() const {
  // @@protoc_insertion_point(field_get:exec.user.UserToBitHandshake.channel)
  return _internal_channel();
}
inline void UserToBitHandshake::set_channel(::exec::shared::RpcChannel value) {
   _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:exec.user.UserToBitHandshake.channel)
}
inline ::exec::shared::RpcChannel UserToBitHandshake::_internal_channel() const {
  return static_cast<::exec::shared::RpcChannel>(_impl_.channel_);
}
inline void UserToBitHandshake::_internal_set_channel(::exec::shared::RpcChannel value) {
  assert(::exec::shared::RpcChannel_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.channel_ = value;
}

// optional bool support_listening = 2;
inline bool UserToBitHandshake::has_support_listening() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void UserToBitHandshake::clear_support_listening() {
  _impl_.support_listening_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool UserToBitHandshake::support_listening() const {
  // @@protoc_insertion_point(field_get:exec.user.UserToBitHandshake.support_listening)
  return _internal_support_listening();
}
inline void UserToBitHandshake::set_support_listening(bool value) {
  _internal_set_support_listening(value);
  // @@protoc_insertion_point(field_set:exec.user.UserToBitHandshake.support_listening)
}
inline bool UserToBitHandshake::_internal_support_listening() const {
  return _impl_.support_listening_;
}
inline void UserToBitHandshake::_internal_set_support_listening(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.support_listening_ = value;
}

// optional int32 rpc_version = 3;
inline bool UserToBitHandshake::has_rpc_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void UserToBitHandshake::clear_rpc_version() {
  _impl_.rpc_version_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t UserToBitHandshake::rpc_version() const {
  // @@protoc_insertion_point(field_get:exec.user.UserToBitHandshake.rpc_version)
  return _internal_rpc_version();
}
inline void UserToBitHandshake::set_rpc_version(::int32_t value) {
  _internal_set_rpc_version(value);
  // @@protoc_insertion_point(field_set:exec.user.UserToBitHandshake.rpc_version)
}
inline ::int32_t UserToBitHandshake::_internal_rpc_version() const {
  return _impl_.rpc_version_;
}
inline void UserToBitHandshake::_internal_set_rpc_version(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.rpc_version_ = value;
}

// optional .exec.shared.UserCredentials credentials = 4;
inline bool UserToBitHandshake::has_credentials() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.credentials_ != nullptr);
  return value;
}
inline const ::exec::shared::UserCredentials& UserToBitHandshake::_internal_credentials() const {
  const ::exec::shared::UserCredentials* p = _impl_.credentials_;
  return p != nullptr ? *p : reinterpret_cast<const ::exec::shared::UserCredentials&>(
      ::exec::shared::_UserCredentials_default_instance_);
}
inline const ::exec::shared::UserCredentials& UserToBitHandshake::credentials() const {
  // @@protoc_insertion_point(field_get:exec.user.UserToBitHandshake.credentials)
  return _internal_credentials();
}
inline void UserToBitHandshake::unsafe_arena_set_allocated_credentials(
    ::exec::shared::UserCredentials* credentials) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.credentials_);
  }
  _impl_.credentials_ = credentials;
  if (credentials) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:exec.user.UserToBitHandshake.credentials)
}
inline ::exec::shared::UserCredentials* UserToBitHandshake::release_credentials() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::exec::shared::UserCredentials* temp = _impl_.credentials_;
  _impl_.credentials_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exec::shared::UserCredentials* UserToBitHandshake::unsafe_arena_release_credentials() {
  // @@protoc_insertion_point(field_release:exec.user.UserToBitHandshake.credentials)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::exec::shared::UserCredentials* temp = _impl_.credentials_;
  _impl_.credentials_ = nullptr;
  return temp;
}
inline ::exec::shared::UserCredentials* UserToBitHandshake::_internal_mutable_credentials() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.credentials_ == nullptr) {
    auto* p = CreateMaybeMessage<::exec::shared::UserCredentials>(GetArenaForAllocation());
    _impl_.credentials_ = p;
  }
  return _impl_.credentials_;
}
inline ::exec::shared::UserCredentials* UserToBitHandshake::mutable_credentials() {
  ::exec::shared::UserCredentials* _msg = _internal_mutable_credentials();
  // @@protoc_insertion_point(field_mutable:exec.user.UserToBitHandshake.credentials)
  return _msg;
}
inline void UserToBitHandshake::set_allocated_credentials(::exec::shared::UserCredentials* credentials) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.credentials_);
  }
  if (credentials) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(credentials));
    if (message_arena != submessage_arena) {
      credentials = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, credentials, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.credentials_ = credentials;
  // @@protoc_insertion_point(field_set_allocated:exec.user.UserToBitHandshake.credentials)
}

// optional .exec.user.UserProperties properties = 5;
inline bool UserToBitHandshake::has_properties() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.properties_ != nullptr);
  return value;
}
inline void UserToBitHandshake::clear_properties() {
  if (_impl_.properties_ != nullptr) _impl_.properties_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::exec::user::UserProperties& UserToBitHandshake::_internal_properties() const {
  const ::exec::user::UserProperties* p = _impl_.properties_;
  return p != nullptr ? *p : reinterpret_cast<const ::exec::user::UserProperties&>(
      ::exec::user::_UserProperties_default_instance_);
}
inline const ::exec::user::UserProperties& UserToBitHandshake::properties() const {
  // @@protoc_insertion_point(field_get:exec.user.UserToBitHandshake.properties)
  return _internal_properties();
}
inline void UserToBitHandshake::unsafe_arena_set_allocated_properties(
    ::exec::user::UserProperties* properties) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.properties_);
  }
  _impl_.properties_ = properties;
  if (properties) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:exec.user.UserToBitHandshake.properties)
}
inline ::exec::user::UserProperties* UserToBitHandshake::release_properties() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::exec::user::UserProperties* temp = _impl_.properties_;
  _impl_.properties_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exec::user::UserProperties* UserToBitHandshake::unsafe_arena_release_properties() {
  // @@protoc_insertion_point(field_release:exec.user.UserToBitHandshake.properties)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::exec::user::UserProperties* temp = _impl_.properties_;
  _impl_.properties_ = nullptr;
  return temp;
}
inline ::exec::user::UserProperties* UserToBitHandshake::_internal_mutable_properties() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.properties_ == nullptr) {
    auto* p = CreateMaybeMessage<::exec::user::UserProperties>(GetArenaForAllocation());
    _impl_.properties_ = p;
  }
  return _impl_.properties_;
}
inline ::exec::user::UserProperties* UserToBitHandshake::mutable_properties() {
  ::exec::user::UserProperties* _msg = _internal_mutable_properties();
  // @@protoc_insertion_point(field_mutable:exec.user.UserToBitHandshake.properties)
  return _msg;
}
inline void UserToBitHandshake::set_allocated_properties(::exec::user::UserProperties* properties) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.properties_;
  }
  if (properties) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(properties);
    if (message_arena != submessage_arena) {
      properties = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, properties, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.properties_ = properties;
  // @@protoc_insertion_point(field_set_allocated:exec.user.UserToBitHandshake.properties)
}

// optional bool support_complex_types = 6 [default = false];
inline bool UserToBitHandshake::has_support_complex_types() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void UserToBitHandshake::clear_support_complex_types() {
  _impl_.support_complex_types_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool UserToBitHandshake::support_complex_types() const {
  // @@protoc_insertion_point(field_get:exec.user.UserToBitHandshake.support_complex_types)
  return _internal_support_complex_types();
}
inline void UserToBitHandshake::set_support_complex_types(bool value) {
  _internal_set_support_complex_types(value);
  // @@protoc_insertion_point(field_set:exec.user.UserToBitHandshake.support_complex_types)
}
inline bool UserToBitHandshake::_internal_support_complex_types() const {
  return _impl_.support_complex_types_;
}
inline void UserToBitHandshake::_internal_set_support_complex_types(bool value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.support_complex_types_ = value;
}

// optional bool support_timeout = 7 [default = false];
inline bool UserToBitHandshake::has_support_timeout() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void UserToBitHandshake::clear_support_timeout() {
  _impl_.support_timeout_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool UserToBitHandshake::support_timeout() const {
  // @@protoc_insertion_point(field_get:exec.user.UserToBitHandshake.support_timeout)
  return _internal_support_timeout();
}
inline void UserToBitHandshake::set_support_timeout(bool value) {
  _internal_set_support_timeout(value);
  // @@protoc_insertion_point(field_set:exec.user.UserToBitHandshake.support_timeout)
}
inline bool UserToBitHandshake::_internal_support_timeout() const {
  return _impl_.support_timeout_;
}
inline void UserToBitHandshake::_internal_set_support_timeout(bool value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.support_timeout_ = value;
}

// optional .exec.user.RpcEndpointInfos client_infos = 8;
inline bool UserToBitHandshake::has_client_infos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.client_infos_ != nullptr);
  return value;
}
inline void UserToBitHandshake::clear_client_infos() {
  if (_impl_.client_infos_ != nullptr) _impl_.client_infos_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::exec::user::RpcEndpointInfos& UserToBitHandshake::_internal_client_infos() const {
  const ::exec::user::RpcEndpointInfos* p = _impl_.client_infos_;
  return p != nullptr ? *p : reinterpret_cast<const ::exec::user::RpcEndpointInfos&>(
      ::exec::user::_RpcEndpointInfos_default_instance_);
}
inline const ::exec::user::RpcEndpointInfos& UserToBitHandshake::client_infos() const {
  // @@protoc_insertion_point(field_get:exec.user.UserToBitHandshake.client_infos)
  return _internal_client_infos();
}
inline void UserToBitHandshake::unsafe_arena_set_allocated_client_infos(
    ::exec::user::RpcEndpointInfos* client_infos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.client_infos_);
  }
  _impl_.client_infos_ = client_infos;
  if (client_infos) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:exec.user.UserToBitHandshake.client_infos)
}
inline ::exec::user::RpcEndpointInfos* UserToBitHandshake::release_client_infos() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::exec::user::RpcEndpointInfos* temp = _impl_.client_infos_;
  _impl_.client_infos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exec::user::RpcEndpointInfos* UserToBitHandshake::unsafe_arena_release_client_infos() {
  // @@protoc_insertion_point(field_release:exec.user.UserToBitHandshake.client_infos)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::exec::user::RpcEndpointInfos* temp = _impl_.client_infos_;
  _impl_.client_infos_ = nullptr;
  return temp;
}
inline ::exec::user::RpcEndpointInfos* UserToBitHandshake::_internal_mutable_client_infos() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.client_infos_ == nullptr) {
    auto* p = CreateMaybeMessage<::exec::user::RpcEndpointInfos>(GetArenaForAllocation());
    _impl_.client_infos_ = p;
  }
  return _impl_.client_infos_;
}
inline ::exec::user::RpcEndpointInfos* UserToBitHandshake::mutable_client_infos() {
  ::exec::user::RpcEndpointInfos* _msg = _internal_mutable_client_infos();
  // @@protoc_insertion_point(field_mutable:exec.user.UserToBitHandshake.client_infos)
  return _msg;
}
inline void UserToBitHandshake::set_allocated_client_infos(::exec::user::RpcEndpointInfos* client_infos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.client_infos_;
  }
  if (client_infos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(client_infos);
    if (message_arena != submessage_arena) {
      client_infos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_infos, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.client_infos_ = client_infos;
  // @@protoc_insertion_point(field_set_allocated:exec.user.UserToBitHandshake.client_infos)
}

// optional .exec.user.SaslSupport sasl_support = 9;
inline bool UserToBitHandshake::has_sasl_support() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void UserToBitHandshake::clear_sasl_support() {
  _impl_.sasl_support_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::exec::user::SaslSupport UserToBitHandshake::sasl_support() const {
  // @@protoc_insertion_point(field_get:exec.user.UserToBitHandshake.sasl_support)
  return _internal_sasl_support();
}
inline void UserToBitHandshake::set_sasl_support(::exec::user::SaslSupport value) {
   _internal_set_sasl_support(value);
  // @@protoc_insertion_point(field_set:exec.user.UserToBitHandshake.sasl_support)
}
inline ::exec::user::SaslSupport UserToBitHandshake::_internal_sasl_support() const {
  return static_cast<::exec::user::SaslSupport>(_impl_.sasl_support_);
}
inline void UserToBitHandshake::_internal_set_sasl_support(::exec::user::SaslSupport value) {
  assert(::exec::user::SaslSupport_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.sasl_support_ = value;
}

// optional bool enable_multiplex = 10 [default = false];
inline bool UserToBitHandshake::has_enable_multiplex() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void UserToBitHandshake::clear_enable_multiplex() {
  _impl_.enable_multiplex_ = false;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline bool UserToBitHandshake::enable_multiplex() const {
  // @@protoc_insertion_point(field_get:exec.user.UserToBitHandshake.enable_multiplex)
  return _internal_enable_multiplex();
}
inline void UserToBitHandshake::set_enable_multiplex(bool value) {
  _internal_set_enable_multiplex(value);
  // @@protoc_insertion_point(field_set:exec.user.UserToBitHandshake.enable_multiplex)
}
inline bool UserToBitHandshake::_internal_enable_multiplex() const {
  return _impl_.enable_multiplex_;
}
inline void UserToBitHandshake::_internal_set_enable_multiplex(bool value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.enable_multiplex_ = value;
}

// optional int32 capabilities_version = 11 [default = 0];
inline bool UserToBitHandshake::has_capabilities_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void UserToBitHandshake::clear_capabilities_version() {
  _impl_.capabilities_version_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::int32_t UserToBitHandshake::capabilities_version() const {
  // @@protoc_insertion_point(field_get:exec.user.UserToBitHandshake.capabilities_version)
  return _internal_capabilities_version();
}
inline void UserToBitHandshake::set_capabilities_version(::int32_t value) {
  _internal_set_capabilities_version(value);
  // @@protoc_insertion_point(field_set:exec.user.UserToBitHandshake.capabilities_version)
}
inline ::int32_t UserToBitHandshake::_internal_capabilities_version() const {
  return _impl_.capabilities_version_;
}
inline void UserToBitHandshake::_internal_set_capabilities_version(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.capabilities_version_ = value;
}

// -------------------------------------------------------------------

// RequestResults

// optional .exec.shared.QueryId query_id = 1;
inline bool RequestResults::has_query_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.query_id_ != nullptr);
  return value;
}
inline const ::exec::shared::QueryId& RequestResults::_internal_query_id() const {
  const ::exec::shared::QueryId* p = _impl_.query_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::exec::shared::QueryId&>(
      ::exec::shared::_QueryId_default_instance_);
}
inline const ::exec::shared::QueryId& RequestResults::query_id() const {
  // @@protoc_insertion_point(field_get:exec.user.RequestResults.query_id)
  return _internal_query_id();
}
inline void RequestResults::unsafe_arena_set_allocated_query_id(
    ::exec::shared::QueryId* query_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.query_id_);
  }
  _impl_.query_id_ = query_id;
  if (query_id) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:exec.user.RequestResults.query_id)
}
inline ::exec::shared::QueryId* RequestResults::release_query_id() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::exec::shared::QueryId* temp = _impl_.query_id_;
  _impl_.query_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exec::shared::QueryId* RequestResults::unsafe_arena_release_query_id() {
  // @@protoc_insertion_point(field_release:exec.user.RequestResults.query_id)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::exec::shared::QueryId* temp = _impl_.query_id_;
  _impl_.query_id_ = nullptr;
  return temp;
}
inline ::exec::shared::QueryId* RequestResults::_internal_mutable_query_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.query_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::exec::shared::QueryId>(GetArenaForAllocation());
    _impl_.query_id_ = p;
  }
  return _impl_.query_id_;
}
inline ::exec::shared::QueryId* RequestResults::mutable_query_id() {
  ::exec::shared::QueryId* _msg = _internal_mutable_query_id();
  // @@protoc_insertion_point(field_mutable:exec.user.RequestResults.query_id)
  return _msg;
}
inline void RequestResults::set_allocated_query_id(::exec::shared::QueryId* query_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.query_id_);
  }
  if (query_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(query_id));
    if (message_arena != submessage_arena) {
      query_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, query_id, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.query_id_ = query_id;
  // @@protoc_insertion_point(field_set_allocated:exec.user.RequestResults.query_id)
}

// optional int32 maximum_responses = 2;
inline bool RequestResults::has_maximum_responses() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RequestResults::clear_maximum_responses() {
  _impl_.maximum_responses_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t RequestResults::maximum_responses() const {
  // @@protoc_insertion_point(field_get:exec.user.RequestResults.maximum_responses)
  return _internal_maximum_responses();
}
inline void RequestResults::set_maximum_responses(::int32_t value) {
  _internal_set_maximum_responses(value);
  // @@protoc_insertion_point(field_set:exec.user.RequestResults.maximum_responses)
}
inline ::int32_t RequestResults::_internal_maximum_responses() const {
  return _impl_.maximum_responses_;
}
inline void RequestResults::_internal_set_maximum_responses(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.maximum_responses_ = value;
}

// -------------------------------------------------------------------

// GetQueryPlanFragments

// required string query = 1;
inline bool GetQueryPlanFragments::has_query() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GetQueryPlanFragments::clear_query() {
  _impl_.query_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetQueryPlanFragments::query() const {
  // @@protoc_insertion_point(field_get:exec.user.GetQueryPlanFragments.query)
  return _internal_query();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetQueryPlanFragments::set_query(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.query_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.user.GetQueryPlanFragments.query)
}
inline std::string* GetQueryPlanFragments::mutable_query() {
  std::string* _s = _internal_mutable_query();
  // @@protoc_insertion_point(field_mutable:exec.user.GetQueryPlanFragments.query)
  return _s;
}
inline const std::string& GetQueryPlanFragments::_internal_query() const {
  return _impl_.query_.Get();
}
inline void GetQueryPlanFragments::_internal_set_query(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.query_.Set(value, GetArenaForAllocation());
}
inline std::string* GetQueryPlanFragments::_internal_mutable_query() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.query_.Mutable( GetArenaForAllocation());
}
inline std::string* GetQueryPlanFragments::release_query() {
  // @@protoc_insertion_point(field_release:exec.user.GetQueryPlanFragments.query)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.query_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.query_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void GetQueryPlanFragments::set_allocated_query(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.query_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.query_.IsDefault()) {
          _impl_.query_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.user.GetQueryPlanFragments.query)
}

// optional .exec.shared.QueryType type = 2;
inline bool GetQueryPlanFragments::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void GetQueryPlanFragments::clear_type() {
  _impl_.type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::exec::shared::QueryType GetQueryPlanFragments::type() const {
  // @@protoc_insertion_point(field_get:exec.user.GetQueryPlanFragments.type)
  return _internal_type();
}
inline void GetQueryPlanFragments::set_type(::exec::shared::QueryType value) {
   _internal_set_type(value);
  // @@protoc_insertion_point(field_set:exec.user.GetQueryPlanFragments.type)
}
inline ::exec::shared::QueryType GetQueryPlanFragments::_internal_type() const {
  return static_cast<::exec::shared::QueryType>(_impl_.type_);
}
inline void GetQueryPlanFragments::_internal_set_type(::exec::shared::QueryType value) {
  assert(::exec::shared::QueryType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.type_ = value;
}

// optional bool split_plan = 3 [default = false];
inline bool GetQueryPlanFragments::has_split_plan() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void GetQueryPlanFragments::clear_split_plan() {
  _impl_.split_plan_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool GetQueryPlanFragments::split_plan() const {
  // @@protoc_insertion_point(field_get:exec.user.GetQueryPlanFragments.split_plan)
  return _internal_split_plan();
}
inline void GetQueryPlanFragments::set_split_plan(bool value) {
  _internal_set_split_plan(value);
  // @@protoc_insertion_point(field_set:exec.user.GetQueryPlanFragments.split_plan)
}
inline bool GetQueryPlanFragments::_internal_split_plan() const {
  return _impl_.split_plan_;
}
inline void GetQueryPlanFragments::_internal_set_split_plan(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.split_plan_ = value;
}

// -------------------------------------------------------------------

// QueryPlanFragments

// required .exec.shared.QueryResult.QueryState status = 1;
inline bool QueryPlanFragments::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void QueryPlanFragments::clear_status() {
  _impl_.status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::exec::shared::QueryResult_QueryState QueryPlanFragments::status() const {
  // @@protoc_insertion_point(field_get:exec.user.QueryPlanFragments.status)
  return _internal_status();
}
inline void QueryPlanFragments::set_status(::exec::shared::QueryResult_QueryState value) {
   _internal_set_status(value);
  // @@protoc_insertion_point(field_set:exec.user.QueryPlanFragments.status)
}
inline ::exec::shared::QueryResult_QueryState QueryPlanFragments::_internal_status() const {
  return static_cast<::exec::shared::QueryResult_QueryState>(_impl_.status_);
}
inline void QueryPlanFragments::_internal_set_status(::exec::shared::QueryResult_QueryState value) {
  assert(::exec::shared::QueryResult_QueryState_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.status_ = value;
}

// optional .exec.shared.QueryId query_id = 2;
inline bool QueryPlanFragments::has_query_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.query_id_ != nullptr);
  return value;
}
inline const ::exec::shared::QueryId& QueryPlanFragments::_internal_query_id() const {
  const ::exec::shared::QueryId* p = _impl_.query_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::exec::shared::QueryId&>(
      ::exec::shared::_QueryId_default_instance_);
}
inline const ::exec::shared::QueryId& QueryPlanFragments::query_id() const {
  // @@protoc_insertion_point(field_get:exec.user.QueryPlanFragments.query_id)
  return _internal_query_id();
}
inline void QueryPlanFragments::unsafe_arena_set_allocated_query_id(
    ::exec::shared::QueryId* query_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.query_id_);
  }
  _impl_.query_id_ = query_id;
  if (query_id) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:exec.user.QueryPlanFragments.query_id)
}
inline ::exec::shared::QueryId* QueryPlanFragments::release_query_id() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::exec::shared::QueryId* temp = _impl_.query_id_;
  _impl_.query_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exec::shared::QueryId* QueryPlanFragments::unsafe_arena_release_query_id() {
  // @@protoc_insertion_point(field_release:exec.user.QueryPlanFragments.query_id)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::exec::shared::QueryId* temp = _impl_.query_id_;
  _impl_.query_id_ = nullptr;
  return temp;
}
inline ::exec::shared::QueryId* QueryPlanFragments::_internal_mutable_query_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.query_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::exec::shared::QueryId>(GetArenaForAllocation());
    _impl_.query_id_ = p;
  }
  return _impl_.query_id_;
}
inline ::exec::shared::QueryId* QueryPlanFragments::mutable_query_id() {
  ::exec::shared::QueryId* _msg = _internal_mutable_query_id();
  // @@protoc_insertion_point(field_mutable:exec.user.QueryPlanFragments.query_id)
  return _msg;
}
inline void QueryPlanFragments::set_allocated_query_id(::exec::shared::QueryId* query_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.query_id_);
  }
  if (query_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(query_id));
    if (message_arena != submessage_arena) {
      query_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, query_id, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.query_id_ = query_id;
  // @@protoc_insertion_point(field_set_allocated:exec.user.QueryPlanFragments.query_id)
}

// repeated .exec.bit.control.PlanFragment fragments = 3;
inline int QueryPlanFragments::_internal_fragments_size() const {
  return _impl_.fragments_.size();
}
inline int QueryPlanFragments::fragments_size() const {
  return _internal_fragments_size();
}
inline ::exec::bit::control::PlanFragment* QueryPlanFragments::mutable_fragments(int index) {
  // @@protoc_insertion_point(field_mutable:exec.user.QueryPlanFragments.fragments)
  return _impl_.fragments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::bit::control::PlanFragment >*
QueryPlanFragments::mutable_fragments() {
  // @@protoc_insertion_point(field_mutable_list:exec.user.QueryPlanFragments.fragments)
  return &_impl_.fragments_;
}
inline const ::exec::bit::control::PlanFragment& QueryPlanFragments::_internal_fragments(int index) const {
  return _impl_.fragments_.Get(index);
}
inline const ::exec::bit::control::PlanFragment& QueryPlanFragments::fragments(int index) const {
  // @@protoc_insertion_point(field_get:exec.user.QueryPlanFragments.fragments)
  return _internal_fragments(index);
}
inline ::exec::bit::control::PlanFragment* QueryPlanFragments::_internal_add_fragments() {
  return _impl_.fragments_.Add();
}
inline ::exec::bit::control::PlanFragment* QueryPlanFragments::add_fragments() {
  ::exec::bit::control::PlanFragment* _add = _internal_add_fragments();
  // @@protoc_insertion_point(field_add:exec.user.QueryPlanFragments.fragments)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::bit::control::PlanFragment >&
QueryPlanFragments::fragments() const {
  // @@protoc_insertion_point(field_list:exec.user.QueryPlanFragments.fragments)
  return _impl_.fragments_;
}

// optional .exec.shared.DrillPBError error = 4;
inline bool QueryPlanFragments::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_ != nullptr);
  return value;
}
inline const ::exec::shared::DrillPBError& QueryPlanFragments::_internal_error() const {
  const ::exec::shared::DrillPBError* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::exec::shared::DrillPBError&>(
      ::exec::shared::_DrillPBError_default_instance_);
}
inline const ::exec::shared::DrillPBError& QueryPlanFragments::error() const {
  // @@protoc_insertion_point(field_get:exec.user.QueryPlanFragments.error)
  return _internal_error();
}
inline void QueryPlanFragments::unsafe_arena_set_allocated_error(
    ::exec::shared::DrillPBError* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:exec.user.QueryPlanFragments.error)
}
inline ::exec::shared::DrillPBError* QueryPlanFragments::release_error() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::exec::shared::DrillPBError* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exec::shared::DrillPBError* QueryPlanFragments::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:exec.user.QueryPlanFragments.error)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::exec::shared::DrillPBError* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::exec::shared::DrillPBError* QueryPlanFragments::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::exec::shared::DrillPBError>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::exec::shared::DrillPBError* QueryPlanFragments::mutable_error() {
  ::exec::shared::DrillPBError* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:exec.user.QueryPlanFragments.error)
  return _msg;
}
inline void QueryPlanFragments::set_allocated_error(::exec::shared::DrillPBError* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(error));
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:exec.user.QueryPlanFragments.error)
}

// -------------------------------------------------------------------

// BitToUserHandshake

// optional int32 rpc_version = 2;
inline bool BitToUserHandshake::has_rpc_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void BitToUserHandshake::clear_rpc_version() {
  _impl_.rpc_version_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t BitToUserHandshake::rpc_version() const {
  // @@protoc_insertion_point(field_get:exec.user.BitToUserHandshake.rpc_version)
  return _internal_rpc_version();
}
inline void BitToUserHandshake::set_rpc_version(::int32_t value) {
  _internal_set_rpc_version(value);
  // @@protoc_insertion_point(field_set:exec.user.BitToUserHandshake.rpc_version)
}
inline ::int32_t BitToUserHandshake::_internal_rpc_version() const {
  return _impl_.rpc_version_;
}
inline void BitToUserHandshake::_internal_set_rpc_version(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.rpc_version_ = value;
}

// optional .exec.user.HandshakeStatus status = 3;
inline bool BitToUserHandshake::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void BitToUserHandshake::clear_status() {
  _impl_.status_ = 1;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::exec::user::HandshakeStatus BitToUserHandshake::status() const {
  // @@protoc_insertion_point(field_get:exec.user.BitToUserHandshake.status)
  return _internal_status();
}
inline void BitToUserHandshake::set_status(::exec::user::HandshakeStatus value) {
   _internal_set_status(value);
  // @@protoc_insertion_point(field_set:exec.user.BitToUserHandshake.status)
}
inline ::exec::user::HandshakeStatus BitToUserHandshake::_internal_status() const {
  return static_cast<::exec::user::HandshakeStatus>(_impl_.status_);
}
inline void BitToUserHandshake::_internal_set_status(::exec::user::HandshakeStatus value) {
  assert(::exec::user::HandshakeStatus_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.status_ = value;
}

// optional string errorId = 4;
inline bool BitToUserHandshake::has_errorid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BitToUserHandshake::clear_errorid() {
  _impl_.errorid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BitToUserHandshake::errorid() const {
  // @@protoc_insertion_point(field_get:exec.user.BitToUserHandshake.errorId)
  return _internal_errorid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BitToUserHandshake::set_errorid(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.errorid_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.user.BitToUserHandshake.errorId)
}
inline std::string* BitToUserHandshake::mutable_errorid() {
  std::string* _s = _internal_mutable_errorid();
  // @@protoc_insertion_point(field_mutable:exec.user.BitToUserHandshake.errorId)
  return _s;
}
inline const std::string& BitToUserHandshake::_internal_errorid() const {
  return _impl_.errorid_.Get();
}
inline void BitToUserHandshake::_internal_set_errorid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.errorid_.Set(value, GetArenaForAllocation());
}
inline std::string* BitToUserHandshake::_internal_mutable_errorid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.errorid_.Mutable( GetArenaForAllocation());
}
inline std::string* BitToUserHandshake::release_errorid() {
  // @@protoc_insertion_point(field_release:exec.user.BitToUserHandshake.errorId)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.errorid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.errorid_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BitToUserHandshake::set_allocated_errorid(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.errorid_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.errorid_.IsDefault()) {
          _impl_.errorid_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.user.BitToUserHandshake.errorId)
}

// optional string errorMessage = 5;
inline bool BitToUserHandshake::has_errormessage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BitToUserHandshake::clear_errormessage() {
  _impl_.errormessage_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BitToUserHandshake::errormessage() const {
  // @@protoc_insertion_point(field_get:exec.user.BitToUserHandshake.errorMessage)
  return _internal_errormessage();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BitToUserHandshake::set_errormessage(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.errormessage_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.user.BitToUserHandshake.errorMessage)
}
inline std::string* BitToUserHandshake::mutable_errormessage() {
  std::string* _s = _internal_mutable_errormessage();
  // @@protoc_insertion_point(field_mutable:exec.user.BitToUserHandshake.errorMessage)
  return _s;
}
inline const std::string& BitToUserHandshake::_internal_errormessage() const {
  return _impl_.errormessage_.Get();
}
inline void BitToUserHandshake::_internal_set_errormessage(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.errormessage_.Set(value, GetArenaForAllocation());
}
inline std::string* BitToUserHandshake::_internal_mutable_errormessage() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.errormessage_.Mutable( GetArenaForAllocation());
}
inline std::string* BitToUserHandshake::release_errormessage() {
  // @@protoc_insertion_point(field_release:exec.user.BitToUserHandshake.errorMessage)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.errormessage_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.errormessage_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BitToUserHandshake::set_allocated_errormessage(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.errormessage_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.errormessage_.IsDefault()) {
          _impl_.errormessage_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.user.BitToUserHandshake.errorMessage)
}

// optional .exec.user.RpcEndpointInfos server_infos = 6;
inline bool BitToUserHandshake::has_server_infos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.server_infos_ != nullptr);
  return value;
}
inline void BitToUserHandshake::clear_server_infos() {
  if (_impl_.server_infos_ != nullptr) _impl_.server_infos_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::exec::user::RpcEndpointInfos& BitToUserHandshake::_internal_server_infos() const {
  const ::exec::user::RpcEndpointInfos* p = _impl_.server_infos_;
  return p != nullptr ? *p : reinterpret_cast<const ::exec::user::RpcEndpointInfos&>(
      ::exec::user::_RpcEndpointInfos_default_instance_);
}
inline const ::exec::user::RpcEndpointInfos& BitToUserHandshake::server_infos() const {
  // @@protoc_insertion_point(field_get:exec.user.BitToUserHandshake.server_infos)
  return _internal_server_infos();
}
inline void BitToUserHandshake::unsafe_arena_set_allocated_server_infos(
    ::exec::user::RpcEndpointInfos* server_infos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.server_infos_);
  }
  _impl_.server_infos_ = server_infos;
  if (server_infos) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:exec.user.BitToUserHandshake.server_infos)
}
inline ::exec::user::RpcEndpointInfos* BitToUserHandshake::release_server_infos() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::exec::user::RpcEndpointInfos* temp = _impl_.server_infos_;
  _impl_.server_infos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exec::user::RpcEndpointInfos* BitToUserHandshake::unsafe_arena_release_server_infos() {
  // @@protoc_insertion_point(field_release:exec.user.BitToUserHandshake.server_infos)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::exec::user::RpcEndpointInfos* temp = _impl_.server_infos_;
  _impl_.server_infos_ = nullptr;
  return temp;
}
inline ::exec::user::RpcEndpointInfos* BitToUserHandshake::_internal_mutable_server_infos() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.server_infos_ == nullptr) {
    auto* p = CreateMaybeMessage<::exec::user::RpcEndpointInfos>(GetArenaForAllocation());
    _impl_.server_infos_ = p;
  }
  return _impl_.server_infos_;
}
inline ::exec::user::RpcEndpointInfos* BitToUserHandshake::mutable_server_infos() {
  ::exec::user::RpcEndpointInfos* _msg = _internal_mutable_server_infos();
  // @@protoc_insertion_point(field_mutable:exec.user.BitToUserHandshake.server_infos)
  return _msg;
}
inline void BitToUserHandshake::set_allocated_server_infos(::exec::user::RpcEndpointInfos* server_infos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.server_infos_;
  }
  if (server_infos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(server_infos);
    if (message_arena != submessage_arena) {
      server_infos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, server_infos, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.server_infos_ = server_infos;
  // @@protoc_insertion_point(field_set_allocated:exec.user.BitToUserHandshake.server_infos)
}

// repeated string authenticationMechanisms = 7;
inline int BitToUserHandshake::_internal_authenticationmechanisms_size() const {
  return _impl_.authenticationmechanisms_.size();
}
inline int BitToUserHandshake::authenticationmechanisms_size() const {
  return _internal_authenticationmechanisms_size();
}
inline void BitToUserHandshake::clear_authenticationmechanisms() {
  _impl_.authenticationmechanisms_.Clear();
}
inline std::string* BitToUserHandshake::add_authenticationmechanisms() {
  std::string* _s = _internal_add_authenticationmechanisms();
  // @@protoc_insertion_point(field_add_mutable:exec.user.BitToUserHandshake.authenticationMechanisms)
  return _s;
}
inline const std::string& BitToUserHandshake::_internal_authenticationmechanisms(int index) const {
  return _impl_.authenticationmechanisms_.Get(index);
}
inline const std::string& BitToUserHandshake::authenticationmechanisms(int index) const {
  // @@protoc_insertion_point(field_get:exec.user.BitToUserHandshake.authenticationMechanisms)
  return _internal_authenticationmechanisms(index);
}
inline std::string* BitToUserHandshake::mutable_authenticationmechanisms(int index) {
  // @@protoc_insertion_point(field_mutable:exec.user.BitToUserHandshake.authenticationMechanisms)
  return _impl_.authenticationmechanisms_.Mutable(index);
}
inline void BitToUserHandshake::set_authenticationmechanisms(int index, const std::string& value) {
  _impl_.authenticationmechanisms_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:exec.user.BitToUserHandshake.authenticationMechanisms)
}
inline void BitToUserHandshake::set_authenticationmechanisms(int index, std::string&& value) {
  _impl_.authenticationmechanisms_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:exec.user.BitToUserHandshake.authenticationMechanisms)
}
inline void BitToUserHandshake::set_authenticationmechanisms(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _impl_.authenticationmechanisms_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:exec.user.BitToUserHandshake.authenticationMechanisms)
}
inline void BitToUserHandshake::set_authenticationmechanisms(int index, const char* value,
                              std::size_t size) {
  _impl_.authenticationmechanisms_.Mutable(index)->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:exec.user.BitToUserHandshake.authenticationMechanisms)
}
inline void BitToUserHandshake::set_authenticationmechanisms(int index, absl::string_view value) {
  _impl_.authenticationmechanisms_.Mutable(index)->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:exec.user.BitToUserHandshake.authenticationMechanisms)
}
inline std::string* BitToUserHandshake::_internal_add_authenticationmechanisms() { return _impl_.authenticationmechanisms_.Add(); }
inline void BitToUserHandshake::add_authenticationmechanisms(const std::string& value) {
  _impl_.authenticationmechanisms_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:exec.user.BitToUserHandshake.authenticationMechanisms)
}
inline void BitToUserHandshake::add_authenticationmechanisms(std::string&& value) {
  _impl_.authenticationmechanisms_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:exec.user.BitToUserHandshake.authenticationMechanisms)
}
inline void BitToUserHandshake::add_authenticationmechanisms(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _impl_.authenticationmechanisms_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:exec.user.BitToUserHandshake.authenticationMechanisms)
}
inline void BitToUserHandshake::add_authenticationmechanisms(const char* value, std::size_t size) {
  _impl_.authenticationmechanisms_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:exec.user.BitToUserHandshake.authenticationMechanisms)
}
inline void BitToUserHandshake::add_authenticationmechanisms(absl::string_view value) {
  _impl_.authenticationmechanisms_.Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:exec.user.BitToUserHandshake.authenticationMechanisms)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BitToUserHandshake::authenticationmechanisms() const {
  // @@protoc_insertion_point(field_list:exec.user.BitToUserHandshake.authenticationMechanisms)
  return _impl_.authenticationmechanisms_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* BitToUserHandshake::mutable_authenticationmechanisms() {
  // @@protoc_insertion_point(field_mutable_list:exec.user.BitToUserHandshake.authenticationMechanisms)
  return &_impl_.authenticationmechanisms_;
}

// repeated .exec.user.RpcType supported_methods = 8;
inline int BitToUserHandshake::_internal_supported_methods_size() const {
  return _impl_.supported_methods_.size();
}
inline int BitToUserHandshake::supported_methods_size() const {
  return _internal_supported_methods_size();
}
inline void BitToUserHandshake::clear_supported_methods() {
  _impl_.supported_methods_.Clear();
}
inline ::exec::user::RpcType BitToUserHandshake::supported_methods(int index) const {
  // @@protoc_insertion_point(field_get:exec.user.BitToUserHandshake.supported_methods)
  return _internal_supported_methods(index);
}
inline void BitToUserHandshake::set_supported_methods(int index, ::exec::user::RpcType value) {
  assert(::exec::user::RpcType_IsValid(value));
  _impl_.supported_methods_.Set(index, value);
  // @@protoc_insertion_point(field_set:exec.user.BitToUserHandshake.supported_methods)
}
inline void BitToUserHandshake::add_supported_methods(::exec::user::RpcType value) {
  _internal_add_supported_methods(value);
  // @@protoc_insertion_point(field_add:exec.user.BitToUserHandshake.supported_methods)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& BitToUserHandshake::supported_methods() const {
  // @@protoc_insertion_point(field_list:exec.user.BitToUserHandshake.supported_methods)
  return _impl_.supported_methods_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* BitToUserHandshake::mutable_supported_methods() {
  // @@protoc_insertion_point(field_mutable_list:exec.user.BitToUserHandshake.supported_methods)
  return _internal_mutable_supported_methods();
}
inline ::exec::user::RpcType BitToUserHandshake::_internal_supported_methods(int index) const {
  return static_cast<::exec::user::RpcType>(_impl_.supported_methods_.Get(index));
}
inline void BitToUserHandshake::_internal_add_supported_methods(::exec::user::RpcType value) {
  assert(::exec::user::RpcType_IsValid(value));
  _impl_.supported_methods_.Add(value);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* BitToUserHandshake::_internal_mutable_supported_methods() {
  return &_impl_.supported_methods_;
}

// optional bool encrypted = 9;
inline bool BitToUserHandshake::has_encrypted() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void BitToUserHandshake::clear_encrypted() {
  _impl_.encrypted_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool BitToUserHandshake::encrypted() const {
  // @@protoc_insertion_point(field_get:exec.user.BitToUserHandshake.encrypted)
  return _internal_encrypted();
}
inline void BitToUserHandshake::set_encrypted(bool value) {
  _internal_set_encrypted(value);
  // @@protoc_insertion_point(field_set:exec.user.BitToUserHandshake.encrypted)
}
inline bool BitToUserHandshake::_internal_encrypted() const {
  return _impl_.encrypted_;
}
inline void BitToUserHandshake::_internal_set_encrypted(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.encrypted_ = value;
}

// optional int32 maxWrappedSize = 10;
inline bool BitToUserHandshake::has_maxwrappedsize() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void BitToUserHandshake::clear_maxwrappedsize() {
  _impl_.maxwrappedsize_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int32_t BitToUserHandshake::maxwrappedsize() const {
  // @@protoc_insertion_point(field_get:exec.user.BitToUserHandshake.maxWrappedSize)
  return _internal_maxwrappedsize();
}
inline void BitToUserHandshake::set_maxwrappedsize(::int32_t value) {
  _internal_set_maxwrappedsize(value);
  // @@protoc_insertion_point(field_set:exec.user.BitToUserHandshake.maxWrappedSize)
}
inline ::int32_t BitToUserHandshake::_internal_maxwrappedsize() const {
  return _impl_.maxwrappedsize_;
}
inline void BitToUserHandshake::_internal_set_maxwrappedsize(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.maxwrappedsize_ = value;
}

// -------------------------------------------------------------------

// LikeFilter

// optional string pattern = 1;
inline bool LikeFilter::has_pattern() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void LikeFilter::clear_pattern() {
  _impl_.pattern_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LikeFilter::pattern() const {
  // @@protoc_insertion_point(field_get:exec.user.LikeFilter.pattern)
  return _internal_pattern();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LikeFilter::set_pattern(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.pattern_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.user.LikeFilter.pattern)
}
inline std::string* LikeFilter::mutable_pattern() {
  std::string* _s = _internal_mutable_pattern();
  // @@protoc_insertion_point(field_mutable:exec.user.LikeFilter.pattern)
  return _s;
}
inline const std::string& LikeFilter::_internal_pattern() const {
  return _impl_.pattern_.Get();
}
inline void LikeFilter::_internal_set_pattern(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.pattern_.Set(value, GetArenaForAllocation());
}
inline std::string* LikeFilter::_internal_mutable_pattern() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.pattern_.Mutable( GetArenaForAllocation());
}
inline std::string* LikeFilter::release_pattern() {
  // @@protoc_insertion_point(field_release:exec.user.LikeFilter.pattern)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.pattern_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.pattern_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void LikeFilter::set_allocated_pattern(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.pattern_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.pattern_.IsDefault()) {
          _impl_.pattern_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.user.LikeFilter.pattern)
}

// optional string escape = 2;
inline bool LikeFilter::has_escape() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void LikeFilter::clear_escape() {
  _impl_.escape_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& LikeFilter::escape() const {
  // @@protoc_insertion_point(field_get:exec.user.LikeFilter.escape)
  return _internal_escape();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LikeFilter::set_escape(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.escape_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.user.LikeFilter.escape)
}
inline std::string* LikeFilter::mutable_escape() {
  std::string* _s = _internal_mutable_escape();
  // @@protoc_insertion_point(field_mutable:exec.user.LikeFilter.escape)
  return _s;
}
inline const std::string& LikeFilter::_internal_escape() const {
  return _impl_.escape_.Get();
}
inline void LikeFilter::_internal_set_escape(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.escape_.Set(value, GetArenaForAllocation());
}
inline std::string* LikeFilter::_internal_mutable_escape() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.escape_.Mutable( GetArenaForAllocation());
}
inline std::string* LikeFilter::release_escape() {
  // @@protoc_insertion_point(field_release:exec.user.LikeFilter.escape)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.escape_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.escape_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void LikeFilter::set_allocated_escape(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.escape_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.escape_.IsDefault()) {
          _impl_.escape_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.user.LikeFilter.escape)
}

// -------------------------------------------------------------------

// GetCatalogsReq

// optional .exec.user.LikeFilter catalog_name_filter = 1;
inline bool GetCatalogsReq::has_catalog_name_filter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.catalog_name_filter_ != nullptr);
  return value;
}
inline void GetCatalogsReq::clear_catalog_name_filter() {
  if (_impl_.catalog_name_filter_ != nullptr) _impl_.catalog_name_filter_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::exec::user::LikeFilter& GetCatalogsReq::_internal_catalog_name_filter() const {
  const ::exec::user::LikeFilter* p = _impl_.catalog_name_filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::exec::user::LikeFilter&>(
      ::exec::user::_LikeFilter_default_instance_);
}
inline const ::exec::user::LikeFilter& GetCatalogsReq::catalog_name_filter() const {
  // @@protoc_insertion_point(field_get:exec.user.GetCatalogsReq.catalog_name_filter)
  return _internal_catalog_name_filter();
}
inline void GetCatalogsReq::unsafe_arena_set_allocated_catalog_name_filter(
    ::exec::user::LikeFilter* catalog_name_filter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.catalog_name_filter_);
  }
  _impl_.catalog_name_filter_ = catalog_name_filter;
  if (catalog_name_filter) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:exec.user.GetCatalogsReq.catalog_name_filter)
}
inline ::exec::user::LikeFilter* GetCatalogsReq::release_catalog_name_filter() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::exec::user::LikeFilter* temp = _impl_.catalog_name_filter_;
  _impl_.catalog_name_filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exec::user::LikeFilter* GetCatalogsReq::unsafe_arena_release_catalog_name_filter() {
  // @@protoc_insertion_point(field_release:exec.user.GetCatalogsReq.catalog_name_filter)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::exec::user::LikeFilter* temp = _impl_.catalog_name_filter_;
  _impl_.catalog_name_filter_ = nullptr;
  return temp;
}
inline ::exec::user::LikeFilter* GetCatalogsReq::_internal_mutable_catalog_name_filter() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.catalog_name_filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::exec::user::LikeFilter>(GetArenaForAllocation());
    _impl_.catalog_name_filter_ = p;
  }
  return _impl_.catalog_name_filter_;
}
inline ::exec::user::LikeFilter* GetCatalogsReq::mutable_catalog_name_filter() {
  ::exec::user::LikeFilter* _msg = _internal_mutable_catalog_name_filter();
  // @@protoc_insertion_point(field_mutable:exec.user.GetCatalogsReq.catalog_name_filter)
  return _msg;
}
inline void GetCatalogsReq::set_allocated_catalog_name_filter(::exec::user::LikeFilter* catalog_name_filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.catalog_name_filter_;
  }
  if (catalog_name_filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(catalog_name_filter);
    if (message_arena != submessage_arena) {
      catalog_name_filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, catalog_name_filter, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.catalog_name_filter_ = catalog_name_filter;
  // @@protoc_insertion_point(field_set_allocated:exec.user.GetCatalogsReq.catalog_name_filter)
}

// -------------------------------------------------------------------

// CatalogMetadata

// optional string catalog_name = 1;
inline bool CatalogMetadata::has_catalog_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CatalogMetadata::clear_catalog_name() {
  _impl_.catalog_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CatalogMetadata::catalog_name() const {
  // @@protoc_insertion_point(field_get:exec.user.CatalogMetadata.catalog_name)
  return _internal_catalog_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CatalogMetadata::set_catalog_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.catalog_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.user.CatalogMetadata.catalog_name)
}
inline std::string* CatalogMetadata::mutable_catalog_name() {
  std::string* _s = _internal_mutable_catalog_name();
  // @@protoc_insertion_point(field_mutable:exec.user.CatalogMetadata.catalog_name)
  return _s;
}
inline const std::string& CatalogMetadata::_internal_catalog_name() const {
  return _impl_.catalog_name_.Get();
}
inline void CatalogMetadata::_internal_set_catalog_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.catalog_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CatalogMetadata::_internal_mutable_catalog_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.catalog_name_.Mutable( GetArenaForAllocation());
}
inline std::string* CatalogMetadata::release_catalog_name() {
  // @@protoc_insertion_point(field_release:exec.user.CatalogMetadata.catalog_name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.catalog_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.catalog_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CatalogMetadata::set_allocated_catalog_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.catalog_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.catalog_name_.IsDefault()) {
          _impl_.catalog_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.user.CatalogMetadata.catalog_name)
}

// optional string description = 2;
inline bool CatalogMetadata::has_description() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CatalogMetadata::clear_description() {
  _impl_.description_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CatalogMetadata::description() const {
  // @@protoc_insertion_point(field_get:exec.user.CatalogMetadata.description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CatalogMetadata::set_description(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.description_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.user.CatalogMetadata.description)
}
inline std::string* CatalogMetadata::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:exec.user.CatalogMetadata.description)
  return _s;
}
inline const std::string& CatalogMetadata::_internal_description() const {
  return _impl_.description_.Get();
}
inline void CatalogMetadata::_internal_set_description(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* CatalogMetadata::_internal_mutable_description() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.description_.Mutable( GetArenaForAllocation());
}
inline std::string* CatalogMetadata::release_description() {
  // @@protoc_insertion_point(field_release:exec.user.CatalogMetadata.description)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.description_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.description_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CatalogMetadata::set_allocated_description(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.description_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.user.CatalogMetadata.description)
}

// optional string connect = 3;
inline bool CatalogMetadata::has_connect() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CatalogMetadata::clear_connect() {
  _impl_.connect_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CatalogMetadata::connect() const {
  // @@protoc_insertion_point(field_get:exec.user.CatalogMetadata.connect)
  return _internal_connect();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CatalogMetadata::set_connect(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.connect_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.user.CatalogMetadata.connect)
}
inline std::string* CatalogMetadata::mutable_connect() {
  std::string* _s = _internal_mutable_connect();
  // @@protoc_insertion_point(field_mutable:exec.user.CatalogMetadata.connect)
  return _s;
}
inline const std::string& CatalogMetadata::_internal_connect() const {
  return _impl_.connect_.Get();
}
inline void CatalogMetadata::_internal_set_connect(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;


  _impl_.connect_.Set(value, GetArenaForAllocation());
}
inline std::string* CatalogMetadata::_internal_mutable_connect() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.connect_.Mutable( GetArenaForAllocation());
}
inline std::string* CatalogMetadata::release_connect() {
  // @@protoc_insertion_point(field_release:exec.user.CatalogMetadata.connect)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.connect_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.connect_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CatalogMetadata::set_allocated_connect(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.connect_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.connect_.IsDefault()) {
          _impl_.connect_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.user.CatalogMetadata.connect)
}

// -------------------------------------------------------------------

// GetCatalogsResp

// optional .exec.user.RequestStatus status = 1;
inline bool GetCatalogsResp::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void GetCatalogsResp::clear_status() {
  _impl_.status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::exec::user::RequestStatus GetCatalogsResp::status() const {
  // @@protoc_insertion_point(field_get:exec.user.GetCatalogsResp.status)
  return _internal_status();
}
inline void GetCatalogsResp::set_status(::exec::user::RequestStatus value) {
   _internal_set_status(value);
  // @@protoc_insertion_point(field_set:exec.user.GetCatalogsResp.status)
}
inline ::exec::user::RequestStatus GetCatalogsResp::_internal_status() const {
  return static_cast<::exec::user::RequestStatus>(_impl_.status_);
}
inline void GetCatalogsResp::_internal_set_status(::exec::user::RequestStatus value) {
  assert(::exec::user::RequestStatus_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.status_ = value;
}

// repeated .exec.user.CatalogMetadata catalogs = 2;
inline int GetCatalogsResp::_internal_catalogs_size() const {
  return _impl_.catalogs_.size();
}
inline int GetCatalogsResp::catalogs_size() const {
  return _internal_catalogs_size();
}
inline void GetCatalogsResp::clear_catalogs() {
  _impl_.catalogs_.Clear();
}
inline ::exec::user::CatalogMetadata* GetCatalogsResp::mutable_catalogs(int index) {
  // @@protoc_insertion_point(field_mutable:exec.user.GetCatalogsResp.catalogs)
  return _impl_.catalogs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::user::CatalogMetadata >*
GetCatalogsResp::mutable_catalogs() {
  // @@protoc_insertion_point(field_mutable_list:exec.user.GetCatalogsResp.catalogs)
  return &_impl_.catalogs_;
}
inline const ::exec::user::CatalogMetadata& GetCatalogsResp::_internal_catalogs(int index) const {
  return _impl_.catalogs_.Get(index);
}
inline const ::exec::user::CatalogMetadata& GetCatalogsResp::catalogs(int index) const {
  // @@protoc_insertion_point(field_get:exec.user.GetCatalogsResp.catalogs)
  return _internal_catalogs(index);
}
inline ::exec::user::CatalogMetadata* GetCatalogsResp::_internal_add_catalogs() {
  return _impl_.catalogs_.Add();
}
inline ::exec::user::CatalogMetadata* GetCatalogsResp::add_catalogs() {
  ::exec::user::CatalogMetadata* _add = _internal_add_catalogs();
  // @@protoc_insertion_point(field_add:exec.user.GetCatalogsResp.catalogs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::user::CatalogMetadata >&
GetCatalogsResp::catalogs() const {
  // @@protoc_insertion_point(field_list:exec.user.GetCatalogsResp.catalogs)
  return _impl_.catalogs_;
}

// optional .exec.shared.DrillPBError error = 3;
inline bool GetCatalogsResp::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_ != nullptr);
  return value;
}
inline const ::exec::shared::DrillPBError& GetCatalogsResp::_internal_error() const {
  const ::exec::shared::DrillPBError* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::exec::shared::DrillPBError&>(
      ::exec::shared::_DrillPBError_default_instance_);
}
inline const ::exec::shared::DrillPBError& GetCatalogsResp::error() const {
  // @@protoc_insertion_point(field_get:exec.user.GetCatalogsResp.error)
  return _internal_error();
}
inline void GetCatalogsResp::unsafe_arena_set_allocated_error(
    ::exec::shared::DrillPBError* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:exec.user.GetCatalogsResp.error)
}
inline ::exec::shared::DrillPBError* GetCatalogsResp::release_error() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::exec::shared::DrillPBError* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exec::shared::DrillPBError* GetCatalogsResp::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:exec.user.GetCatalogsResp.error)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::exec::shared::DrillPBError* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::exec::shared::DrillPBError* GetCatalogsResp::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::exec::shared::DrillPBError>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::exec::shared::DrillPBError* GetCatalogsResp::mutable_error() {
  ::exec::shared::DrillPBError* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:exec.user.GetCatalogsResp.error)
  return _msg;
}
inline void GetCatalogsResp::set_allocated_error(::exec::shared::DrillPBError* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(error));
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:exec.user.GetCatalogsResp.error)
}

// -------------------------------------------------------------------

// GetSchemasReq

// optional .exec.user.LikeFilter catalog_name_filter = 1;
inline bool GetSchemasReq::has_catalog_name_filter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.catalog_name_filter_ != nullptr);
  return value;
}
inline void GetSchemasReq::clear_catalog_name_filter() {
  if (_impl_.catalog_name_filter_ != nullptr) _impl_.catalog_name_filter_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::exec::user::LikeFilter& GetSchemasReq::_internal_catalog_name_filter() const {
  const ::exec::user::LikeFilter* p = _impl_.catalog_name_filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::exec::user::LikeFilter&>(
      ::exec::user::_LikeFilter_default_instance_);
}
inline const ::exec::user::LikeFilter& GetSchemasReq::catalog_name_filter() const {
  // @@protoc_insertion_point(field_get:exec.user.GetSchemasReq.catalog_name_filter)
  return _internal_catalog_name_filter();
}
inline void GetSchemasReq::unsafe_arena_set_allocated_catalog_name_filter(
    ::exec::user::LikeFilter* catalog_name_filter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.catalog_name_filter_);
  }
  _impl_.catalog_name_filter_ = catalog_name_filter;
  if (catalog_name_filter) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:exec.user.GetSchemasReq.catalog_name_filter)
}
inline ::exec::user::LikeFilter* GetSchemasReq::release_catalog_name_filter() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::exec::user::LikeFilter* temp = _impl_.catalog_name_filter_;
  _impl_.catalog_name_filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exec::user::LikeFilter* GetSchemasReq::unsafe_arena_release_catalog_name_filter() {
  // @@protoc_insertion_point(field_release:exec.user.GetSchemasReq.catalog_name_filter)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::exec::user::LikeFilter* temp = _impl_.catalog_name_filter_;
  _impl_.catalog_name_filter_ = nullptr;
  return temp;
}
inline ::exec::user::LikeFilter* GetSchemasReq::_internal_mutable_catalog_name_filter() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.catalog_name_filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::exec::user::LikeFilter>(GetArenaForAllocation());
    _impl_.catalog_name_filter_ = p;
  }
  return _impl_.catalog_name_filter_;
}
inline ::exec::user::LikeFilter* GetSchemasReq::mutable_catalog_name_filter() {
  ::exec::user::LikeFilter* _msg = _internal_mutable_catalog_name_filter();
  // @@protoc_insertion_point(field_mutable:exec.user.GetSchemasReq.catalog_name_filter)
  return _msg;
}
inline void GetSchemasReq::set_allocated_catalog_name_filter(::exec::user::LikeFilter* catalog_name_filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.catalog_name_filter_;
  }
  if (catalog_name_filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(catalog_name_filter);
    if (message_arena != submessage_arena) {
      catalog_name_filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, catalog_name_filter, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.catalog_name_filter_ = catalog_name_filter;
  // @@protoc_insertion_point(field_set_allocated:exec.user.GetSchemasReq.catalog_name_filter)
}

// optional .exec.user.LikeFilter schema_name_filter = 2;
inline bool GetSchemasReq::has_schema_name_filter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.schema_name_filter_ != nullptr);
  return value;
}
inline void GetSchemasReq::clear_schema_name_filter() {
  if (_impl_.schema_name_filter_ != nullptr) _impl_.schema_name_filter_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::exec::user::LikeFilter& GetSchemasReq::_internal_schema_name_filter() const {
  const ::exec::user::LikeFilter* p = _impl_.schema_name_filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::exec::user::LikeFilter&>(
      ::exec::user::_LikeFilter_default_instance_);
}
inline const ::exec::user::LikeFilter& GetSchemasReq::schema_name_filter() const {
  // @@protoc_insertion_point(field_get:exec.user.GetSchemasReq.schema_name_filter)
  return _internal_schema_name_filter();
}
inline void GetSchemasReq::unsafe_arena_set_allocated_schema_name_filter(
    ::exec::user::LikeFilter* schema_name_filter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.schema_name_filter_);
  }
  _impl_.schema_name_filter_ = schema_name_filter;
  if (schema_name_filter) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:exec.user.GetSchemasReq.schema_name_filter)
}
inline ::exec::user::LikeFilter* GetSchemasReq::release_schema_name_filter() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::exec::user::LikeFilter* temp = _impl_.schema_name_filter_;
  _impl_.schema_name_filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exec::user::LikeFilter* GetSchemasReq::unsafe_arena_release_schema_name_filter() {
  // @@protoc_insertion_point(field_release:exec.user.GetSchemasReq.schema_name_filter)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::exec::user::LikeFilter* temp = _impl_.schema_name_filter_;
  _impl_.schema_name_filter_ = nullptr;
  return temp;
}
inline ::exec::user::LikeFilter* GetSchemasReq::_internal_mutable_schema_name_filter() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.schema_name_filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::exec::user::LikeFilter>(GetArenaForAllocation());
    _impl_.schema_name_filter_ = p;
  }
  return _impl_.schema_name_filter_;
}
inline ::exec::user::LikeFilter* GetSchemasReq::mutable_schema_name_filter() {
  ::exec::user::LikeFilter* _msg = _internal_mutable_schema_name_filter();
  // @@protoc_insertion_point(field_mutable:exec.user.GetSchemasReq.schema_name_filter)
  return _msg;
}
inline void GetSchemasReq::set_allocated_schema_name_filter(::exec::user::LikeFilter* schema_name_filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.schema_name_filter_;
  }
  if (schema_name_filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(schema_name_filter);
    if (message_arena != submessage_arena) {
      schema_name_filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, schema_name_filter, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.schema_name_filter_ = schema_name_filter;
  // @@protoc_insertion_point(field_set_allocated:exec.user.GetSchemasReq.schema_name_filter)
}

// -------------------------------------------------------------------

// SchemaMetadata

// optional string catalog_name = 1;
inline bool SchemaMetadata::has_catalog_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SchemaMetadata::clear_catalog_name() {
  _impl_.catalog_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SchemaMetadata::catalog_name() const {
  // @@protoc_insertion_point(field_get:exec.user.SchemaMetadata.catalog_name)
  return _internal_catalog_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SchemaMetadata::set_catalog_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.catalog_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.user.SchemaMetadata.catalog_name)
}
inline std::string* SchemaMetadata::mutable_catalog_name() {
  std::string* _s = _internal_mutable_catalog_name();
  // @@protoc_insertion_point(field_mutable:exec.user.SchemaMetadata.catalog_name)
  return _s;
}
inline const std::string& SchemaMetadata::_internal_catalog_name() const {
  return _impl_.catalog_name_.Get();
}
inline void SchemaMetadata::_internal_set_catalog_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.catalog_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SchemaMetadata::_internal_mutable_catalog_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.catalog_name_.Mutable( GetArenaForAllocation());
}
inline std::string* SchemaMetadata::release_catalog_name() {
  // @@protoc_insertion_point(field_release:exec.user.SchemaMetadata.catalog_name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.catalog_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.catalog_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SchemaMetadata::set_allocated_catalog_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.catalog_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.catalog_name_.IsDefault()) {
          _impl_.catalog_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.user.SchemaMetadata.catalog_name)
}

// optional string schema_name = 2;
inline bool SchemaMetadata::has_schema_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SchemaMetadata::clear_schema_name() {
  _impl_.schema_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SchemaMetadata::schema_name() const {
  // @@protoc_insertion_point(field_get:exec.user.SchemaMetadata.schema_name)
  return _internal_schema_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SchemaMetadata::set_schema_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.schema_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.user.SchemaMetadata.schema_name)
}
inline std::string* SchemaMetadata::mutable_schema_name() {
  std::string* _s = _internal_mutable_schema_name();
  // @@protoc_insertion_point(field_mutable:exec.user.SchemaMetadata.schema_name)
  return _s;
}
inline const std::string& SchemaMetadata::_internal_schema_name() const {
  return _impl_.schema_name_.Get();
}
inline void SchemaMetadata::_internal_set_schema_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.schema_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SchemaMetadata::_internal_mutable_schema_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.schema_name_.Mutable( GetArenaForAllocation());
}
inline std::string* SchemaMetadata::release_schema_name() {
  // @@protoc_insertion_point(field_release:exec.user.SchemaMetadata.schema_name)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.schema_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.schema_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SchemaMetadata::set_allocated_schema_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.schema_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.schema_name_.IsDefault()) {
          _impl_.schema_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.user.SchemaMetadata.schema_name)
}

// optional string owner = 3;
inline bool SchemaMetadata::has_owner() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SchemaMetadata::clear_owner() {
  _impl_.owner_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& SchemaMetadata::owner() const {
  // @@protoc_insertion_point(field_get:exec.user.SchemaMetadata.owner)
  return _internal_owner();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SchemaMetadata::set_owner(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.owner_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.user.SchemaMetadata.owner)
}
inline std::string* SchemaMetadata::mutable_owner() {
  std::string* _s = _internal_mutable_owner();
  // @@protoc_insertion_point(field_mutable:exec.user.SchemaMetadata.owner)
  return _s;
}
inline const std::string& SchemaMetadata::_internal_owner() const {
  return _impl_.owner_.Get();
}
inline void SchemaMetadata::_internal_set_owner(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;


  _impl_.owner_.Set(value, GetArenaForAllocation());
}
inline std::string* SchemaMetadata::_internal_mutable_owner() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.owner_.Mutable( GetArenaForAllocation());
}
inline std::string* SchemaMetadata::release_owner() {
  // @@protoc_insertion_point(field_release:exec.user.SchemaMetadata.owner)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.owner_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.owner_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SchemaMetadata::set_allocated_owner(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.owner_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.owner_.IsDefault()) {
          _impl_.owner_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.user.SchemaMetadata.owner)
}

// optional string type = 4;
inline bool SchemaMetadata::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void SchemaMetadata::clear_type() {
  _impl_.type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& SchemaMetadata::type() const {
  // @@protoc_insertion_point(field_get:exec.user.SchemaMetadata.type)
  return _internal_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SchemaMetadata::set_type(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.type_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.user.SchemaMetadata.type)
}
inline std::string* SchemaMetadata::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:exec.user.SchemaMetadata.type)
  return _s;
}
inline const std::string& SchemaMetadata::_internal_type() const {
  return _impl_.type_.Get();
}
inline void SchemaMetadata::_internal_set_type(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;


  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* SchemaMetadata::_internal_mutable_type() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.type_.Mutable( GetArenaForAllocation());
}
inline std::string* SchemaMetadata::release_type() {
  // @@protoc_insertion_point(field_release:exec.user.SchemaMetadata.type)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.type_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.type_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SchemaMetadata::set_allocated_type(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.type_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.type_.IsDefault()) {
          _impl_.type_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.user.SchemaMetadata.type)
}

// optional string mutable = 5;
inline bool SchemaMetadata::has_mutable_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void SchemaMetadata::clear_mutable_() {
  _impl_.mutable__.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& SchemaMetadata::mutable_() const {
  // @@protoc_insertion_point(field_get:exec.user.SchemaMetadata.mutable)
  return _internal_mutable_();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SchemaMetadata::set_mutable_(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.mutable__.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.user.SchemaMetadata.mutable)
}
inline std::string* SchemaMetadata::mutable_mutable_() {
  std::string* _s = _internal_mutable_mutable_();
  // @@protoc_insertion_point(field_mutable:exec.user.SchemaMetadata.mutable)
  return _s;
}
inline const std::string& SchemaMetadata::_internal_mutable_() const {
  return _impl_.mutable__.Get();
}
inline void SchemaMetadata::_internal_set_mutable_(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;


  _impl_.mutable__.Set(value, GetArenaForAllocation());
}
inline std::string* SchemaMetadata::_internal_mutable_mutable_() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.mutable__.Mutable( GetArenaForAllocation());
}
inline std::string* SchemaMetadata::release_mutable_() {
  // @@protoc_insertion_point(field_release:exec.user.SchemaMetadata.mutable)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.mutable__.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.mutable__.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SchemaMetadata::set_allocated_mutable_(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.mutable__.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.mutable__.IsDefault()) {
          _impl_.mutable__.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.user.SchemaMetadata.mutable)
}

// -------------------------------------------------------------------

// GetSchemasResp

// optional .exec.user.RequestStatus status = 1;
inline bool GetSchemasResp::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void GetSchemasResp::clear_status() {
  _impl_.status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::exec::user::RequestStatus GetSchemasResp::status() const {
  // @@protoc_insertion_point(field_get:exec.user.GetSchemasResp.status)
  return _internal_status();
}
inline void GetSchemasResp::set_status(::exec::user::RequestStatus value) {
   _internal_set_status(value);
  // @@protoc_insertion_point(field_set:exec.user.GetSchemasResp.status)
}
inline ::exec::user::RequestStatus GetSchemasResp::_internal_status() const {
  return static_cast<::exec::user::RequestStatus>(_impl_.status_);
}
inline void GetSchemasResp::_internal_set_status(::exec::user::RequestStatus value) {
  assert(::exec::user::RequestStatus_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.status_ = value;
}

// repeated .exec.user.SchemaMetadata schemas = 2;
inline int GetSchemasResp::_internal_schemas_size() const {
  return _impl_.schemas_.size();
}
inline int GetSchemasResp::schemas_size() const {
  return _internal_schemas_size();
}
inline void GetSchemasResp::clear_schemas() {
  _impl_.schemas_.Clear();
}
inline ::exec::user::SchemaMetadata* GetSchemasResp::mutable_schemas(int index) {
  // @@protoc_insertion_point(field_mutable:exec.user.GetSchemasResp.schemas)
  return _impl_.schemas_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::user::SchemaMetadata >*
GetSchemasResp::mutable_schemas() {
  // @@protoc_insertion_point(field_mutable_list:exec.user.GetSchemasResp.schemas)
  return &_impl_.schemas_;
}
inline const ::exec::user::SchemaMetadata& GetSchemasResp::_internal_schemas(int index) const {
  return _impl_.schemas_.Get(index);
}
inline const ::exec::user::SchemaMetadata& GetSchemasResp::schemas(int index) const {
  // @@protoc_insertion_point(field_get:exec.user.GetSchemasResp.schemas)
  return _internal_schemas(index);
}
inline ::exec::user::SchemaMetadata* GetSchemasResp::_internal_add_schemas() {
  return _impl_.schemas_.Add();
}
inline ::exec::user::SchemaMetadata* GetSchemasResp::add_schemas() {
  ::exec::user::SchemaMetadata* _add = _internal_add_schemas();
  // @@protoc_insertion_point(field_add:exec.user.GetSchemasResp.schemas)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::user::SchemaMetadata >&
GetSchemasResp::schemas() const {
  // @@protoc_insertion_point(field_list:exec.user.GetSchemasResp.schemas)
  return _impl_.schemas_;
}

// optional .exec.shared.DrillPBError error = 3;
inline bool GetSchemasResp::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_ != nullptr);
  return value;
}
inline const ::exec::shared::DrillPBError& GetSchemasResp::_internal_error() const {
  const ::exec::shared::DrillPBError* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::exec::shared::DrillPBError&>(
      ::exec::shared::_DrillPBError_default_instance_);
}
inline const ::exec::shared::DrillPBError& GetSchemasResp::error() const {
  // @@protoc_insertion_point(field_get:exec.user.GetSchemasResp.error)
  return _internal_error();
}
inline void GetSchemasResp::unsafe_arena_set_allocated_error(
    ::exec::shared::DrillPBError* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:exec.user.GetSchemasResp.error)
}
inline ::exec::shared::DrillPBError* GetSchemasResp::release_error() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::exec::shared::DrillPBError* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exec::shared::DrillPBError* GetSchemasResp::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:exec.user.GetSchemasResp.error)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::exec::shared::DrillPBError* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::exec::shared::DrillPBError* GetSchemasResp::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::exec::shared::DrillPBError>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::exec::shared::DrillPBError* GetSchemasResp::mutable_error() {
  ::exec::shared::DrillPBError* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:exec.user.GetSchemasResp.error)
  return _msg;
}
inline void GetSchemasResp::set_allocated_error(::exec::shared::DrillPBError* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(error));
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:exec.user.GetSchemasResp.error)
}

// -------------------------------------------------------------------

// GetTablesReq

// optional .exec.user.LikeFilter catalog_name_filter = 1;
inline bool GetTablesReq::has_catalog_name_filter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.catalog_name_filter_ != nullptr);
  return value;
}
inline void GetTablesReq::clear_catalog_name_filter() {
  if (_impl_.catalog_name_filter_ != nullptr) _impl_.catalog_name_filter_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::exec::user::LikeFilter& GetTablesReq::_internal_catalog_name_filter() const {
  const ::exec::user::LikeFilter* p = _impl_.catalog_name_filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::exec::user::LikeFilter&>(
      ::exec::user::_LikeFilter_default_instance_);
}
inline const ::exec::user::LikeFilter& GetTablesReq::catalog_name_filter() const {
  // @@protoc_insertion_point(field_get:exec.user.GetTablesReq.catalog_name_filter)
  return _internal_catalog_name_filter();
}
inline void GetTablesReq::unsafe_arena_set_allocated_catalog_name_filter(
    ::exec::user::LikeFilter* catalog_name_filter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.catalog_name_filter_);
  }
  _impl_.catalog_name_filter_ = catalog_name_filter;
  if (catalog_name_filter) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:exec.user.GetTablesReq.catalog_name_filter)
}
inline ::exec::user::LikeFilter* GetTablesReq::release_catalog_name_filter() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::exec::user::LikeFilter* temp = _impl_.catalog_name_filter_;
  _impl_.catalog_name_filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exec::user::LikeFilter* GetTablesReq::unsafe_arena_release_catalog_name_filter() {
  // @@protoc_insertion_point(field_release:exec.user.GetTablesReq.catalog_name_filter)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::exec::user::LikeFilter* temp = _impl_.catalog_name_filter_;
  _impl_.catalog_name_filter_ = nullptr;
  return temp;
}
inline ::exec::user::LikeFilter* GetTablesReq::_internal_mutable_catalog_name_filter() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.catalog_name_filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::exec::user::LikeFilter>(GetArenaForAllocation());
    _impl_.catalog_name_filter_ = p;
  }
  return _impl_.catalog_name_filter_;
}
inline ::exec::user::LikeFilter* GetTablesReq::mutable_catalog_name_filter() {
  ::exec::user::LikeFilter* _msg = _internal_mutable_catalog_name_filter();
  // @@protoc_insertion_point(field_mutable:exec.user.GetTablesReq.catalog_name_filter)
  return _msg;
}
inline void GetTablesReq::set_allocated_catalog_name_filter(::exec::user::LikeFilter* catalog_name_filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.catalog_name_filter_;
  }
  if (catalog_name_filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(catalog_name_filter);
    if (message_arena != submessage_arena) {
      catalog_name_filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, catalog_name_filter, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.catalog_name_filter_ = catalog_name_filter;
  // @@protoc_insertion_point(field_set_allocated:exec.user.GetTablesReq.catalog_name_filter)
}

// optional .exec.user.LikeFilter schema_name_filter = 2;
inline bool GetTablesReq::has_schema_name_filter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.schema_name_filter_ != nullptr);
  return value;
}
inline void GetTablesReq::clear_schema_name_filter() {
  if (_impl_.schema_name_filter_ != nullptr) _impl_.schema_name_filter_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::exec::user::LikeFilter& GetTablesReq::_internal_schema_name_filter() const {
  const ::exec::user::LikeFilter* p = _impl_.schema_name_filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::exec::user::LikeFilter&>(
      ::exec::user::_LikeFilter_default_instance_);
}
inline const ::exec::user::LikeFilter& GetTablesReq::schema_name_filter() const {
  // @@protoc_insertion_point(field_get:exec.user.GetTablesReq.schema_name_filter)
  return _internal_schema_name_filter();
}
inline void GetTablesReq::unsafe_arena_set_allocated_schema_name_filter(
    ::exec::user::LikeFilter* schema_name_filter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.schema_name_filter_);
  }
  _impl_.schema_name_filter_ = schema_name_filter;
  if (schema_name_filter) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:exec.user.GetTablesReq.schema_name_filter)
}
inline ::exec::user::LikeFilter* GetTablesReq::release_schema_name_filter() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::exec::user::LikeFilter* temp = _impl_.schema_name_filter_;
  _impl_.schema_name_filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exec::user::LikeFilter* GetTablesReq::unsafe_arena_release_schema_name_filter() {
  // @@protoc_insertion_point(field_release:exec.user.GetTablesReq.schema_name_filter)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::exec::user::LikeFilter* temp = _impl_.schema_name_filter_;
  _impl_.schema_name_filter_ = nullptr;
  return temp;
}
inline ::exec::user::LikeFilter* GetTablesReq::_internal_mutable_schema_name_filter() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.schema_name_filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::exec::user::LikeFilter>(GetArenaForAllocation());
    _impl_.schema_name_filter_ = p;
  }
  return _impl_.schema_name_filter_;
}
inline ::exec::user::LikeFilter* GetTablesReq::mutable_schema_name_filter() {
  ::exec::user::LikeFilter* _msg = _internal_mutable_schema_name_filter();
  // @@protoc_insertion_point(field_mutable:exec.user.GetTablesReq.schema_name_filter)
  return _msg;
}
inline void GetTablesReq::set_allocated_schema_name_filter(::exec::user::LikeFilter* schema_name_filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.schema_name_filter_;
  }
  if (schema_name_filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(schema_name_filter);
    if (message_arena != submessage_arena) {
      schema_name_filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, schema_name_filter, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.schema_name_filter_ = schema_name_filter;
  // @@protoc_insertion_point(field_set_allocated:exec.user.GetTablesReq.schema_name_filter)
}

// optional .exec.user.LikeFilter table_name_filter = 3;
inline bool GetTablesReq::has_table_name_filter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.table_name_filter_ != nullptr);
  return value;
}
inline void GetTablesReq::clear_table_name_filter() {
  if (_impl_.table_name_filter_ != nullptr) _impl_.table_name_filter_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::exec::user::LikeFilter& GetTablesReq::_internal_table_name_filter() const {
  const ::exec::user::LikeFilter* p = _impl_.table_name_filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::exec::user::LikeFilter&>(
      ::exec::user::_LikeFilter_default_instance_);
}
inline const ::exec::user::LikeFilter& GetTablesReq::table_name_filter() const {
  // @@protoc_insertion_point(field_get:exec.user.GetTablesReq.table_name_filter)
  return _internal_table_name_filter();
}
inline void GetTablesReq::unsafe_arena_set_allocated_table_name_filter(
    ::exec::user::LikeFilter* table_name_filter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.table_name_filter_);
  }
  _impl_.table_name_filter_ = table_name_filter;
  if (table_name_filter) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:exec.user.GetTablesReq.table_name_filter)
}
inline ::exec::user::LikeFilter* GetTablesReq::release_table_name_filter() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::exec::user::LikeFilter* temp = _impl_.table_name_filter_;
  _impl_.table_name_filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exec::user::LikeFilter* GetTablesReq::unsafe_arena_release_table_name_filter() {
  // @@protoc_insertion_point(field_release:exec.user.GetTablesReq.table_name_filter)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::exec::user::LikeFilter* temp = _impl_.table_name_filter_;
  _impl_.table_name_filter_ = nullptr;
  return temp;
}
inline ::exec::user::LikeFilter* GetTablesReq::_internal_mutable_table_name_filter() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.table_name_filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::exec::user::LikeFilter>(GetArenaForAllocation());
    _impl_.table_name_filter_ = p;
  }
  return _impl_.table_name_filter_;
}
inline ::exec::user::LikeFilter* GetTablesReq::mutable_table_name_filter() {
  ::exec::user::LikeFilter* _msg = _internal_mutable_table_name_filter();
  // @@protoc_insertion_point(field_mutable:exec.user.GetTablesReq.table_name_filter)
  return _msg;
}
inline void GetTablesReq::set_allocated_table_name_filter(::exec::user::LikeFilter* table_name_filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.table_name_filter_;
  }
  if (table_name_filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(table_name_filter);
    if (message_arena != submessage_arena) {
      table_name_filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table_name_filter, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.table_name_filter_ = table_name_filter;
  // @@protoc_insertion_point(field_set_allocated:exec.user.GetTablesReq.table_name_filter)
}

// repeated string table_type_filter = 4;
inline int GetTablesReq::_internal_table_type_filter_size() const {
  return _impl_.table_type_filter_.size();
}
inline int GetTablesReq::table_type_filter_size() const {
  return _internal_table_type_filter_size();
}
inline void GetTablesReq::clear_table_type_filter() {
  _impl_.table_type_filter_.Clear();
}
inline std::string* GetTablesReq::add_table_type_filter() {
  std::string* _s = _internal_add_table_type_filter();
  // @@protoc_insertion_point(field_add_mutable:exec.user.GetTablesReq.table_type_filter)
  return _s;
}
inline const std::string& GetTablesReq::_internal_table_type_filter(int index) const {
  return _impl_.table_type_filter_.Get(index);
}
inline const std::string& GetTablesReq::table_type_filter(int index) const {
  // @@protoc_insertion_point(field_get:exec.user.GetTablesReq.table_type_filter)
  return _internal_table_type_filter(index);
}
inline std::string* GetTablesReq::mutable_table_type_filter(int index) {
  // @@protoc_insertion_point(field_mutable:exec.user.GetTablesReq.table_type_filter)
  return _impl_.table_type_filter_.Mutable(index);
}
inline void GetTablesReq::set_table_type_filter(int index, const std::string& value) {
  _impl_.table_type_filter_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:exec.user.GetTablesReq.table_type_filter)
}
inline void GetTablesReq::set_table_type_filter(int index, std::string&& value) {
  _impl_.table_type_filter_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:exec.user.GetTablesReq.table_type_filter)
}
inline void GetTablesReq::set_table_type_filter(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _impl_.table_type_filter_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:exec.user.GetTablesReq.table_type_filter)
}
inline void GetTablesReq::set_table_type_filter(int index, const char* value,
                              std::size_t size) {
  _impl_.table_type_filter_.Mutable(index)->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:exec.user.GetTablesReq.table_type_filter)
}
inline void GetTablesReq::set_table_type_filter(int index, absl::string_view value) {
  _impl_.table_type_filter_.Mutable(index)->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:exec.user.GetTablesReq.table_type_filter)
}
inline std::string* GetTablesReq::_internal_add_table_type_filter() { return _impl_.table_type_filter_.Add(); }
inline void GetTablesReq::add_table_type_filter(const std::string& value) {
  _impl_.table_type_filter_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:exec.user.GetTablesReq.table_type_filter)
}
inline void GetTablesReq::add_table_type_filter(std::string&& value) {
  _impl_.table_type_filter_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:exec.user.GetTablesReq.table_type_filter)
}
inline void GetTablesReq::add_table_type_filter(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _impl_.table_type_filter_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:exec.user.GetTablesReq.table_type_filter)
}
inline void GetTablesReq::add_table_type_filter(const char* value, std::size_t size) {
  _impl_.table_type_filter_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:exec.user.GetTablesReq.table_type_filter)
}
inline void GetTablesReq::add_table_type_filter(absl::string_view value) {
  _impl_.table_type_filter_.Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:exec.user.GetTablesReq.table_type_filter)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetTablesReq::table_type_filter() const {
  // @@protoc_insertion_point(field_list:exec.user.GetTablesReq.table_type_filter)
  return _impl_.table_type_filter_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* GetTablesReq::mutable_table_type_filter() {
  // @@protoc_insertion_point(field_mutable_list:exec.user.GetTablesReq.table_type_filter)
  return &_impl_.table_type_filter_;
}

// -------------------------------------------------------------------

// TableMetadata

// optional string catalog_name = 1;
inline bool TableMetadata::has_catalog_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TableMetadata::clear_catalog_name() {
  _impl_.catalog_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TableMetadata::catalog_name() const {
  // @@protoc_insertion_point(field_get:exec.user.TableMetadata.catalog_name)
  return _internal_catalog_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TableMetadata::set_catalog_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.catalog_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.user.TableMetadata.catalog_name)
}
inline std::string* TableMetadata::mutable_catalog_name() {
  std::string* _s = _internal_mutable_catalog_name();
  // @@protoc_insertion_point(field_mutable:exec.user.TableMetadata.catalog_name)
  return _s;
}
inline const std::string& TableMetadata::_internal_catalog_name() const {
  return _impl_.catalog_name_.Get();
}
inline void TableMetadata::_internal_set_catalog_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.catalog_name_.Set(value, GetArenaForAllocation());
}
inline std::string* TableMetadata::_internal_mutable_catalog_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.catalog_name_.Mutable( GetArenaForAllocation());
}
inline std::string* TableMetadata::release_catalog_name() {
  // @@protoc_insertion_point(field_release:exec.user.TableMetadata.catalog_name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.catalog_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.catalog_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TableMetadata::set_allocated_catalog_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.catalog_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.catalog_name_.IsDefault()) {
          _impl_.catalog_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.user.TableMetadata.catalog_name)
}

// optional string schema_name = 2;
inline bool TableMetadata::has_schema_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void TableMetadata::clear_schema_name() {
  _impl_.schema_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TableMetadata::schema_name() const {
  // @@protoc_insertion_point(field_get:exec.user.TableMetadata.schema_name)
  return _internal_schema_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TableMetadata::set_schema_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.schema_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.user.TableMetadata.schema_name)
}
inline std::string* TableMetadata::mutable_schema_name() {
  std::string* _s = _internal_mutable_schema_name();
  // @@protoc_insertion_point(field_mutable:exec.user.TableMetadata.schema_name)
  return _s;
}
inline const std::string& TableMetadata::_internal_schema_name() const {
  return _impl_.schema_name_.Get();
}
inline void TableMetadata::_internal_set_schema_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.schema_name_.Set(value, GetArenaForAllocation());
}
inline std::string* TableMetadata::_internal_mutable_schema_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.schema_name_.Mutable( GetArenaForAllocation());
}
inline std::string* TableMetadata::release_schema_name() {
  // @@protoc_insertion_point(field_release:exec.user.TableMetadata.schema_name)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.schema_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.schema_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TableMetadata::set_allocated_schema_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.schema_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.schema_name_.IsDefault()) {
          _impl_.schema_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.user.TableMetadata.schema_name)
}

// optional string table_name = 3;
inline bool TableMetadata::has_table_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void TableMetadata::clear_table_name() {
  _impl_.table_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& TableMetadata::table_name() const {
  // @@protoc_insertion_point(field_get:exec.user.TableMetadata.table_name)
  return _internal_table_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TableMetadata::set_table_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.table_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.user.TableMetadata.table_name)
}
inline std::string* TableMetadata::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:exec.user.TableMetadata.table_name)
  return _s;
}
inline const std::string& TableMetadata::_internal_table_name() const {
  return _impl_.table_name_.Get();
}
inline void TableMetadata::_internal_set_table_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;


  _impl_.table_name_.Set(value, GetArenaForAllocation());
}
inline std::string* TableMetadata::_internal_mutable_table_name() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.table_name_.Mutable( GetArenaForAllocation());
}
inline std::string* TableMetadata::release_table_name() {
  // @@protoc_insertion_point(field_release:exec.user.TableMetadata.table_name)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.table_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.table_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TableMetadata::set_allocated_table_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.table_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.table_name_.IsDefault()) {
          _impl_.table_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.user.TableMetadata.table_name)
}

// optional string type = 4;
inline bool TableMetadata::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void TableMetadata::clear_type() {
  _impl_.type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& TableMetadata::type() const {
  // @@protoc_insertion_point(field_get:exec.user.TableMetadata.type)
  return _internal_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TableMetadata::set_type(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.type_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.user.TableMetadata.type)
}
inline std::string* TableMetadata::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:exec.user.TableMetadata.type)
  return _s;
}
inline const std::string& TableMetadata::_internal_type() const {
  return _impl_.type_.Get();
}
inline void TableMetadata::_internal_set_type(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;


  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* TableMetadata::_internal_mutable_type() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.type_.Mutable( GetArenaForAllocation());
}
inline std::string* TableMetadata::release_type() {
  // @@protoc_insertion_point(field_release:exec.user.TableMetadata.type)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.type_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.type_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TableMetadata::set_allocated_type(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.type_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.type_.IsDefault()) {
          _impl_.type_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.user.TableMetadata.type)
}

// -------------------------------------------------------------------

// GetTablesResp

// optional .exec.user.RequestStatus status = 1;
inline bool GetTablesResp::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void GetTablesResp::clear_status() {
  _impl_.status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::exec::user::RequestStatus GetTablesResp::status() const {
  // @@protoc_insertion_point(field_get:exec.user.GetTablesResp.status)
  return _internal_status();
}
inline void GetTablesResp::set_status(::exec::user::RequestStatus value) {
   _internal_set_status(value);
  // @@protoc_insertion_point(field_set:exec.user.GetTablesResp.status)
}
inline ::exec::user::RequestStatus GetTablesResp::_internal_status() const {
  return static_cast<::exec::user::RequestStatus>(_impl_.status_);
}
inline void GetTablesResp::_internal_set_status(::exec::user::RequestStatus value) {
  assert(::exec::user::RequestStatus_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.status_ = value;
}

// repeated .exec.user.TableMetadata tables = 2;
inline int GetTablesResp::_internal_tables_size() const {
  return _impl_.tables_.size();
}
inline int GetTablesResp::tables_size() const {
  return _internal_tables_size();
}
inline void GetTablesResp::clear_tables() {
  _impl_.tables_.Clear();
}
inline ::exec::user::TableMetadata* GetTablesResp::mutable_tables(int index) {
  // @@protoc_insertion_point(field_mutable:exec.user.GetTablesResp.tables)
  return _impl_.tables_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::user::TableMetadata >*
GetTablesResp::mutable_tables() {
  // @@protoc_insertion_point(field_mutable_list:exec.user.GetTablesResp.tables)
  return &_impl_.tables_;
}
inline const ::exec::user::TableMetadata& GetTablesResp::_internal_tables(int index) const {
  return _impl_.tables_.Get(index);
}
inline const ::exec::user::TableMetadata& GetTablesResp::tables(int index) const {
  // @@protoc_insertion_point(field_get:exec.user.GetTablesResp.tables)
  return _internal_tables(index);
}
inline ::exec::user::TableMetadata* GetTablesResp::_internal_add_tables() {
  return _impl_.tables_.Add();
}
inline ::exec::user::TableMetadata* GetTablesResp::add_tables() {
  ::exec::user::TableMetadata* _add = _internal_add_tables();
  // @@protoc_insertion_point(field_add:exec.user.GetTablesResp.tables)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::user::TableMetadata >&
GetTablesResp::tables() const {
  // @@protoc_insertion_point(field_list:exec.user.GetTablesResp.tables)
  return _impl_.tables_;
}

// optional .exec.shared.DrillPBError error = 3;
inline bool GetTablesResp::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_ != nullptr);
  return value;
}
inline const ::exec::shared::DrillPBError& GetTablesResp::_internal_error() const {
  const ::exec::shared::DrillPBError* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::exec::shared::DrillPBError&>(
      ::exec::shared::_DrillPBError_default_instance_);
}
inline const ::exec::shared::DrillPBError& GetTablesResp::error() const {
  // @@protoc_insertion_point(field_get:exec.user.GetTablesResp.error)
  return _internal_error();
}
inline void GetTablesResp::unsafe_arena_set_allocated_error(
    ::exec::shared::DrillPBError* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:exec.user.GetTablesResp.error)
}
inline ::exec::shared::DrillPBError* GetTablesResp::release_error() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::exec::shared::DrillPBError* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exec::shared::DrillPBError* GetTablesResp::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:exec.user.GetTablesResp.error)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::exec::shared::DrillPBError* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::exec::shared::DrillPBError* GetTablesResp::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::exec::shared::DrillPBError>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::exec::shared::DrillPBError* GetTablesResp::mutable_error() {
  ::exec::shared::DrillPBError* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:exec.user.GetTablesResp.error)
  return _msg;
}
inline void GetTablesResp::set_allocated_error(::exec::shared::DrillPBError* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(error));
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:exec.user.GetTablesResp.error)
}

// -------------------------------------------------------------------

// GetColumnsReq

// optional .exec.user.LikeFilter catalog_name_filter = 1;
inline bool GetColumnsReq::has_catalog_name_filter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.catalog_name_filter_ != nullptr);
  return value;
}
inline void GetColumnsReq::clear_catalog_name_filter() {
  if (_impl_.catalog_name_filter_ != nullptr) _impl_.catalog_name_filter_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::exec::user::LikeFilter& GetColumnsReq::_internal_catalog_name_filter() const {
  const ::exec::user::LikeFilter* p = _impl_.catalog_name_filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::exec::user::LikeFilter&>(
      ::exec::user::_LikeFilter_default_instance_);
}
inline const ::exec::user::LikeFilter& GetColumnsReq::catalog_name_filter() const {
  // @@protoc_insertion_point(field_get:exec.user.GetColumnsReq.catalog_name_filter)
  return _internal_catalog_name_filter();
}
inline void GetColumnsReq::unsafe_arena_set_allocated_catalog_name_filter(
    ::exec::user::LikeFilter* catalog_name_filter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.catalog_name_filter_);
  }
  _impl_.catalog_name_filter_ = catalog_name_filter;
  if (catalog_name_filter) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:exec.user.GetColumnsReq.catalog_name_filter)
}
inline ::exec::user::LikeFilter* GetColumnsReq::release_catalog_name_filter() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::exec::user::LikeFilter* temp = _impl_.catalog_name_filter_;
  _impl_.catalog_name_filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exec::user::LikeFilter* GetColumnsReq::unsafe_arena_release_catalog_name_filter() {
  // @@protoc_insertion_point(field_release:exec.user.GetColumnsReq.catalog_name_filter)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::exec::user::LikeFilter* temp = _impl_.catalog_name_filter_;
  _impl_.catalog_name_filter_ = nullptr;
  return temp;
}
inline ::exec::user::LikeFilter* GetColumnsReq::_internal_mutable_catalog_name_filter() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.catalog_name_filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::exec::user::LikeFilter>(GetArenaForAllocation());
    _impl_.catalog_name_filter_ = p;
  }
  return _impl_.catalog_name_filter_;
}
inline ::exec::user::LikeFilter* GetColumnsReq::mutable_catalog_name_filter() {
  ::exec::user::LikeFilter* _msg = _internal_mutable_catalog_name_filter();
  // @@protoc_insertion_point(field_mutable:exec.user.GetColumnsReq.catalog_name_filter)
  return _msg;
}
inline void GetColumnsReq::set_allocated_catalog_name_filter(::exec::user::LikeFilter* catalog_name_filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.catalog_name_filter_;
  }
  if (catalog_name_filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(catalog_name_filter);
    if (message_arena != submessage_arena) {
      catalog_name_filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, catalog_name_filter, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.catalog_name_filter_ = catalog_name_filter;
  // @@protoc_insertion_point(field_set_allocated:exec.user.GetColumnsReq.catalog_name_filter)
}

// optional .exec.user.LikeFilter schema_name_filter = 2;
inline bool GetColumnsReq::has_schema_name_filter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.schema_name_filter_ != nullptr);
  return value;
}
inline void GetColumnsReq::clear_schema_name_filter() {
  if (_impl_.schema_name_filter_ != nullptr) _impl_.schema_name_filter_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::exec::user::LikeFilter& GetColumnsReq::_internal_schema_name_filter() const {
  const ::exec::user::LikeFilter* p = _impl_.schema_name_filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::exec::user::LikeFilter&>(
      ::exec::user::_LikeFilter_default_instance_);
}
inline const ::exec::user::LikeFilter& GetColumnsReq::schema_name_filter() const {
  // @@protoc_insertion_point(field_get:exec.user.GetColumnsReq.schema_name_filter)
  return _internal_schema_name_filter();
}
inline void GetColumnsReq::unsafe_arena_set_allocated_schema_name_filter(
    ::exec::user::LikeFilter* schema_name_filter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.schema_name_filter_);
  }
  _impl_.schema_name_filter_ = schema_name_filter;
  if (schema_name_filter) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:exec.user.GetColumnsReq.schema_name_filter)
}
inline ::exec::user::LikeFilter* GetColumnsReq::release_schema_name_filter() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::exec::user::LikeFilter* temp = _impl_.schema_name_filter_;
  _impl_.schema_name_filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exec::user::LikeFilter* GetColumnsReq::unsafe_arena_release_schema_name_filter() {
  // @@protoc_insertion_point(field_release:exec.user.GetColumnsReq.schema_name_filter)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::exec::user::LikeFilter* temp = _impl_.schema_name_filter_;
  _impl_.schema_name_filter_ = nullptr;
  return temp;
}
inline ::exec::user::LikeFilter* GetColumnsReq::_internal_mutable_schema_name_filter() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.schema_name_filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::exec::user::LikeFilter>(GetArenaForAllocation());
    _impl_.schema_name_filter_ = p;
  }
  return _impl_.schema_name_filter_;
}
inline ::exec::user::LikeFilter* GetColumnsReq::mutable_schema_name_filter() {
  ::exec::user::LikeFilter* _msg = _internal_mutable_schema_name_filter();
  // @@protoc_insertion_point(field_mutable:exec.user.GetColumnsReq.schema_name_filter)
  return _msg;
}
inline void GetColumnsReq::set_allocated_schema_name_filter(::exec::user::LikeFilter* schema_name_filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.schema_name_filter_;
  }
  if (schema_name_filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(schema_name_filter);
    if (message_arena != submessage_arena) {
      schema_name_filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, schema_name_filter, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.schema_name_filter_ = schema_name_filter;
  // @@protoc_insertion_point(field_set_allocated:exec.user.GetColumnsReq.schema_name_filter)
}

// optional .exec.user.LikeFilter table_name_filter = 3;
inline bool GetColumnsReq::has_table_name_filter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.table_name_filter_ != nullptr);
  return value;
}
inline void GetColumnsReq::clear_table_name_filter() {
  if (_impl_.table_name_filter_ != nullptr) _impl_.table_name_filter_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::exec::user::LikeFilter& GetColumnsReq::_internal_table_name_filter() const {
  const ::exec::user::LikeFilter* p = _impl_.table_name_filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::exec::user::LikeFilter&>(
      ::exec::user::_LikeFilter_default_instance_);
}
inline const ::exec::user::LikeFilter& GetColumnsReq::table_name_filter() const {
  // @@protoc_insertion_point(field_get:exec.user.GetColumnsReq.table_name_filter)
  return _internal_table_name_filter();
}
inline void GetColumnsReq::unsafe_arena_set_allocated_table_name_filter(
    ::exec::user::LikeFilter* table_name_filter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.table_name_filter_);
  }
  _impl_.table_name_filter_ = table_name_filter;
  if (table_name_filter) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:exec.user.GetColumnsReq.table_name_filter)
}
inline ::exec::user::LikeFilter* GetColumnsReq::release_table_name_filter() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::exec::user::LikeFilter* temp = _impl_.table_name_filter_;
  _impl_.table_name_filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exec::user::LikeFilter* GetColumnsReq::unsafe_arena_release_table_name_filter() {
  // @@protoc_insertion_point(field_release:exec.user.GetColumnsReq.table_name_filter)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::exec::user::LikeFilter* temp = _impl_.table_name_filter_;
  _impl_.table_name_filter_ = nullptr;
  return temp;
}
inline ::exec::user::LikeFilter* GetColumnsReq::_internal_mutable_table_name_filter() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.table_name_filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::exec::user::LikeFilter>(GetArenaForAllocation());
    _impl_.table_name_filter_ = p;
  }
  return _impl_.table_name_filter_;
}
inline ::exec::user::LikeFilter* GetColumnsReq::mutable_table_name_filter() {
  ::exec::user::LikeFilter* _msg = _internal_mutable_table_name_filter();
  // @@protoc_insertion_point(field_mutable:exec.user.GetColumnsReq.table_name_filter)
  return _msg;
}
inline void GetColumnsReq::set_allocated_table_name_filter(::exec::user::LikeFilter* table_name_filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.table_name_filter_;
  }
  if (table_name_filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(table_name_filter);
    if (message_arena != submessage_arena) {
      table_name_filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table_name_filter, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.table_name_filter_ = table_name_filter;
  // @@protoc_insertion_point(field_set_allocated:exec.user.GetColumnsReq.table_name_filter)
}

// optional .exec.user.LikeFilter column_name_filter = 4;
inline bool GetColumnsReq::has_column_name_filter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.column_name_filter_ != nullptr);
  return value;
}
inline void GetColumnsReq::clear_column_name_filter() {
  if (_impl_.column_name_filter_ != nullptr) _impl_.column_name_filter_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::exec::user::LikeFilter& GetColumnsReq::_internal_column_name_filter() const {
  const ::exec::user::LikeFilter* p = _impl_.column_name_filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::exec::user::LikeFilter&>(
      ::exec::user::_LikeFilter_default_instance_);
}
inline const ::exec::user::LikeFilter& GetColumnsReq::column_name_filter() const {
  // @@protoc_insertion_point(field_get:exec.user.GetColumnsReq.column_name_filter)
  return _internal_column_name_filter();
}
inline void GetColumnsReq::unsafe_arena_set_allocated_column_name_filter(
    ::exec::user::LikeFilter* column_name_filter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.column_name_filter_);
  }
  _impl_.column_name_filter_ = column_name_filter;
  if (column_name_filter) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:exec.user.GetColumnsReq.column_name_filter)
}
inline ::exec::user::LikeFilter* GetColumnsReq::release_column_name_filter() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::exec::user::LikeFilter* temp = _impl_.column_name_filter_;
  _impl_.column_name_filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exec::user::LikeFilter* GetColumnsReq::unsafe_arena_release_column_name_filter() {
  // @@protoc_insertion_point(field_release:exec.user.GetColumnsReq.column_name_filter)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::exec::user::LikeFilter* temp = _impl_.column_name_filter_;
  _impl_.column_name_filter_ = nullptr;
  return temp;
}
inline ::exec::user::LikeFilter* GetColumnsReq::_internal_mutable_column_name_filter() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.column_name_filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::exec::user::LikeFilter>(GetArenaForAllocation());
    _impl_.column_name_filter_ = p;
  }
  return _impl_.column_name_filter_;
}
inline ::exec::user::LikeFilter* GetColumnsReq::mutable_column_name_filter() {
  ::exec::user::LikeFilter* _msg = _internal_mutable_column_name_filter();
  // @@protoc_insertion_point(field_mutable:exec.user.GetColumnsReq.column_name_filter)
  return _msg;
}
inline void GetColumnsReq::set_allocated_column_name_filter(::exec::user::LikeFilter* column_name_filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.column_name_filter_;
  }
  if (column_name_filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(column_name_filter);
    if (message_arena != submessage_arena) {
      column_name_filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, column_name_filter, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.column_name_filter_ = column_name_filter;
  // @@protoc_insertion_point(field_set_allocated:exec.user.GetColumnsReq.column_name_filter)
}

// -------------------------------------------------------------------

// ColumnMetadata

// optional string catalog_name = 1;
inline bool ColumnMetadata::has_catalog_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ColumnMetadata::clear_catalog_name() {
  _impl_.catalog_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ColumnMetadata::catalog_name() const {
  // @@protoc_insertion_point(field_get:exec.user.ColumnMetadata.catalog_name)
  return _internal_catalog_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ColumnMetadata::set_catalog_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.catalog_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.user.ColumnMetadata.catalog_name)
}
inline std::string* ColumnMetadata::mutable_catalog_name() {
  std::string* _s = _internal_mutable_catalog_name();
  // @@protoc_insertion_point(field_mutable:exec.user.ColumnMetadata.catalog_name)
  return _s;
}
inline const std::string& ColumnMetadata::_internal_catalog_name() const {
  return _impl_.catalog_name_.Get();
}
inline void ColumnMetadata::_internal_set_catalog_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.catalog_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ColumnMetadata::_internal_mutable_catalog_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.catalog_name_.Mutable( GetArenaForAllocation());
}
inline std::string* ColumnMetadata::release_catalog_name() {
  // @@protoc_insertion_point(field_release:exec.user.ColumnMetadata.catalog_name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.catalog_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.catalog_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ColumnMetadata::set_allocated_catalog_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.catalog_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.catalog_name_.IsDefault()) {
          _impl_.catalog_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.user.ColumnMetadata.catalog_name)
}

// optional string schema_name = 2;
inline bool ColumnMetadata::has_schema_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ColumnMetadata::clear_schema_name() {
  _impl_.schema_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ColumnMetadata::schema_name() const {
  // @@protoc_insertion_point(field_get:exec.user.ColumnMetadata.schema_name)
  return _internal_schema_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ColumnMetadata::set_schema_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.schema_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.user.ColumnMetadata.schema_name)
}
inline std::string* ColumnMetadata::mutable_schema_name() {
  std::string* _s = _internal_mutable_schema_name();
  // @@protoc_insertion_point(field_mutable:exec.user.ColumnMetadata.schema_name)
  return _s;
}
inline const std::string& ColumnMetadata::_internal_schema_name() const {
  return _impl_.schema_name_.Get();
}
inline void ColumnMetadata::_internal_set_schema_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.schema_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ColumnMetadata::_internal_mutable_schema_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.schema_name_.Mutable( GetArenaForAllocation());
}
inline std::string* ColumnMetadata::release_schema_name() {
  // @@protoc_insertion_point(field_release:exec.user.ColumnMetadata.schema_name)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.schema_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.schema_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ColumnMetadata::set_allocated_schema_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.schema_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.schema_name_.IsDefault()) {
          _impl_.schema_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.user.ColumnMetadata.schema_name)
}

// optional string table_name = 3;
inline bool ColumnMetadata::has_table_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ColumnMetadata::clear_table_name() {
  _impl_.table_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ColumnMetadata::table_name() const {
  // @@protoc_insertion_point(field_get:exec.user.ColumnMetadata.table_name)
  return _internal_table_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ColumnMetadata::set_table_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.table_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.user.ColumnMetadata.table_name)
}
inline std::string* ColumnMetadata::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:exec.user.ColumnMetadata.table_name)
  return _s;
}
inline const std::string& ColumnMetadata::_internal_table_name() const {
  return _impl_.table_name_.Get();
}
inline void ColumnMetadata::_internal_set_table_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;


  _impl_.table_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ColumnMetadata::_internal_mutable_table_name() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.table_name_.Mutable( GetArenaForAllocation());
}
inline std::string* ColumnMetadata::release_table_name() {
  // @@protoc_insertion_point(field_release:exec.user.ColumnMetadata.table_name)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.table_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.table_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ColumnMetadata::set_allocated_table_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.table_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.table_name_.IsDefault()) {
          _impl_.table_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.user.ColumnMetadata.table_name)
}

// optional string column_name = 4;
inline bool ColumnMetadata::has_column_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void ColumnMetadata::clear_column_name() {
  _impl_.column_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ColumnMetadata::column_name() const {
  // @@protoc_insertion_point(field_get:exec.user.ColumnMetadata.column_name)
  return _internal_column_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ColumnMetadata::set_column_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.column_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.user.ColumnMetadata.column_name)
}
inline std::string* ColumnMetadata::mutable_column_name() {
  std::string* _s = _internal_mutable_column_name();
  // @@protoc_insertion_point(field_mutable:exec.user.ColumnMetadata.column_name)
  return _s;
}
inline const std::string& ColumnMetadata::_internal_column_name() const {
  return _impl_.column_name_.Get();
}
inline void ColumnMetadata::_internal_set_column_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;


  _impl_.column_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ColumnMetadata::_internal_mutable_column_name() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.column_name_.Mutable( GetArenaForAllocation());
}
inline std::string* ColumnMetadata::release_column_name() {
  // @@protoc_insertion_point(field_release:exec.user.ColumnMetadata.column_name)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.column_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.column_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ColumnMetadata::set_allocated_column_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.column_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.column_name_.IsDefault()) {
          _impl_.column_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.user.ColumnMetadata.column_name)
}

// optional int32 ordinal_position = 5;
inline bool ColumnMetadata::has_ordinal_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void ColumnMetadata::clear_ordinal_position() {
  _impl_.ordinal_position_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::int32_t ColumnMetadata::ordinal_position() const {
  // @@protoc_insertion_point(field_get:exec.user.ColumnMetadata.ordinal_position)
  return _internal_ordinal_position();
}
inline void ColumnMetadata::set_ordinal_position(::int32_t value) {
  _internal_set_ordinal_position(value);
  // @@protoc_insertion_point(field_set:exec.user.ColumnMetadata.ordinal_position)
}
inline ::int32_t ColumnMetadata::_internal_ordinal_position() const {
  return _impl_.ordinal_position_;
}
inline void ColumnMetadata::_internal_set_ordinal_position(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.ordinal_position_ = value;
}

// optional string default_value = 6;
inline bool ColumnMetadata::has_default_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void ColumnMetadata::clear_default_value() {
  _impl_.default_value_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& ColumnMetadata::default_value() const {
  // @@protoc_insertion_point(field_get:exec.user.ColumnMetadata.default_value)
  return _internal_default_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ColumnMetadata::set_default_value(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.default_value_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.user.ColumnMetadata.default_value)
}
inline std::string* ColumnMetadata::mutable_default_value() {
  std::string* _s = _internal_mutable_default_value();
  // @@protoc_insertion_point(field_mutable:exec.user.ColumnMetadata.default_value)
  return _s;
}
inline const std::string& ColumnMetadata::_internal_default_value() const {
  return _impl_.default_value_.Get();
}
inline void ColumnMetadata::_internal_set_default_value(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;


  _impl_.default_value_.Set(value, GetArenaForAllocation());
}
inline std::string* ColumnMetadata::_internal_mutable_default_value() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.default_value_.Mutable( GetArenaForAllocation());
}
inline std::string* ColumnMetadata::release_default_value() {
  // @@protoc_insertion_point(field_release:exec.user.ColumnMetadata.default_value)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.default_value_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.default_value_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ColumnMetadata::set_allocated_default_value(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.default_value_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.default_value_.IsDefault()) {
          _impl_.default_value_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.user.ColumnMetadata.default_value)
}

// optional bool is_nullable = 7;
inline bool ColumnMetadata::has_is_nullable() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void ColumnMetadata::clear_is_nullable() {
  _impl_.is_nullable_ = false;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline bool ColumnMetadata::is_nullable() const {
  // @@protoc_insertion_point(field_get:exec.user.ColumnMetadata.is_nullable)
  return _internal_is_nullable();
}
inline void ColumnMetadata::set_is_nullable(bool value) {
  _internal_set_is_nullable(value);
  // @@protoc_insertion_point(field_set:exec.user.ColumnMetadata.is_nullable)
}
inline bool ColumnMetadata::_internal_is_nullable() const {
  return _impl_.is_nullable_;
}
inline void ColumnMetadata::_internal_set_is_nullable(bool value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.is_nullable_ = value;
}

// optional string data_type = 8;
inline bool ColumnMetadata::has_data_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void ColumnMetadata::clear_data_type() {
  _impl_.data_type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& ColumnMetadata::data_type() const {
  // @@protoc_insertion_point(field_get:exec.user.ColumnMetadata.data_type)
  return _internal_data_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ColumnMetadata::set_data_type(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.data_type_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.user.ColumnMetadata.data_type)
}
inline std::string* ColumnMetadata::mutable_data_type() {
  std::string* _s = _internal_mutable_data_type();
  // @@protoc_insertion_point(field_mutable:exec.user.ColumnMetadata.data_type)
  return _s;
}
inline const std::string& ColumnMetadata::_internal_data_type() const {
  return _impl_.data_type_.Get();
}
inline void ColumnMetadata::_internal_set_data_type(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;


  _impl_.data_type_.Set(value, GetArenaForAllocation());
}
inline std::string* ColumnMetadata::_internal_mutable_data_type() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.data_type_.Mutable( GetArenaForAllocation());
}
inline std::string* ColumnMetadata::release_data_type() {
  // @@protoc_insertion_point(field_release:exec.user.ColumnMetadata.data_type)
  if ((_impl_._has_bits_[0] & 0x00000020u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* released = _impl_.data_type_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.data_type_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ColumnMetadata::set_allocated_data_type(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.data_type_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.data_type_.IsDefault()) {
          _impl_.data_type_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.user.ColumnMetadata.data_type)
}

// optional int32 char_max_length = 9;
inline bool ColumnMetadata::has_char_max_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void ColumnMetadata::clear_char_max_length() {
  _impl_.char_max_length_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::int32_t ColumnMetadata::char_max_length() const {
  // @@protoc_insertion_point(field_get:exec.user.ColumnMetadata.char_max_length)
  return _internal_char_max_length();
}
inline void ColumnMetadata::set_char_max_length(::int32_t value) {
  _internal_set_char_max_length(value);
  // @@protoc_insertion_point(field_set:exec.user.ColumnMetadata.char_max_length)
}
inline ::int32_t ColumnMetadata::_internal_char_max_length() const {
  return _impl_.char_max_length_;
}
inline void ColumnMetadata::_internal_set_char_max_length(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.char_max_length_ = value;
}

// optional int32 char_octet_length = 10;
inline bool ColumnMetadata::has_char_octet_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void ColumnMetadata::clear_char_octet_length() {
  _impl_.char_octet_length_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::int32_t ColumnMetadata::char_octet_length() const {
  // @@protoc_insertion_point(field_get:exec.user.ColumnMetadata.char_octet_length)
  return _internal_char_octet_length();
}
inline void ColumnMetadata::set_char_octet_length(::int32_t value) {
  _internal_set_char_octet_length(value);
  // @@protoc_insertion_point(field_set:exec.user.ColumnMetadata.char_octet_length)
}
inline ::int32_t ColumnMetadata::_internal_char_octet_length() const {
  return _impl_.char_octet_length_;
}
inline void ColumnMetadata::_internal_set_char_octet_length(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.char_octet_length_ = value;
}

// optional int32 numeric_precision = 11;
inline bool ColumnMetadata::has_numeric_precision() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void ColumnMetadata::clear_numeric_precision() {
  _impl_.numeric_precision_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline ::int32_t ColumnMetadata::numeric_precision() const {
  // @@protoc_insertion_point(field_get:exec.user.ColumnMetadata.numeric_precision)
  return _internal_numeric_precision();
}
inline void ColumnMetadata::set_numeric_precision(::int32_t value) {
  _internal_set_numeric_precision(value);
  // @@protoc_insertion_point(field_set:exec.user.ColumnMetadata.numeric_precision)
}
inline ::int32_t ColumnMetadata::_internal_numeric_precision() const {
  return _impl_.numeric_precision_;
}
inline void ColumnMetadata::_internal_set_numeric_precision(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.numeric_precision_ = value;
}

// optional int32 numeric_precision_radix = 12;
inline bool ColumnMetadata::has_numeric_precision_radix() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline void ColumnMetadata::clear_numeric_precision_radix() {
  _impl_.numeric_precision_radix_ = 0;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline ::int32_t ColumnMetadata::numeric_precision_radix() const {
  // @@protoc_insertion_point(field_get:exec.user.ColumnMetadata.numeric_precision_radix)
  return _internal_numeric_precision_radix();
}
inline void ColumnMetadata::set_numeric_precision_radix(::int32_t value) {
  _internal_set_numeric_precision_radix(value);
  // @@protoc_insertion_point(field_set:exec.user.ColumnMetadata.numeric_precision_radix)
}
inline ::int32_t ColumnMetadata::_internal_numeric_precision_radix() const {
  return _impl_.numeric_precision_radix_;
}
inline void ColumnMetadata::_internal_set_numeric_precision_radix(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.numeric_precision_radix_ = value;
}

// optional int32 numeric_scale = 13;
inline bool ColumnMetadata::has_numeric_scale() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline void ColumnMetadata::clear_numeric_scale() {
  _impl_.numeric_scale_ = 0;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline ::int32_t ColumnMetadata::numeric_scale() const {
  // @@protoc_insertion_point(field_get:exec.user.ColumnMetadata.numeric_scale)
  return _internal_numeric_scale();
}
inline void ColumnMetadata::set_numeric_scale(::int32_t value) {
  _internal_set_numeric_scale(value);
  // @@protoc_insertion_point(field_set:exec.user.ColumnMetadata.numeric_scale)
}
inline ::int32_t ColumnMetadata::_internal_numeric_scale() const {
  return _impl_.numeric_scale_;
}
inline void ColumnMetadata::_internal_set_numeric_scale(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.numeric_scale_ = value;
}

// optional int32 date_time_precision = 14;
inline bool ColumnMetadata::has_date_time_precision() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline void ColumnMetadata::clear_date_time_precision() {
  _impl_.date_time_precision_ = 0;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline ::int32_t ColumnMetadata::date_time_precision() const {
  // @@protoc_insertion_point(field_get:exec.user.ColumnMetadata.date_time_precision)
  return _internal_date_time_precision();
}
inline void ColumnMetadata::set_date_time_precision(::int32_t value) {
  _internal_set_date_time_precision(value);
  // @@protoc_insertion_point(field_set:exec.user.ColumnMetadata.date_time_precision)
}
inline ::int32_t ColumnMetadata::_internal_date_time_precision() const {
  return _impl_.date_time_precision_;
}
inline void ColumnMetadata::_internal_set_date_time_precision(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.date_time_precision_ = value;
}

// optional string interval_type = 15;
inline bool ColumnMetadata::has_interval_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void ColumnMetadata::clear_interval_type() {
  _impl_.interval_type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& ColumnMetadata::interval_type() const {
  // @@protoc_insertion_point(field_get:exec.user.ColumnMetadata.interval_type)
  return _internal_interval_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ColumnMetadata::set_interval_type(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.interval_type_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.user.ColumnMetadata.interval_type)
}
inline std::string* ColumnMetadata::mutable_interval_type() {
  std::string* _s = _internal_mutable_interval_type();
  // @@protoc_insertion_point(field_mutable:exec.user.ColumnMetadata.interval_type)
  return _s;
}
inline const std::string& ColumnMetadata::_internal_interval_type() const {
  return _impl_.interval_type_.Get();
}
inline void ColumnMetadata::_internal_set_interval_type(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000040u;


  _impl_.interval_type_.Set(value, GetArenaForAllocation());
}
inline std::string* ColumnMetadata::_internal_mutable_interval_type() {
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.interval_type_.Mutable( GetArenaForAllocation());
}
inline std::string* ColumnMetadata::release_interval_type() {
  // @@protoc_insertion_point(field_release:exec.user.ColumnMetadata.interval_type)
  if ((_impl_._has_bits_[0] & 0x00000040u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* released = _impl_.interval_type_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.interval_type_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ColumnMetadata::set_allocated_interval_type(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.interval_type_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.interval_type_.IsDefault()) {
          _impl_.interval_type_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.user.ColumnMetadata.interval_type)
}

// optional int32 interval_precision = 16;
inline bool ColumnMetadata::has_interval_precision() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline void ColumnMetadata::clear_interval_precision() {
  _impl_.interval_precision_ = 0;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline ::int32_t ColumnMetadata::interval_precision() const {
  // @@protoc_insertion_point(field_get:exec.user.ColumnMetadata.interval_precision)
  return _internal_interval_precision();
}
inline void ColumnMetadata::set_interval_precision(::int32_t value) {
  _internal_set_interval_precision(value);
  // @@protoc_insertion_point(field_set:exec.user.ColumnMetadata.interval_precision)
}
inline ::int32_t ColumnMetadata::_internal_interval_precision() const {
  return _impl_.interval_precision_;
}
inline void ColumnMetadata::_internal_set_interval_precision(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.interval_precision_ = value;
}

// optional int32 column_size = 17;
inline bool ColumnMetadata::has_column_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline void ColumnMetadata::clear_column_size() {
  _impl_.column_size_ = 0;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline ::int32_t ColumnMetadata::column_size() const {
  // @@protoc_insertion_point(field_get:exec.user.ColumnMetadata.column_size)
  return _internal_column_size();
}
inline void ColumnMetadata::set_column_size(::int32_t value) {
  _internal_set_column_size(value);
  // @@protoc_insertion_point(field_set:exec.user.ColumnMetadata.column_size)
}
inline ::int32_t ColumnMetadata::_internal_column_size() const {
  return _impl_.column_size_;
}
inline void ColumnMetadata::_internal_set_column_size(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.column_size_ = value;
}

// -------------------------------------------------------------------

// GetColumnsResp

// optional .exec.user.RequestStatus status = 1;
inline bool GetColumnsResp::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void GetColumnsResp::clear_status() {
  _impl_.status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::exec::user::RequestStatus GetColumnsResp::status() const {
  // @@protoc_insertion_point(field_get:exec.user.GetColumnsResp.status)
  return _internal_status();
}
inline void GetColumnsResp::set_status(::exec::user::RequestStatus value) {
   _internal_set_status(value);
  // @@protoc_insertion_point(field_set:exec.user.GetColumnsResp.status)
}
inline ::exec::user::RequestStatus GetColumnsResp::_internal_status() const {
  return static_cast<::exec::user::RequestStatus>(_impl_.status_);
}
inline void GetColumnsResp::_internal_set_status(::exec::user::RequestStatus value) {
  assert(::exec::user::RequestStatus_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.status_ = value;
}

// repeated .exec.user.ColumnMetadata columns = 2;
inline int GetColumnsResp::_internal_columns_size() const {
  return _impl_.columns_.size();
}
inline int GetColumnsResp::columns_size() const {
  return _internal_columns_size();
}
inline void GetColumnsResp::clear_columns() {
  _impl_.columns_.Clear();
}
inline ::exec::user::ColumnMetadata* GetColumnsResp::mutable_columns(int index) {
  // @@protoc_insertion_point(field_mutable:exec.user.GetColumnsResp.columns)
  return _impl_.columns_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::user::ColumnMetadata >*
GetColumnsResp::mutable_columns() {
  // @@protoc_insertion_point(field_mutable_list:exec.user.GetColumnsResp.columns)
  return &_impl_.columns_;
}
inline const ::exec::user::ColumnMetadata& GetColumnsResp::_internal_columns(int index) const {
  return _impl_.columns_.Get(index);
}
inline const ::exec::user::ColumnMetadata& GetColumnsResp::columns(int index) const {
  // @@protoc_insertion_point(field_get:exec.user.GetColumnsResp.columns)
  return _internal_columns(index);
}
inline ::exec::user::ColumnMetadata* GetColumnsResp::_internal_add_columns() {
  return _impl_.columns_.Add();
}
inline ::exec::user::ColumnMetadata* GetColumnsResp::add_columns() {
  ::exec::user::ColumnMetadata* _add = _internal_add_columns();
  // @@protoc_insertion_point(field_add:exec.user.GetColumnsResp.columns)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::user::ColumnMetadata >&
GetColumnsResp::columns() const {
  // @@protoc_insertion_point(field_list:exec.user.GetColumnsResp.columns)
  return _impl_.columns_;
}

// optional .exec.shared.DrillPBError error = 3;
inline bool GetColumnsResp::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_ != nullptr);
  return value;
}
inline const ::exec::shared::DrillPBError& GetColumnsResp::_internal_error() const {
  const ::exec::shared::DrillPBError* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::exec::shared::DrillPBError&>(
      ::exec::shared::_DrillPBError_default_instance_);
}
inline const ::exec::shared::DrillPBError& GetColumnsResp::error() const {
  // @@protoc_insertion_point(field_get:exec.user.GetColumnsResp.error)
  return _internal_error();
}
inline void GetColumnsResp::unsafe_arena_set_allocated_error(
    ::exec::shared::DrillPBError* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:exec.user.GetColumnsResp.error)
}
inline ::exec::shared::DrillPBError* GetColumnsResp::release_error() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::exec::shared::DrillPBError* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exec::shared::DrillPBError* GetColumnsResp::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:exec.user.GetColumnsResp.error)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::exec::shared::DrillPBError* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::exec::shared::DrillPBError* GetColumnsResp::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::exec::shared::DrillPBError>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::exec::shared::DrillPBError* GetColumnsResp::mutable_error() {
  ::exec::shared::DrillPBError* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:exec.user.GetColumnsResp.error)
  return _msg;
}
inline void GetColumnsResp::set_allocated_error(::exec::shared::DrillPBError* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(error));
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:exec.user.GetColumnsResp.error)
}

// -------------------------------------------------------------------

// CreatePreparedStatementReq

// optional string sql_query = 1;
inline bool CreatePreparedStatementReq::has_sql_query() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CreatePreparedStatementReq::clear_sql_query() {
  _impl_.sql_query_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CreatePreparedStatementReq::sql_query() const {
  // @@protoc_insertion_point(field_get:exec.user.CreatePreparedStatementReq.sql_query)
  return _internal_sql_query();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreatePreparedStatementReq::set_sql_query(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sql_query_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.user.CreatePreparedStatementReq.sql_query)
}
inline std::string* CreatePreparedStatementReq::mutable_sql_query() {
  std::string* _s = _internal_mutable_sql_query();
  // @@protoc_insertion_point(field_mutable:exec.user.CreatePreparedStatementReq.sql_query)
  return _s;
}
inline const std::string& CreatePreparedStatementReq::_internal_sql_query() const {
  return _impl_.sql_query_.Get();
}
inline void CreatePreparedStatementReq::_internal_set_sql_query(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.sql_query_.Set(value, GetArenaForAllocation());
}
inline std::string* CreatePreparedStatementReq::_internal_mutable_sql_query() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.sql_query_.Mutable( GetArenaForAllocation());
}
inline std::string* CreatePreparedStatementReq::release_sql_query() {
  // @@protoc_insertion_point(field_release:exec.user.CreatePreparedStatementReq.sql_query)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.sql_query_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.sql_query_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CreatePreparedStatementReq::set_allocated_sql_query(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.sql_query_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sql_query_.IsDefault()) {
          _impl_.sql_query_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.user.CreatePreparedStatementReq.sql_query)
}

// -------------------------------------------------------------------

// ResultColumnMetadata

// optional string catalog_name = 1;
inline bool ResultColumnMetadata::has_catalog_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ResultColumnMetadata::clear_catalog_name() {
  _impl_.catalog_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ResultColumnMetadata::catalog_name() const {
  // @@protoc_insertion_point(field_get:exec.user.ResultColumnMetadata.catalog_name)
  return _internal_catalog_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ResultColumnMetadata::set_catalog_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.catalog_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.user.ResultColumnMetadata.catalog_name)
}
inline std::string* ResultColumnMetadata::mutable_catalog_name() {
  std::string* _s = _internal_mutable_catalog_name();
  // @@protoc_insertion_point(field_mutable:exec.user.ResultColumnMetadata.catalog_name)
  return _s;
}
inline const std::string& ResultColumnMetadata::_internal_catalog_name() const {
  return _impl_.catalog_name_.Get();
}
inline void ResultColumnMetadata::_internal_set_catalog_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.catalog_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ResultColumnMetadata::_internal_mutable_catalog_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.catalog_name_.Mutable( GetArenaForAllocation());
}
inline std::string* ResultColumnMetadata::release_catalog_name() {
  // @@protoc_insertion_point(field_release:exec.user.ResultColumnMetadata.catalog_name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.catalog_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.catalog_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ResultColumnMetadata::set_allocated_catalog_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.catalog_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.catalog_name_.IsDefault()) {
          _impl_.catalog_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.user.ResultColumnMetadata.catalog_name)
}

// optional string schema_name = 2;
inline bool ResultColumnMetadata::has_schema_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ResultColumnMetadata::clear_schema_name() {
  _impl_.schema_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ResultColumnMetadata::schema_name() const {
  // @@protoc_insertion_point(field_get:exec.user.ResultColumnMetadata.schema_name)
  return _internal_schema_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ResultColumnMetadata::set_schema_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.schema_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.user.ResultColumnMetadata.schema_name)
}
inline std::string* ResultColumnMetadata::mutable_schema_name() {
  std::string* _s = _internal_mutable_schema_name();
  // @@protoc_insertion_point(field_mutable:exec.user.ResultColumnMetadata.schema_name)
  return _s;
}
inline const std::string& ResultColumnMetadata::_internal_schema_name() const {
  return _impl_.schema_name_.Get();
}
inline void ResultColumnMetadata::_internal_set_schema_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.schema_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ResultColumnMetadata::_internal_mutable_schema_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.schema_name_.Mutable( GetArenaForAllocation());
}
inline std::string* ResultColumnMetadata::release_schema_name() {
  // @@protoc_insertion_point(field_release:exec.user.ResultColumnMetadata.schema_name)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.schema_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.schema_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ResultColumnMetadata::set_allocated_schema_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.schema_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.schema_name_.IsDefault()) {
          _impl_.schema_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.user.ResultColumnMetadata.schema_name)
}

// optional string table_name = 3;
inline bool ResultColumnMetadata::has_table_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ResultColumnMetadata::clear_table_name() {
  _impl_.table_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ResultColumnMetadata::table_name() const {
  // @@protoc_insertion_point(field_get:exec.user.ResultColumnMetadata.table_name)
  return _internal_table_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ResultColumnMetadata::set_table_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.table_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.user.ResultColumnMetadata.table_name)
}
inline std::string* ResultColumnMetadata::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:exec.user.ResultColumnMetadata.table_name)
  return _s;
}
inline const std::string& ResultColumnMetadata::_internal_table_name() const {
  return _impl_.table_name_.Get();
}
inline void ResultColumnMetadata::_internal_set_table_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;


  _impl_.table_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ResultColumnMetadata::_internal_mutable_table_name() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.table_name_.Mutable( GetArenaForAllocation());
}
inline std::string* ResultColumnMetadata::release_table_name() {
  // @@protoc_insertion_point(field_release:exec.user.ResultColumnMetadata.table_name)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.table_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.table_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ResultColumnMetadata::set_allocated_table_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.table_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.table_name_.IsDefault()) {
          _impl_.table_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.user.ResultColumnMetadata.table_name)
}

// optional string column_name = 4;
inline bool ResultColumnMetadata::has_column_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void ResultColumnMetadata::clear_column_name() {
  _impl_.column_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ResultColumnMetadata::column_name() const {
  // @@protoc_insertion_point(field_get:exec.user.ResultColumnMetadata.column_name)
  return _internal_column_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ResultColumnMetadata::set_column_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.column_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.user.ResultColumnMetadata.column_name)
}
inline std::string* ResultColumnMetadata::mutable_column_name() {
  std::string* _s = _internal_mutable_column_name();
  // @@protoc_insertion_point(field_mutable:exec.user.ResultColumnMetadata.column_name)
  return _s;
}
inline const std::string& ResultColumnMetadata::_internal_column_name() const {
  return _impl_.column_name_.Get();
}
inline void ResultColumnMetadata::_internal_set_column_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;


  _impl_.column_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ResultColumnMetadata::_internal_mutable_column_name() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.column_name_.Mutable( GetArenaForAllocation());
}
inline std::string* ResultColumnMetadata::release_column_name() {
  // @@protoc_insertion_point(field_release:exec.user.ResultColumnMetadata.column_name)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.column_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.column_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ResultColumnMetadata::set_allocated_column_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.column_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.column_name_.IsDefault()) {
          _impl_.column_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.user.ResultColumnMetadata.column_name)
}

// optional string label = 5;
inline bool ResultColumnMetadata::has_label() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void ResultColumnMetadata::clear_label() {
  _impl_.label_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& ResultColumnMetadata::label() const {
  // @@protoc_insertion_point(field_get:exec.user.ResultColumnMetadata.label)
  return _internal_label();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ResultColumnMetadata::set_label(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.label_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.user.ResultColumnMetadata.label)
}
inline std::string* ResultColumnMetadata::mutable_label() {
  std::string* _s = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:exec.user.ResultColumnMetadata.label)
  return _s;
}
inline const std::string& ResultColumnMetadata::_internal_label() const {
  return _impl_.label_.Get();
}
inline void ResultColumnMetadata::_internal_set_label(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;


  _impl_.label_.Set(value, GetArenaForAllocation());
}
inline std::string* ResultColumnMetadata::_internal_mutable_label() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.label_.Mutable( GetArenaForAllocation());
}
inline std::string* ResultColumnMetadata::release_label() {
  // @@protoc_insertion_point(field_release:exec.user.ResultColumnMetadata.label)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.label_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.label_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ResultColumnMetadata::set_allocated_label(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.label_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.label_.IsDefault()) {
          _impl_.label_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.user.ResultColumnMetadata.label)
}

// optional string data_type = 6;
inline bool ResultColumnMetadata::has_data_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void ResultColumnMetadata::clear_data_type() {
  _impl_.data_type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& ResultColumnMetadata::data_type() const {
  // @@protoc_insertion_point(field_get:exec.user.ResultColumnMetadata.data_type)
  return _internal_data_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ResultColumnMetadata::set_data_type(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.data_type_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.user.ResultColumnMetadata.data_type)
}
inline std::string* ResultColumnMetadata::mutable_data_type() {
  std::string* _s = _internal_mutable_data_type();
  // @@protoc_insertion_point(field_mutable:exec.user.ResultColumnMetadata.data_type)
  return _s;
}
inline const std::string& ResultColumnMetadata::_internal_data_type() const {
  return _impl_.data_type_.Get();
}
inline void ResultColumnMetadata::_internal_set_data_type(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;


  _impl_.data_type_.Set(value, GetArenaForAllocation());
}
inline std::string* ResultColumnMetadata::_internal_mutable_data_type() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.data_type_.Mutable( GetArenaForAllocation());
}
inline std::string* ResultColumnMetadata::release_data_type() {
  // @@protoc_insertion_point(field_release:exec.user.ResultColumnMetadata.data_type)
  if ((_impl_._has_bits_[0] & 0x00000020u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* released = _impl_.data_type_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.data_type_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ResultColumnMetadata::set_allocated_data_type(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.data_type_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.data_type_.IsDefault()) {
          _impl_.data_type_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.user.ResultColumnMetadata.data_type)
}

// optional bool is_nullable = 7;
inline bool ResultColumnMetadata::has_is_nullable() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void ResultColumnMetadata::clear_is_nullable() {
  _impl_.is_nullable_ = false;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline bool ResultColumnMetadata::is_nullable() const {
  // @@protoc_insertion_point(field_get:exec.user.ResultColumnMetadata.is_nullable)
  return _internal_is_nullable();
}
inline void ResultColumnMetadata::set_is_nullable(bool value) {
  _internal_set_is_nullable(value);
  // @@protoc_insertion_point(field_set:exec.user.ResultColumnMetadata.is_nullable)
}
inline bool ResultColumnMetadata::_internal_is_nullable() const {
  return _impl_.is_nullable_;
}
inline void ResultColumnMetadata::_internal_set_is_nullable(bool value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.is_nullable_ = value;
}

// optional int32 precision = 8;
inline bool ResultColumnMetadata::has_precision() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void ResultColumnMetadata::clear_precision() {
  _impl_.precision_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::int32_t ResultColumnMetadata::precision() const {
  // @@protoc_insertion_point(field_get:exec.user.ResultColumnMetadata.precision)
  return _internal_precision();
}
inline void ResultColumnMetadata::set_precision(::int32_t value) {
  _internal_set_precision(value);
  // @@protoc_insertion_point(field_set:exec.user.ResultColumnMetadata.precision)
}
inline ::int32_t ResultColumnMetadata::_internal_precision() const {
  return _impl_.precision_;
}
inline void ResultColumnMetadata::_internal_set_precision(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.precision_ = value;
}

// optional int32 scale = 9;
inline bool ResultColumnMetadata::has_scale() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void ResultColumnMetadata::clear_scale() {
  _impl_.scale_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::int32_t ResultColumnMetadata::scale() const {
  // @@protoc_insertion_point(field_get:exec.user.ResultColumnMetadata.scale)
  return _internal_scale();
}
inline void ResultColumnMetadata::set_scale(::int32_t value) {
  _internal_set_scale(value);
  // @@protoc_insertion_point(field_set:exec.user.ResultColumnMetadata.scale)
}
inline ::int32_t ResultColumnMetadata::_internal_scale() const {
  return _impl_.scale_;
}
inline void ResultColumnMetadata::_internal_set_scale(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.scale_ = value;
}

// optional bool signed = 10;
inline bool ResultColumnMetadata::has_signed_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void ResultColumnMetadata::clear_signed_() {
  _impl_.signed__ = false;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline bool ResultColumnMetadata::signed_() const {
  // @@protoc_insertion_point(field_get:exec.user.ResultColumnMetadata.signed)
  return _internal_signed_();
}
inline void ResultColumnMetadata::set_signed_(bool value) {
  _internal_set_signed_(value);
  // @@protoc_insertion_point(field_set:exec.user.ResultColumnMetadata.signed)
}
inline bool ResultColumnMetadata::_internal_signed_() const {
  return _impl_.signed__;
}
inline void ResultColumnMetadata::_internal_set_signed_(bool value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.signed__ = value;
}

// optional int32 display_size = 11;
inline bool ResultColumnMetadata::has_display_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void ResultColumnMetadata::clear_display_size() {
  _impl_.display_size_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::int32_t ResultColumnMetadata::display_size() const {
  // @@protoc_insertion_point(field_get:exec.user.ResultColumnMetadata.display_size)
  return _internal_display_size();
}
inline void ResultColumnMetadata::set_display_size(::int32_t value) {
  _internal_set_display_size(value);
  // @@protoc_insertion_point(field_set:exec.user.ResultColumnMetadata.display_size)
}
inline ::int32_t ResultColumnMetadata::_internal_display_size() const {
  return _impl_.display_size_;
}
inline void ResultColumnMetadata::_internal_set_display_size(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.display_size_ = value;
}

// optional bool is_aliased = 12;
inline bool ResultColumnMetadata::has_is_aliased() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline void ResultColumnMetadata::clear_is_aliased() {
  _impl_.is_aliased_ = false;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline bool ResultColumnMetadata::is_aliased() const {
  // @@protoc_insertion_point(field_get:exec.user.ResultColumnMetadata.is_aliased)
  return _internal_is_aliased();
}
inline void ResultColumnMetadata::set_is_aliased(bool value) {
  _internal_set_is_aliased(value);
  // @@protoc_insertion_point(field_set:exec.user.ResultColumnMetadata.is_aliased)
}
inline bool ResultColumnMetadata::_internal_is_aliased() const {
  return _impl_.is_aliased_;
}
inline void ResultColumnMetadata::_internal_set_is_aliased(bool value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.is_aliased_ = value;
}

// optional .exec.user.ColumnSearchability searchability = 13;
inline bool ResultColumnMetadata::has_searchability() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline void ResultColumnMetadata::clear_searchability() {
  _impl_.searchability_ = 0;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline ::exec::user::ColumnSearchability ResultColumnMetadata::searchability() const {
  // @@protoc_insertion_point(field_get:exec.user.ResultColumnMetadata.searchability)
  return _internal_searchability();
}
inline void ResultColumnMetadata::set_searchability(::exec::user::ColumnSearchability value) {
   _internal_set_searchability(value);
  // @@protoc_insertion_point(field_set:exec.user.ResultColumnMetadata.searchability)
}
inline ::exec::user::ColumnSearchability ResultColumnMetadata::_internal_searchability() const {
  return static_cast<::exec::user::ColumnSearchability>(_impl_.searchability_);
}
inline void ResultColumnMetadata::_internal_set_searchability(::exec::user::ColumnSearchability value) {
  assert(::exec::user::ColumnSearchability_IsValid(value));
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.searchability_ = value;
}

// optional .exec.user.ColumnUpdatability updatability = 14;
inline bool ResultColumnMetadata::has_updatability() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline void ResultColumnMetadata::clear_updatability() {
  _impl_.updatability_ = 0;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline ::exec::user::ColumnUpdatability ResultColumnMetadata::updatability() const {
  // @@protoc_insertion_point(field_get:exec.user.ResultColumnMetadata.updatability)
  return _internal_updatability();
}
inline void ResultColumnMetadata::set_updatability(::exec::user::ColumnUpdatability value) {
   _internal_set_updatability(value);
  // @@protoc_insertion_point(field_set:exec.user.ResultColumnMetadata.updatability)
}
inline ::exec::user::ColumnUpdatability ResultColumnMetadata::_internal_updatability() const {
  return static_cast<::exec::user::ColumnUpdatability>(_impl_.updatability_);
}
inline void ResultColumnMetadata::_internal_set_updatability(::exec::user::ColumnUpdatability value) {
  assert(::exec::user::ColumnUpdatability_IsValid(value));
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.updatability_ = value;
}

// optional bool auto_increment = 15;
inline bool ResultColumnMetadata::has_auto_increment() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline void ResultColumnMetadata::clear_auto_increment() {
  _impl_.auto_increment_ = false;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline bool ResultColumnMetadata::auto_increment() const {
  // @@protoc_insertion_point(field_get:exec.user.ResultColumnMetadata.auto_increment)
  return _internal_auto_increment();
}
inline void ResultColumnMetadata::set_auto_increment(bool value) {
  _internal_set_auto_increment(value);
  // @@protoc_insertion_point(field_set:exec.user.ResultColumnMetadata.auto_increment)
}
inline bool ResultColumnMetadata::_internal_auto_increment() const {
  return _impl_.auto_increment_;
}
inline void ResultColumnMetadata::_internal_set_auto_increment(bool value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.auto_increment_ = value;
}

// optional bool case_sensitivity = 16;
inline bool ResultColumnMetadata::has_case_sensitivity() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline void ResultColumnMetadata::clear_case_sensitivity() {
  _impl_.case_sensitivity_ = false;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline bool ResultColumnMetadata::case_sensitivity() const {
  // @@protoc_insertion_point(field_get:exec.user.ResultColumnMetadata.case_sensitivity)
  return _internal_case_sensitivity();
}
inline void ResultColumnMetadata::set_case_sensitivity(bool value) {
  _internal_set_case_sensitivity(value);
  // @@protoc_insertion_point(field_set:exec.user.ResultColumnMetadata.case_sensitivity)
}
inline bool ResultColumnMetadata::_internal_case_sensitivity() const {
  return _impl_.case_sensitivity_;
}
inline void ResultColumnMetadata::_internal_set_case_sensitivity(bool value) {
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.case_sensitivity_ = value;
}

// optional bool sortable = 17;
inline bool ResultColumnMetadata::has_sortable() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline void ResultColumnMetadata::clear_sortable() {
  _impl_.sortable_ = false;
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline bool ResultColumnMetadata::sortable() const {
  // @@protoc_insertion_point(field_get:exec.user.ResultColumnMetadata.sortable)
  return _internal_sortable();
}
inline void ResultColumnMetadata::set_sortable(bool value) {
  _internal_set_sortable(value);
  // @@protoc_insertion_point(field_set:exec.user.ResultColumnMetadata.sortable)
}
inline bool ResultColumnMetadata::_internal_sortable() const {
  return _impl_.sortable_;
}
inline void ResultColumnMetadata::_internal_set_sortable(bool value) {
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.sortable_ = value;
}

// optional string class_name = 18;
inline bool ResultColumnMetadata::has_class_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void ResultColumnMetadata::clear_class_name() {
  _impl_.class_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& ResultColumnMetadata::class_name() const {
  // @@protoc_insertion_point(field_get:exec.user.ResultColumnMetadata.class_name)
  return _internal_class_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ResultColumnMetadata::set_class_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.class_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.user.ResultColumnMetadata.class_name)
}
inline std::string* ResultColumnMetadata::mutable_class_name() {
  std::string* _s = _internal_mutable_class_name();
  // @@protoc_insertion_point(field_mutable:exec.user.ResultColumnMetadata.class_name)
  return _s;
}
inline const std::string& ResultColumnMetadata::_internal_class_name() const {
  return _impl_.class_name_.Get();
}
inline void ResultColumnMetadata::_internal_set_class_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000040u;


  _impl_.class_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ResultColumnMetadata::_internal_mutable_class_name() {
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.class_name_.Mutable( GetArenaForAllocation());
}
inline std::string* ResultColumnMetadata::release_class_name() {
  // @@protoc_insertion_point(field_release:exec.user.ResultColumnMetadata.class_name)
  if ((_impl_._has_bits_[0] & 0x00000040u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* released = _impl_.class_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.class_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ResultColumnMetadata::set_allocated_class_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.class_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.class_name_.IsDefault()) {
          _impl_.class_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.user.ResultColumnMetadata.class_name)
}

// optional bool is_currency = 20;
inline bool ResultColumnMetadata::has_is_currency() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline void ResultColumnMetadata::clear_is_currency() {
  _impl_.is_currency_ = false;
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline bool ResultColumnMetadata::is_currency() const {
  // @@protoc_insertion_point(field_get:exec.user.ResultColumnMetadata.is_currency)
  return _internal_is_currency();
}
inline void ResultColumnMetadata::set_is_currency(bool value) {
  _internal_set_is_currency(value);
  // @@protoc_insertion_point(field_set:exec.user.ResultColumnMetadata.is_currency)
}
inline bool ResultColumnMetadata::_internal_is_currency() const {
  return _impl_.is_currency_;
}
inline void ResultColumnMetadata::_internal_set_is_currency(bool value) {
  _impl_._has_bits_[0] |= 0x00040000u;
  _impl_.is_currency_ = value;
}

// -------------------------------------------------------------------

// PreparedStatementHandle

// optional bytes server_info = 1;
inline bool PreparedStatementHandle::has_server_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PreparedStatementHandle::clear_server_info() {
  _impl_.server_info_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PreparedStatementHandle::server_info() const {
  // @@protoc_insertion_point(field_get:exec.user.PreparedStatementHandle.server_info)
  return _internal_server_info();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PreparedStatementHandle::set_server_info(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.server_info_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.user.PreparedStatementHandle.server_info)
}
inline std::string* PreparedStatementHandle::mutable_server_info() {
  std::string* _s = _internal_mutable_server_info();
  // @@protoc_insertion_point(field_mutable:exec.user.PreparedStatementHandle.server_info)
  return _s;
}
inline const std::string& PreparedStatementHandle::_internal_server_info() const {
  return _impl_.server_info_.Get();
}
inline void PreparedStatementHandle::_internal_set_server_info(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.server_info_.Set(value, GetArenaForAllocation());
}
inline std::string* PreparedStatementHandle::_internal_mutable_server_info() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.server_info_.Mutable( GetArenaForAllocation());
}
inline std::string* PreparedStatementHandle::release_server_info() {
  // @@protoc_insertion_point(field_release:exec.user.PreparedStatementHandle.server_info)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.server_info_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.server_info_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void PreparedStatementHandle::set_allocated_server_info(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.server_info_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.server_info_.IsDefault()) {
          _impl_.server_info_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.user.PreparedStatementHandle.server_info)
}

// -------------------------------------------------------------------

// PreparedStatement

// repeated .exec.user.ResultColumnMetadata columns = 1;
inline int PreparedStatement::_internal_columns_size() const {
  return _impl_.columns_.size();
}
inline int PreparedStatement::columns_size() const {
  return _internal_columns_size();
}
inline void PreparedStatement::clear_columns() {
  _impl_.columns_.Clear();
}
inline ::exec::user::ResultColumnMetadata* PreparedStatement::mutable_columns(int index) {
  // @@protoc_insertion_point(field_mutable:exec.user.PreparedStatement.columns)
  return _impl_.columns_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::user::ResultColumnMetadata >*
PreparedStatement::mutable_columns() {
  // @@protoc_insertion_point(field_mutable_list:exec.user.PreparedStatement.columns)
  return &_impl_.columns_;
}
inline const ::exec::user::ResultColumnMetadata& PreparedStatement::_internal_columns(int index) const {
  return _impl_.columns_.Get(index);
}
inline const ::exec::user::ResultColumnMetadata& PreparedStatement::columns(int index) const {
  // @@protoc_insertion_point(field_get:exec.user.PreparedStatement.columns)
  return _internal_columns(index);
}
inline ::exec::user::ResultColumnMetadata* PreparedStatement::_internal_add_columns() {
  return _impl_.columns_.Add();
}
inline ::exec::user::ResultColumnMetadata* PreparedStatement::add_columns() {
  ::exec::user::ResultColumnMetadata* _add = _internal_add_columns();
  // @@protoc_insertion_point(field_add:exec.user.PreparedStatement.columns)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::user::ResultColumnMetadata >&
PreparedStatement::columns() const {
  // @@protoc_insertion_point(field_list:exec.user.PreparedStatement.columns)
  return _impl_.columns_;
}

// optional .exec.user.PreparedStatementHandle server_handle = 2;
inline bool PreparedStatement::has_server_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.server_handle_ != nullptr);
  return value;
}
inline void PreparedStatement::clear_server_handle() {
  if (_impl_.server_handle_ != nullptr) _impl_.server_handle_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::exec::user::PreparedStatementHandle& PreparedStatement::_internal_server_handle() const {
  const ::exec::user::PreparedStatementHandle* p = _impl_.server_handle_;
  return p != nullptr ? *p : reinterpret_cast<const ::exec::user::PreparedStatementHandle&>(
      ::exec::user::_PreparedStatementHandle_default_instance_);
}
inline const ::exec::user::PreparedStatementHandle& PreparedStatement::server_handle() const {
  // @@protoc_insertion_point(field_get:exec.user.PreparedStatement.server_handle)
  return _internal_server_handle();
}
inline void PreparedStatement::unsafe_arena_set_allocated_server_handle(
    ::exec::user::PreparedStatementHandle* server_handle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.server_handle_);
  }
  _impl_.server_handle_ = server_handle;
  if (server_handle) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:exec.user.PreparedStatement.server_handle)
}
inline ::exec::user::PreparedStatementHandle* PreparedStatement::release_server_handle() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::exec::user::PreparedStatementHandle* temp = _impl_.server_handle_;
  _impl_.server_handle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exec::user::PreparedStatementHandle* PreparedStatement::unsafe_arena_release_server_handle() {
  // @@protoc_insertion_point(field_release:exec.user.PreparedStatement.server_handle)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::exec::user::PreparedStatementHandle* temp = _impl_.server_handle_;
  _impl_.server_handle_ = nullptr;
  return temp;
}
inline ::exec::user::PreparedStatementHandle* PreparedStatement::_internal_mutable_server_handle() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.server_handle_ == nullptr) {
    auto* p = CreateMaybeMessage<::exec::user::PreparedStatementHandle>(GetArenaForAllocation());
    _impl_.server_handle_ = p;
  }
  return _impl_.server_handle_;
}
inline ::exec::user::PreparedStatementHandle* PreparedStatement::mutable_server_handle() {
  ::exec::user::PreparedStatementHandle* _msg = _internal_mutable_server_handle();
  // @@protoc_insertion_point(field_mutable:exec.user.PreparedStatement.server_handle)
  return _msg;
}
inline void PreparedStatement::set_allocated_server_handle(::exec::user::PreparedStatementHandle* server_handle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.server_handle_;
  }
  if (server_handle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(server_handle);
    if (message_arena != submessage_arena) {
      server_handle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, server_handle, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.server_handle_ = server_handle;
  // @@protoc_insertion_point(field_set_allocated:exec.user.PreparedStatement.server_handle)
}

// -------------------------------------------------------------------

// CreatePreparedStatementResp

// optional .exec.user.RequestStatus status = 1;
inline bool CreatePreparedStatementResp::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CreatePreparedStatementResp::clear_status() {
  _impl_.status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::exec::user::RequestStatus CreatePreparedStatementResp::status() const {
  // @@protoc_insertion_point(field_get:exec.user.CreatePreparedStatementResp.status)
  return _internal_status();
}
inline void CreatePreparedStatementResp::set_status(::exec::user::RequestStatus value) {
   _internal_set_status(value);
  // @@protoc_insertion_point(field_set:exec.user.CreatePreparedStatementResp.status)
}
inline ::exec::user::RequestStatus CreatePreparedStatementResp::_internal_status() const {
  return static_cast<::exec::user::RequestStatus>(_impl_.status_);
}
inline void CreatePreparedStatementResp::_internal_set_status(::exec::user::RequestStatus value) {
  assert(::exec::user::RequestStatus_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.status_ = value;
}

// optional .exec.user.PreparedStatement prepared_statement = 2;
inline bool CreatePreparedStatementResp::has_prepared_statement() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.prepared_statement_ != nullptr);
  return value;
}
inline void CreatePreparedStatementResp::clear_prepared_statement() {
  if (_impl_.prepared_statement_ != nullptr) _impl_.prepared_statement_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::exec::user::PreparedStatement& CreatePreparedStatementResp::_internal_prepared_statement() const {
  const ::exec::user::PreparedStatement* p = _impl_.prepared_statement_;
  return p != nullptr ? *p : reinterpret_cast<const ::exec::user::PreparedStatement&>(
      ::exec::user::_PreparedStatement_default_instance_);
}
inline const ::exec::user::PreparedStatement& CreatePreparedStatementResp::prepared_statement() const {
  // @@protoc_insertion_point(field_get:exec.user.CreatePreparedStatementResp.prepared_statement)
  return _internal_prepared_statement();
}
inline void CreatePreparedStatementResp::unsafe_arena_set_allocated_prepared_statement(
    ::exec::user::PreparedStatement* prepared_statement) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.prepared_statement_);
  }
  _impl_.prepared_statement_ = prepared_statement;
  if (prepared_statement) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:exec.user.CreatePreparedStatementResp.prepared_statement)
}
inline ::exec::user::PreparedStatement* CreatePreparedStatementResp::release_prepared_statement() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::exec::user::PreparedStatement* temp = _impl_.prepared_statement_;
  _impl_.prepared_statement_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exec::user::PreparedStatement* CreatePreparedStatementResp::unsafe_arena_release_prepared_statement() {
  // @@protoc_insertion_point(field_release:exec.user.CreatePreparedStatementResp.prepared_statement)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::exec::user::PreparedStatement* temp = _impl_.prepared_statement_;
  _impl_.prepared_statement_ = nullptr;
  return temp;
}
inline ::exec::user::PreparedStatement* CreatePreparedStatementResp::_internal_mutable_prepared_statement() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.prepared_statement_ == nullptr) {
    auto* p = CreateMaybeMessage<::exec::user::PreparedStatement>(GetArenaForAllocation());
    _impl_.prepared_statement_ = p;
  }
  return _impl_.prepared_statement_;
}
inline ::exec::user::PreparedStatement* CreatePreparedStatementResp::mutable_prepared_statement() {
  ::exec::user::PreparedStatement* _msg = _internal_mutable_prepared_statement();
  // @@protoc_insertion_point(field_mutable:exec.user.CreatePreparedStatementResp.prepared_statement)
  return _msg;
}
inline void CreatePreparedStatementResp::set_allocated_prepared_statement(::exec::user::PreparedStatement* prepared_statement) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.prepared_statement_;
  }
  if (prepared_statement) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(prepared_statement);
    if (message_arena != submessage_arena) {
      prepared_statement = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, prepared_statement, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.prepared_statement_ = prepared_statement;
  // @@protoc_insertion_point(field_set_allocated:exec.user.CreatePreparedStatementResp.prepared_statement)
}

// optional .exec.shared.DrillPBError error = 3;
inline bool CreatePreparedStatementResp::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_ != nullptr);
  return value;
}
inline const ::exec::shared::DrillPBError& CreatePreparedStatementResp::_internal_error() const {
  const ::exec::shared::DrillPBError* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::exec::shared::DrillPBError&>(
      ::exec::shared::_DrillPBError_default_instance_);
}
inline const ::exec::shared::DrillPBError& CreatePreparedStatementResp::error() const {
  // @@protoc_insertion_point(field_get:exec.user.CreatePreparedStatementResp.error)
  return _internal_error();
}
inline void CreatePreparedStatementResp::unsafe_arena_set_allocated_error(
    ::exec::shared::DrillPBError* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:exec.user.CreatePreparedStatementResp.error)
}
inline ::exec::shared::DrillPBError* CreatePreparedStatementResp::release_error() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::exec::shared::DrillPBError* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exec::shared::DrillPBError* CreatePreparedStatementResp::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:exec.user.CreatePreparedStatementResp.error)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::exec::shared::DrillPBError* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::exec::shared::DrillPBError* CreatePreparedStatementResp::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::exec::shared::DrillPBError>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::exec::shared::DrillPBError* CreatePreparedStatementResp::mutable_error() {
  ::exec::shared::DrillPBError* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:exec.user.CreatePreparedStatementResp.error)
  return _msg;
}
inline void CreatePreparedStatementResp::set_allocated_error(::exec::shared::DrillPBError* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(error));
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:exec.user.CreatePreparedStatementResp.error)
}

// -------------------------------------------------------------------

// GetServerMetaReq

// -------------------------------------------------------------------

// ConvertSupport

// required .common.MinorType from = 1;
inline bool ConvertSupport::has_from() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ConvertSupport::clear_from() {
  _impl_.from_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::common::MinorType ConvertSupport::from() const {
  // @@protoc_insertion_point(field_get:exec.user.ConvertSupport.from)
  return _internal_from();
}
inline void ConvertSupport::set_from(::common::MinorType value) {
   _internal_set_from(value);
  // @@protoc_insertion_point(field_set:exec.user.ConvertSupport.from)
}
inline ::common::MinorType ConvertSupport::_internal_from() const {
  return static_cast<::common::MinorType>(_impl_.from_);
}
inline void ConvertSupport::_internal_set_from(::common::MinorType value) {
  assert(::common::MinorType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.from_ = value;
}

// required .common.MinorType to = 2;
inline bool ConvertSupport::has_to() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ConvertSupport::clear_to() {
  _impl_.to_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::common::MinorType ConvertSupport::to() const {
  // @@protoc_insertion_point(field_get:exec.user.ConvertSupport.to)
  return _internal_to();
}
inline void ConvertSupport::set_to(::common::MinorType value) {
   _internal_set_to(value);
  // @@protoc_insertion_point(field_set:exec.user.ConvertSupport.to)
}
inline ::common::MinorType ConvertSupport::_internal_to() const {
  return static_cast<::common::MinorType>(_impl_.to_);
}
inline void ConvertSupport::_internal_set_to(::common::MinorType value) {
  assert(::common::MinorType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.to_ = value;
}

// -------------------------------------------------------------------

// GetServerMetaResp

// optional .exec.user.RequestStatus status = 1;
inline bool GetServerMetaResp::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void GetServerMetaResp::clear_status() {
  _impl_.status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::exec::user::RequestStatus GetServerMetaResp::status() const {
  // @@protoc_insertion_point(field_get:exec.user.GetServerMetaResp.status)
  return _internal_status();
}
inline void GetServerMetaResp::set_status(::exec::user::RequestStatus value) {
   _internal_set_status(value);
  // @@protoc_insertion_point(field_set:exec.user.GetServerMetaResp.status)
}
inline ::exec::user::RequestStatus GetServerMetaResp::_internal_status() const {
  return static_cast<::exec::user::RequestStatus>(_impl_.status_);
}
inline void GetServerMetaResp::_internal_set_status(::exec::user::RequestStatus value) {
  assert(::exec::user::RequestStatus_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.status_ = value;
}

// optional .exec.user.ServerMeta server_meta = 2;
inline bool GetServerMetaResp::has_server_meta() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.server_meta_ != nullptr);
  return value;
}
inline void GetServerMetaResp::clear_server_meta() {
  if (_impl_.server_meta_ != nullptr) _impl_.server_meta_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::exec::user::ServerMeta& GetServerMetaResp::_internal_server_meta() const {
  const ::exec::user::ServerMeta* p = _impl_.server_meta_;
  return p != nullptr ? *p : reinterpret_cast<const ::exec::user::ServerMeta&>(
      ::exec::user::_ServerMeta_default_instance_);
}
inline const ::exec::user::ServerMeta& GetServerMetaResp::server_meta() const {
  // @@protoc_insertion_point(field_get:exec.user.GetServerMetaResp.server_meta)
  return _internal_server_meta();
}
inline void GetServerMetaResp::unsafe_arena_set_allocated_server_meta(
    ::exec::user::ServerMeta* server_meta) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.server_meta_);
  }
  _impl_.server_meta_ = server_meta;
  if (server_meta) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:exec.user.GetServerMetaResp.server_meta)
}
inline ::exec::user::ServerMeta* GetServerMetaResp::release_server_meta() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::exec::user::ServerMeta* temp = _impl_.server_meta_;
  _impl_.server_meta_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exec::user::ServerMeta* GetServerMetaResp::unsafe_arena_release_server_meta() {
  // @@protoc_insertion_point(field_release:exec.user.GetServerMetaResp.server_meta)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::exec::user::ServerMeta* temp = _impl_.server_meta_;
  _impl_.server_meta_ = nullptr;
  return temp;
}
inline ::exec::user::ServerMeta* GetServerMetaResp::_internal_mutable_server_meta() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.server_meta_ == nullptr) {
    auto* p = CreateMaybeMessage<::exec::user::ServerMeta>(GetArenaForAllocation());
    _impl_.server_meta_ = p;
  }
  return _impl_.server_meta_;
}
inline ::exec::user::ServerMeta* GetServerMetaResp::mutable_server_meta() {
  ::exec::user::ServerMeta* _msg = _internal_mutable_server_meta();
  // @@protoc_insertion_point(field_mutable:exec.user.GetServerMetaResp.server_meta)
  return _msg;
}
inline void GetServerMetaResp::set_allocated_server_meta(::exec::user::ServerMeta* server_meta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.server_meta_;
  }
  if (server_meta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(server_meta);
    if (message_arena != submessage_arena) {
      server_meta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, server_meta, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.server_meta_ = server_meta;
  // @@protoc_insertion_point(field_set_allocated:exec.user.GetServerMetaResp.server_meta)
}

// optional .exec.shared.DrillPBError error = 3;
inline bool GetServerMetaResp::has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.error_ != nullptr);
  return value;
}
inline const ::exec::shared::DrillPBError& GetServerMetaResp::_internal_error() const {
  const ::exec::shared::DrillPBError* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::exec::shared::DrillPBError&>(
      ::exec::shared::_DrillPBError_default_instance_);
}
inline const ::exec::shared::DrillPBError& GetServerMetaResp::error() const {
  // @@protoc_insertion_point(field_get:exec.user.GetServerMetaResp.error)
  return _internal_error();
}
inline void GetServerMetaResp::unsafe_arena_set_allocated_error(
    ::exec::shared::DrillPBError* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:exec.user.GetServerMetaResp.error)
}
inline ::exec::shared::DrillPBError* GetServerMetaResp::release_error() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::exec::shared::DrillPBError* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exec::shared::DrillPBError* GetServerMetaResp::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:exec.user.GetServerMetaResp.error)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::exec::shared::DrillPBError* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::exec::shared::DrillPBError* GetServerMetaResp::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::exec::shared::DrillPBError>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::exec::shared::DrillPBError* GetServerMetaResp::mutable_error() {
  ::exec::shared::DrillPBError* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:exec.user.GetServerMetaResp.error)
  return _msg;
}
inline void GetServerMetaResp::set_allocated_error(::exec::shared::DrillPBError* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(error));
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:exec.user.GetServerMetaResp.error)
}

// -------------------------------------------------------------------

// ServerMeta

// optional bool all_tables_selectable = 1;
inline bool ServerMeta::has_all_tables_selectable() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void ServerMeta::clear_all_tables_selectable() {
  _impl_.all_tables_selectable_ = false;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline bool ServerMeta::all_tables_selectable() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.all_tables_selectable)
  return _internal_all_tables_selectable();
}
inline void ServerMeta::set_all_tables_selectable(bool value) {
  _internal_set_all_tables_selectable(value);
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.all_tables_selectable)
}
inline bool ServerMeta::_internal_all_tables_selectable() const {
  return _impl_.all_tables_selectable_;
}
inline void ServerMeta::_internal_set_all_tables_selectable(bool value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.all_tables_selectable_ = value;
}

// optional bool blob_included_in_max_row_size = 2;
inline bool ServerMeta::has_blob_included_in_max_row_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void ServerMeta::clear_blob_included_in_max_row_size() {
  _impl_.blob_included_in_max_row_size_ = false;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline bool ServerMeta::blob_included_in_max_row_size() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.blob_included_in_max_row_size)
  return _internal_blob_included_in_max_row_size();
}
inline void ServerMeta::set_blob_included_in_max_row_size(bool value) {
  _internal_set_blob_included_in_max_row_size(value);
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.blob_included_in_max_row_size)
}
inline bool ServerMeta::_internal_blob_included_in_max_row_size() const {
  return _impl_.blob_included_in_max_row_size_;
}
inline void ServerMeta::_internal_set_blob_included_in_max_row_size(bool value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.blob_included_in_max_row_size_ = value;
}

// optional bool catalog_at_start = 3;
inline bool ServerMeta::has_catalog_at_start() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void ServerMeta::clear_catalog_at_start() {
  _impl_.catalog_at_start_ = false;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline bool ServerMeta::catalog_at_start() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.catalog_at_start)
  return _internal_catalog_at_start();
}
inline void ServerMeta::set_catalog_at_start(bool value) {
  _internal_set_catalog_at_start(value);
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.catalog_at_start)
}
inline bool ServerMeta::_internal_catalog_at_start() const {
  return _impl_.catalog_at_start_;
}
inline void ServerMeta::_internal_set_catalog_at_start(bool value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.catalog_at_start_ = value;
}

// optional string catalog_separator = 4;
inline bool ServerMeta::has_catalog_separator() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ServerMeta::clear_catalog_separator() {
  _impl_.catalog_separator_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ServerMeta::catalog_separator() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.catalog_separator)
  return _internal_catalog_separator();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ServerMeta::set_catalog_separator(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.catalog_separator_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.catalog_separator)
}
inline std::string* ServerMeta::mutable_catalog_separator() {
  std::string* _s = _internal_mutable_catalog_separator();
  // @@protoc_insertion_point(field_mutable:exec.user.ServerMeta.catalog_separator)
  return _s;
}
inline const std::string& ServerMeta::_internal_catalog_separator() const {
  return _impl_.catalog_separator_.Get();
}
inline void ServerMeta::_internal_set_catalog_separator(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.catalog_separator_.Set(value, GetArenaForAllocation());
}
inline std::string* ServerMeta::_internal_mutable_catalog_separator() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.catalog_separator_.Mutable( GetArenaForAllocation());
}
inline std::string* ServerMeta::release_catalog_separator() {
  // @@protoc_insertion_point(field_release:exec.user.ServerMeta.catalog_separator)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.catalog_separator_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.catalog_separator_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ServerMeta::set_allocated_catalog_separator(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.catalog_separator_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.catalog_separator_.IsDefault()) {
          _impl_.catalog_separator_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.user.ServerMeta.catalog_separator)
}

// optional string catalog_term = 5;
inline bool ServerMeta::has_catalog_term() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ServerMeta::clear_catalog_term() {
  _impl_.catalog_term_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ServerMeta::catalog_term() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.catalog_term)
  return _internal_catalog_term();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ServerMeta::set_catalog_term(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.catalog_term_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.catalog_term)
}
inline std::string* ServerMeta::mutable_catalog_term() {
  std::string* _s = _internal_mutable_catalog_term();
  // @@protoc_insertion_point(field_mutable:exec.user.ServerMeta.catalog_term)
  return _s;
}
inline const std::string& ServerMeta::_internal_catalog_term() const {
  return _impl_.catalog_term_.Get();
}
inline void ServerMeta::_internal_set_catalog_term(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.catalog_term_.Set(value, GetArenaForAllocation());
}
inline std::string* ServerMeta::_internal_mutable_catalog_term() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.catalog_term_.Mutable( GetArenaForAllocation());
}
inline std::string* ServerMeta::release_catalog_term() {
  // @@protoc_insertion_point(field_release:exec.user.ServerMeta.catalog_term)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.catalog_term_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.catalog_term_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ServerMeta::set_allocated_catalog_term(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.catalog_term_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.catalog_term_.IsDefault()) {
          _impl_.catalog_term_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.user.ServerMeta.catalog_term)
}

// repeated .exec.user.CollateSupport collate_support = 6;
inline int ServerMeta::_internal_collate_support_size() const {
  return _impl_.collate_support_.size();
}
inline int ServerMeta::collate_support_size() const {
  return _internal_collate_support_size();
}
inline void ServerMeta::clear_collate_support() {
  _impl_.collate_support_.Clear();
}
inline ::exec::user::CollateSupport ServerMeta::collate_support(int index) const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.collate_support)
  return _internal_collate_support(index);
}
inline void ServerMeta::set_collate_support(int index, ::exec::user::CollateSupport value) {
  assert(::exec::user::CollateSupport_IsValid(value));
  _impl_.collate_support_.Set(index, value);
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.collate_support)
}
inline void ServerMeta::add_collate_support(::exec::user::CollateSupport value) {
  _internal_add_collate_support(value);
  // @@protoc_insertion_point(field_add:exec.user.ServerMeta.collate_support)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& ServerMeta::collate_support() const {
  // @@protoc_insertion_point(field_list:exec.user.ServerMeta.collate_support)
  return _impl_.collate_support_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* ServerMeta::mutable_collate_support() {
  // @@protoc_insertion_point(field_mutable_list:exec.user.ServerMeta.collate_support)
  return _internal_mutable_collate_support();
}
inline ::exec::user::CollateSupport ServerMeta::_internal_collate_support(int index) const {
  return static_cast<::exec::user::CollateSupport>(_impl_.collate_support_.Get(index));
}
inline void ServerMeta::_internal_add_collate_support(::exec::user::CollateSupport value) {
  assert(::exec::user::CollateSupport_IsValid(value));
  _impl_.collate_support_.Add(value);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* ServerMeta::_internal_mutable_collate_support() {
  return &_impl_.collate_support_;
}

// optional bool column_aliasing_supported = 7;
inline bool ServerMeta::has_column_aliasing_supported() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void ServerMeta::clear_column_aliasing_supported() {
  _impl_.column_aliasing_supported_ = false;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline bool ServerMeta::column_aliasing_supported() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.column_aliasing_supported)
  return _internal_column_aliasing_supported();
}
inline void ServerMeta::set_column_aliasing_supported(bool value) {
  _internal_set_column_aliasing_supported(value);
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.column_aliasing_supported)
}
inline bool ServerMeta::_internal_column_aliasing_supported() const {
  return _impl_.column_aliasing_supported_;
}
inline void ServerMeta::_internal_set_column_aliasing_supported(bool value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.column_aliasing_supported_ = value;
}

// repeated .exec.user.ConvertSupport convert_support = 8;
inline int ServerMeta::_internal_convert_support_size() const {
  return _impl_.convert_support_.size();
}
inline int ServerMeta::convert_support_size() const {
  return _internal_convert_support_size();
}
inline void ServerMeta::clear_convert_support() {
  _impl_.convert_support_.Clear();
}
inline ::exec::user::ConvertSupport* ServerMeta::mutable_convert_support(int index) {
  // @@protoc_insertion_point(field_mutable:exec.user.ServerMeta.convert_support)
  return _impl_.convert_support_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::user::ConvertSupport >*
ServerMeta::mutable_convert_support() {
  // @@protoc_insertion_point(field_mutable_list:exec.user.ServerMeta.convert_support)
  return &_impl_.convert_support_;
}
inline const ::exec::user::ConvertSupport& ServerMeta::_internal_convert_support(int index) const {
  return _impl_.convert_support_.Get(index);
}
inline const ::exec::user::ConvertSupport& ServerMeta::convert_support(int index) const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.convert_support)
  return _internal_convert_support(index);
}
inline ::exec::user::ConvertSupport* ServerMeta::_internal_add_convert_support() {
  return _impl_.convert_support_.Add();
}
inline ::exec::user::ConvertSupport* ServerMeta::add_convert_support() {
  ::exec::user::ConvertSupport* _add = _internal_add_convert_support();
  // @@protoc_insertion_point(field_add:exec.user.ServerMeta.convert_support)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::user::ConvertSupport >&
ServerMeta::convert_support() const {
  // @@protoc_insertion_point(field_list:exec.user.ServerMeta.convert_support)
  return _impl_.convert_support_;
}

// optional .exec.user.CorrelationNamesSupport correlation_names_support = 9;
inline bool ServerMeta::has_correlation_names_support() const {
  bool value = (_impl_._has_bits_[1] & 0x00000010u) != 0;
  return value;
}
inline void ServerMeta::clear_correlation_names_support() {
  _impl_.correlation_names_support_ = 1;
  _impl_._has_bits_[1] &= ~0x00000010u;
}
inline ::exec::user::CorrelationNamesSupport ServerMeta::correlation_names_support() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.correlation_names_support)
  return _internal_correlation_names_support();
}
inline void ServerMeta::set_correlation_names_support(::exec::user::CorrelationNamesSupport value) {
   _internal_set_correlation_names_support(value);
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.correlation_names_support)
}
inline ::exec::user::CorrelationNamesSupport ServerMeta::_internal_correlation_names_support() const {
  return static_cast<::exec::user::CorrelationNamesSupport>(_impl_.correlation_names_support_);
}
inline void ServerMeta::_internal_set_correlation_names_support(::exec::user::CorrelationNamesSupport value) {
  assert(::exec::user::CorrelationNamesSupport_IsValid(value));
  _impl_._has_bits_[1] |= 0x00000010u;
  _impl_.correlation_names_support_ = value;
}

// repeated string date_time_functions = 10;
inline int ServerMeta::_internal_date_time_functions_size() const {
  return _impl_.date_time_functions_.size();
}
inline int ServerMeta::date_time_functions_size() const {
  return _internal_date_time_functions_size();
}
inline void ServerMeta::clear_date_time_functions() {
  _impl_.date_time_functions_.Clear();
}
inline std::string* ServerMeta::add_date_time_functions() {
  std::string* _s = _internal_add_date_time_functions();
  // @@protoc_insertion_point(field_add_mutable:exec.user.ServerMeta.date_time_functions)
  return _s;
}
inline const std::string& ServerMeta::_internal_date_time_functions(int index) const {
  return _impl_.date_time_functions_.Get(index);
}
inline const std::string& ServerMeta::date_time_functions(int index) const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.date_time_functions)
  return _internal_date_time_functions(index);
}
inline std::string* ServerMeta::mutable_date_time_functions(int index) {
  // @@protoc_insertion_point(field_mutable:exec.user.ServerMeta.date_time_functions)
  return _impl_.date_time_functions_.Mutable(index);
}
inline void ServerMeta::set_date_time_functions(int index, const std::string& value) {
  _impl_.date_time_functions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.date_time_functions)
}
inline void ServerMeta::set_date_time_functions(int index, std::string&& value) {
  _impl_.date_time_functions_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.date_time_functions)
}
inline void ServerMeta::set_date_time_functions(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _impl_.date_time_functions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:exec.user.ServerMeta.date_time_functions)
}
inline void ServerMeta::set_date_time_functions(int index, const char* value,
                              std::size_t size) {
  _impl_.date_time_functions_.Mutable(index)->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:exec.user.ServerMeta.date_time_functions)
}
inline void ServerMeta::set_date_time_functions(int index, absl::string_view value) {
  _impl_.date_time_functions_.Mutable(index)->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:exec.user.ServerMeta.date_time_functions)
}
inline std::string* ServerMeta::_internal_add_date_time_functions() { return _impl_.date_time_functions_.Add(); }
inline void ServerMeta::add_date_time_functions(const std::string& value) {
  _impl_.date_time_functions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:exec.user.ServerMeta.date_time_functions)
}
inline void ServerMeta::add_date_time_functions(std::string&& value) {
  _impl_.date_time_functions_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:exec.user.ServerMeta.date_time_functions)
}
inline void ServerMeta::add_date_time_functions(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _impl_.date_time_functions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:exec.user.ServerMeta.date_time_functions)
}
inline void ServerMeta::add_date_time_functions(const char* value, std::size_t size) {
  _impl_.date_time_functions_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:exec.user.ServerMeta.date_time_functions)
}
inline void ServerMeta::add_date_time_functions(absl::string_view value) {
  _impl_.date_time_functions_.Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:exec.user.ServerMeta.date_time_functions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ServerMeta::date_time_functions() const {
  // @@protoc_insertion_point(field_list:exec.user.ServerMeta.date_time_functions)
  return _impl_.date_time_functions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* ServerMeta::mutable_date_time_functions() {
  // @@protoc_insertion_point(field_mutable_list:exec.user.ServerMeta.date_time_functions)
  return &_impl_.date_time_functions_;
}

// repeated .exec.user.DateTimeLiteralsSupport date_time_literals_support = 11;
inline int ServerMeta::_internal_date_time_literals_support_size() const {
  return _impl_.date_time_literals_support_.size();
}
inline int ServerMeta::date_time_literals_support_size() const {
  return _internal_date_time_literals_support_size();
}
inline void ServerMeta::clear_date_time_literals_support() {
  _impl_.date_time_literals_support_.Clear();
}
inline ::exec::user::DateTimeLiteralsSupport ServerMeta::date_time_literals_support(int index) const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.date_time_literals_support)
  return _internal_date_time_literals_support(index);
}
inline void ServerMeta::set_date_time_literals_support(int index, ::exec::user::DateTimeLiteralsSupport value) {
  assert(::exec::user::DateTimeLiteralsSupport_IsValid(value));
  _impl_.date_time_literals_support_.Set(index, value);
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.date_time_literals_support)
}
inline void ServerMeta::add_date_time_literals_support(::exec::user::DateTimeLiteralsSupport value) {
  _internal_add_date_time_literals_support(value);
  // @@protoc_insertion_point(field_add:exec.user.ServerMeta.date_time_literals_support)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& ServerMeta::date_time_literals_support() const {
  // @@protoc_insertion_point(field_list:exec.user.ServerMeta.date_time_literals_support)
  return _impl_.date_time_literals_support_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* ServerMeta::mutable_date_time_literals_support() {
  // @@protoc_insertion_point(field_mutable_list:exec.user.ServerMeta.date_time_literals_support)
  return _internal_mutable_date_time_literals_support();
}
inline ::exec::user::DateTimeLiteralsSupport ServerMeta::_internal_date_time_literals_support(int index) const {
  return static_cast<::exec::user::DateTimeLiteralsSupport>(_impl_.date_time_literals_support_.Get(index));
}
inline void ServerMeta::_internal_add_date_time_literals_support(::exec::user::DateTimeLiteralsSupport value) {
  assert(::exec::user::DateTimeLiteralsSupport_IsValid(value));
  _impl_.date_time_literals_support_.Add(value);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* ServerMeta::_internal_mutable_date_time_literals_support() {
  return &_impl_.date_time_literals_support_;
}

// optional .exec.user.GroupBySupport group_by_support = 12;
inline bool ServerMeta::has_group_by_support() const {
  bool value = (_impl_._has_bits_[1] & 0x00000020u) != 0;
  return value;
}
inline void ServerMeta::clear_group_by_support() {
  _impl_.group_by_support_ = 1;
  _impl_._has_bits_[1] &= ~0x00000020u;
}
inline ::exec::user::GroupBySupport ServerMeta::group_by_support() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.group_by_support)
  return _internal_group_by_support();
}
inline void ServerMeta::set_group_by_support(::exec::user::GroupBySupport value) {
   _internal_set_group_by_support(value);
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.group_by_support)
}
inline ::exec::user::GroupBySupport ServerMeta::_internal_group_by_support() const {
  return static_cast<::exec::user::GroupBySupport>(_impl_.group_by_support_);
}
inline void ServerMeta::_internal_set_group_by_support(::exec::user::GroupBySupport value) {
  assert(::exec::user::GroupBySupport_IsValid(value));
  _impl_._has_bits_[1] |= 0x00000020u;
  _impl_.group_by_support_ = value;
}

// optional .exec.user.IdentifierCasing identifier_casing = 13;
inline bool ServerMeta::has_identifier_casing() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline void ServerMeta::clear_identifier_casing() {
  _impl_.identifier_casing_ = 0;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline ::exec::user::IdentifierCasing ServerMeta::identifier_casing() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.identifier_casing)
  return _internal_identifier_casing();
}
inline void ServerMeta::set_identifier_casing(::exec::user::IdentifierCasing value) {
   _internal_set_identifier_casing(value);
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.identifier_casing)
}
inline ::exec::user::IdentifierCasing ServerMeta::_internal_identifier_casing() const {
  return static_cast<::exec::user::IdentifierCasing>(_impl_.identifier_casing_);
}
inline void ServerMeta::_internal_set_identifier_casing(::exec::user::IdentifierCasing value) {
  assert(::exec::user::IdentifierCasing_IsValid(value));
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.identifier_casing_ = value;
}

// optional string identifier_quote_string = 14;
inline bool ServerMeta::has_identifier_quote_string() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ServerMeta::clear_identifier_quote_string() {
  _impl_.identifier_quote_string_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ServerMeta::identifier_quote_string() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.identifier_quote_string)
  return _internal_identifier_quote_string();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ServerMeta::set_identifier_quote_string(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.identifier_quote_string_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.identifier_quote_string)
}
inline std::string* ServerMeta::mutable_identifier_quote_string() {
  std::string* _s = _internal_mutable_identifier_quote_string();
  // @@protoc_insertion_point(field_mutable:exec.user.ServerMeta.identifier_quote_string)
  return _s;
}
inline const std::string& ServerMeta::_internal_identifier_quote_string() const {
  return _impl_.identifier_quote_string_.Get();
}
inline void ServerMeta::_internal_set_identifier_quote_string(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;


  _impl_.identifier_quote_string_.Set(value, GetArenaForAllocation());
}
inline std::string* ServerMeta::_internal_mutable_identifier_quote_string() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.identifier_quote_string_.Mutable( GetArenaForAllocation());
}
inline std::string* ServerMeta::release_identifier_quote_string() {
  // @@protoc_insertion_point(field_release:exec.user.ServerMeta.identifier_quote_string)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.identifier_quote_string_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.identifier_quote_string_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ServerMeta::set_allocated_identifier_quote_string(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.identifier_quote_string_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.identifier_quote_string_.IsDefault()) {
          _impl_.identifier_quote_string_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.user.ServerMeta.identifier_quote_string)
}

// optional bool like_escape_clause_supported = 15;
inline bool ServerMeta::has_like_escape_clause_supported() const {
  bool value = (_impl_._has_bits_[0] & 0x20000000u) != 0;
  return value;
}
inline void ServerMeta::clear_like_escape_clause_supported() {
  _impl_.like_escape_clause_supported_ = false;
  _impl_._has_bits_[0] &= ~0x20000000u;
}
inline bool ServerMeta::like_escape_clause_supported() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.like_escape_clause_supported)
  return _internal_like_escape_clause_supported();
}
inline void ServerMeta::set_like_escape_clause_supported(bool value) {
  _internal_set_like_escape_clause_supported(value);
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.like_escape_clause_supported)
}
inline bool ServerMeta::_internal_like_escape_clause_supported() const {
  return _impl_.like_escape_clause_supported_;
}
inline void ServerMeta::_internal_set_like_escape_clause_supported(bool value) {
  _impl_._has_bits_[0] |= 0x20000000u;
  _impl_.like_escape_clause_supported_ = value;
}

// optional uint32 max_binary_literal_length = 16;
inline bool ServerMeta::has_max_binary_literal_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline void ServerMeta::clear_max_binary_literal_length() {
  _impl_.max_binary_literal_length_ = 0u;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline ::uint32_t ServerMeta::max_binary_literal_length() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.max_binary_literal_length)
  return _internal_max_binary_literal_length();
}
inline void ServerMeta::set_max_binary_literal_length(::uint32_t value) {
  _internal_set_max_binary_literal_length(value);
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.max_binary_literal_length)
}
inline ::uint32_t ServerMeta::_internal_max_binary_literal_length() const {
  return _impl_.max_binary_literal_length_;
}
inline void ServerMeta::_internal_set_max_binary_literal_length(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.max_binary_literal_length_ = value;
}

// optional uint32 max_catalog_name_length = 17;
inline bool ServerMeta::has_max_catalog_name_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline void ServerMeta::clear_max_catalog_name_length() {
  _impl_.max_catalog_name_length_ = 0u;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline ::uint32_t ServerMeta::max_catalog_name_length() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.max_catalog_name_length)
  return _internal_max_catalog_name_length();
}
inline void ServerMeta::set_max_catalog_name_length(::uint32_t value) {
  _internal_set_max_catalog_name_length(value);
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.max_catalog_name_length)
}
inline ::uint32_t ServerMeta::_internal_max_catalog_name_length() const {
  return _impl_.max_catalog_name_length_;
}
inline void ServerMeta::_internal_set_max_catalog_name_length(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.max_catalog_name_length_ = value;
}

// optional uint32 max_char_literal_length = 18;
inline bool ServerMeta::has_max_char_literal_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline void ServerMeta::clear_max_char_literal_length() {
  _impl_.max_char_literal_length_ = 0u;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline ::uint32_t ServerMeta::max_char_literal_length() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.max_char_literal_length)
  return _internal_max_char_literal_length();
}
inline void ServerMeta::set_max_char_literal_length(::uint32_t value) {
  _internal_set_max_char_literal_length(value);
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.max_char_literal_length)
}
inline ::uint32_t ServerMeta::_internal_max_char_literal_length() const {
  return _impl_.max_char_literal_length_;
}
inline void ServerMeta::_internal_set_max_char_literal_length(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00008000u;
  _impl_.max_char_literal_length_ = value;
}

// optional uint32 max_column_name_length = 19;
inline bool ServerMeta::has_max_column_name_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline void ServerMeta::clear_max_column_name_length() {
  _impl_.max_column_name_length_ = 0u;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline ::uint32_t ServerMeta::max_column_name_length() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.max_column_name_length)
  return _internal_max_column_name_length();
}
inline void ServerMeta::set_max_column_name_length(::uint32_t value) {
  _internal_set_max_column_name_length(value);
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.max_column_name_length)
}
inline ::uint32_t ServerMeta::_internal_max_column_name_length() const {
  return _impl_.max_column_name_length_;
}
inline void ServerMeta::_internal_set_max_column_name_length(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00010000u;
  _impl_.max_column_name_length_ = value;
}

// optional uint32 max_columns_in_group_by = 20;
inline bool ServerMeta::has_max_columns_in_group_by() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline void ServerMeta::clear_max_columns_in_group_by() {
  _impl_.max_columns_in_group_by_ = 0u;
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline ::uint32_t ServerMeta::max_columns_in_group_by() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.max_columns_in_group_by)
  return _internal_max_columns_in_group_by();
}
inline void ServerMeta::set_max_columns_in_group_by(::uint32_t value) {
  _internal_set_max_columns_in_group_by(value);
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.max_columns_in_group_by)
}
inline ::uint32_t ServerMeta::_internal_max_columns_in_group_by() const {
  return _impl_.max_columns_in_group_by_;
}
inline void ServerMeta::_internal_set_max_columns_in_group_by(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00020000u;
  _impl_.max_columns_in_group_by_ = value;
}

// optional uint32 max_columns_in_order_by = 21;
inline bool ServerMeta::has_max_columns_in_order_by() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline void ServerMeta::clear_max_columns_in_order_by() {
  _impl_.max_columns_in_order_by_ = 0u;
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline ::uint32_t ServerMeta::max_columns_in_order_by() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.max_columns_in_order_by)
  return _internal_max_columns_in_order_by();
}
inline void ServerMeta::set_max_columns_in_order_by(::uint32_t value) {
  _internal_set_max_columns_in_order_by(value);
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.max_columns_in_order_by)
}
inline ::uint32_t ServerMeta::_internal_max_columns_in_order_by() const {
  return _impl_.max_columns_in_order_by_;
}
inline void ServerMeta::_internal_set_max_columns_in_order_by(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00040000u;
  _impl_.max_columns_in_order_by_ = value;
}

// optional uint32 max_columns_in_select = 22;
inline bool ServerMeta::has_max_columns_in_select() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline void ServerMeta::clear_max_columns_in_select() {
  _impl_.max_columns_in_select_ = 0u;
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline ::uint32_t ServerMeta::max_columns_in_select() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.max_columns_in_select)
  return _internal_max_columns_in_select();
}
inline void ServerMeta::set_max_columns_in_select(::uint32_t value) {
  _internal_set_max_columns_in_select(value);
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.max_columns_in_select)
}
inline ::uint32_t ServerMeta::_internal_max_columns_in_select() const {
  return _impl_.max_columns_in_select_;
}
inline void ServerMeta::_internal_set_max_columns_in_select(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00080000u;
  _impl_.max_columns_in_select_ = value;
}

// optional uint32 max_cursor_name_length = 23;
inline bool ServerMeta::has_max_cursor_name_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline void ServerMeta::clear_max_cursor_name_length() {
  _impl_.max_cursor_name_length_ = 0u;
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline ::uint32_t ServerMeta::max_cursor_name_length() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.max_cursor_name_length)
  return _internal_max_cursor_name_length();
}
inline void ServerMeta::set_max_cursor_name_length(::uint32_t value) {
  _internal_set_max_cursor_name_length(value);
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.max_cursor_name_length)
}
inline ::uint32_t ServerMeta::_internal_max_cursor_name_length() const {
  return _impl_.max_cursor_name_length_;
}
inline void ServerMeta::_internal_set_max_cursor_name_length(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00100000u;
  _impl_.max_cursor_name_length_ = value;
}

// optional uint32 max_logical_lob_size = 24;
inline bool ServerMeta::has_max_logical_lob_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline void ServerMeta::clear_max_logical_lob_size() {
  _impl_.max_logical_lob_size_ = 0u;
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline ::uint32_t ServerMeta::max_logical_lob_size() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.max_logical_lob_size)
  return _internal_max_logical_lob_size();
}
inline void ServerMeta::set_max_logical_lob_size(::uint32_t value) {
  _internal_set_max_logical_lob_size(value);
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.max_logical_lob_size)
}
inline ::uint32_t ServerMeta::_internal_max_logical_lob_size() const {
  return _impl_.max_logical_lob_size_;
}
inline void ServerMeta::_internal_set_max_logical_lob_size(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00200000u;
  _impl_.max_logical_lob_size_ = value;
}

// optional uint32 max_row_size = 25;
inline bool ServerMeta::has_max_row_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline void ServerMeta::clear_max_row_size() {
  _impl_.max_row_size_ = 0u;
  _impl_._has_bits_[0] &= ~0x00400000u;
}
inline ::uint32_t ServerMeta::max_row_size() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.max_row_size)
  return _internal_max_row_size();
}
inline void ServerMeta::set_max_row_size(::uint32_t value) {
  _internal_set_max_row_size(value);
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.max_row_size)
}
inline ::uint32_t ServerMeta::_internal_max_row_size() const {
  return _impl_.max_row_size_;
}
inline void ServerMeta::_internal_set_max_row_size(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00400000u;
  _impl_.max_row_size_ = value;
}

// optional uint32 max_schema_name_length = 26;
inline bool ServerMeta::has_max_schema_name_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline void ServerMeta::clear_max_schema_name_length() {
  _impl_.max_schema_name_length_ = 0u;
  _impl_._has_bits_[0] &= ~0x00800000u;
}
inline ::uint32_t ServerMeta::max_schema_name_length() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.max_schema_name_length)
  return _internal_max_schema_name_length();
}
inline void ServerMeta::set_max_schema_name_length(::uint32_t value) {
  _internal_set_max_schema_name_length(value);
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.max_schema_name_length)
}
inline ::uint32_t ServerMeta::_internal_max_schema_name_length() const {
  return _impl_.max_schema_name_length_;
}
inline void ServerMeta::_internal_set_max_schema_name_length(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x00800000u;
  _impl_.max_schema_name_length_ = value;
}

// optional uint32 max_statement_length = 27;
inline bool ServerMeta::has_max_statement_length() const {
  bool value = (_impl_._has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline void ServerMeta::clear_max_statement_length() {
  _impl_.max_statement_length_ = 0u;
  _impl_._has_bits_[0] &= ~0x01000000u;
}
inline ::uint32_t ServerMeta::max_statement_length() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.max_statement_length)
  return _internal_max_statement_length();
}
inline void ServerMeta::set_max_statement_length(::uint32_t value) {
  _internal_set_max_statement_length(value);
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.max_statement_length)
}
inline ::uint32_t ServerMeta::_internal_max_statement_length() const {
  return _impl_.max_statement_length_;
}
inline void ServerMeta::_internal_set_max_statement_length(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x01000000u;
  _impl_.max_statement_length_ = value;
}

// optional uint32 max_statements = 28;
inline bool ServerMeta::has_max_statements() const {
  bool value = (_impl_._has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline void ServerMeta::clear_max_statements() {
  _impl_.max_statements_ = 0u;
  _impl_._has_bits_[0] &= ~0x02000000u;
}
inline ::uint32_t ServerMeta::max_statements() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.max_statements)
  return _internal_max_statements();
}
inline void ServerMeta::set_max_statements(::uint32_t value) {
  _internal_set_max_statements(value);
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.max_statements)
}
inline ::uint32_t ServerMeta::_internal_max_statements() const {
  return _impl_.max_statements_;
}
inline void ServerMeta::_internal_set_max_statements(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x02000000u;
  _impl_.max_statements_ = value;
}

// optional uint32 max_table_name_length = 29;
inline bool ServerMeta::has_max_table_name_length() const {
  bool value = (_impl_._has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline void ServerMeta::clear_max_table_name_length() {
  _impl_.max_table_name_length_ = 0u;
  _impl_._has_bits_[0] &= ~0x04000000u;
}
inline ::uint32_t ServerMeta::max_table_name_length() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.max_table_name_length)
  return _internal_max_table_name_length();
}
inline void ServerMeta::set_max_table_name_length(::uint32_t value) {
  _internal_set_max_table_name_length(value);
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.max_table_name_length)
}
inline ::uint32_t ServerMeta::_internal_max_table_name_length() const {
  return _impl_.max_table_name_length_;
}
inline void ServerMeta::_internal_set_max_table_name_length(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x04000000u;
  _impl_.max_table_name_length_ = value;
}

// optional uint32 max_tables_in_select = 30;
inline bool ServerMeta::has_max_tables_in_select() const {
  bool value = (_impl_._has_bits_[0] & 0x08000000u) != 0;
  return value;
}
inline void ServerMeta::clear_max_tables_in_select() {
  _impl_.max_tables_in_select_ = 0u;
  _impl_._has_bits_[0] &= ~0x08000000u;
}
inline ::uint32_t ServerMeta::max_tables_in_select() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.max_tables_in_select)
  return _internal_max_tables_in_select();
}
inline void ServerMeta::set_max_tables_in_select(::uint32_t value) {
  _internal_set_max_tables_in_select(value);
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.max_tables_in_select)
}
inline ::uint32_t ServerMeta::_internal_max_tables_in_select() const {
  return _impl_.max_tables_in_select_;
}
inline void ServerMeta::_internal_set_max_tables_in_select(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x08000000u;
  _impl_.max_tables_in_select_ = value;
}

// optional uint32 max_user_name_length = 31;
inline bool ServerMeta::has_max_user_name_length() const {
  bool value = (_impl_._has_bits_[0] & 0x10000000u) != 0;
  return value;
}
inline void ServerMeta::clear_max_user_name_length() {
  _impl_.max_user_name_length_ = 0u;
  _impl_._has_bits_[0] &= ~0x10000000u;
}
inline ::uint32_t ServerMeta::max_user_name_length() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.max_user_name_length)
  return _internal_max_user_name_length();
}
inline void ServerMeta::set_max_user_name_length(::uint32_t value) {
  _internal_set_max_user_name_length(value);
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.max_user_name_length)
}
inline ::uint32_t ServerMeta::_internal_max_user_name_length() const {
  return _impl_.max_user_name_length_;
}
inline void ServerMeta::_internal_set_max_user_name_length(::uint32_t value) {
  _impl_._has_bits_[0] |= 0x10000000u;
  _impl_.max_user_name_length_ = value;
}

// optional .exec.user.NullCollation null_collation = 32;
inline bool ServerMeta::has_null_collation() const {
  bool value = (_impl_._has_bits_[1] & 0x00000002u) != 0;
  return value;
}
inline void ServerMeta::clear_null_collation() {
  _impl_.null_collation_ = 0;
  _impl_._has_bits_[1] &= ~0x00000002u;
}
inline ::exec::user::NullCollation ServerMeta::null_collation() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.null_collation)
  return _internal_null_collation();
}
inline void ServerMeta::set_null_collation(::exec::user::NullCollation value) {
   _internal_set_null_collation(value);
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.null_collation)
}
inline ::exec::user::NullCollation ServerMeta::_internal_null_collation() const {
  return static_cast<::exec::user::NullCollation>(_impl_.null_collation_);
}
inline void ServerMeta::_internal_set_null_collation(::exec::user::NullCollation value) {
  assert(::exec::user::NullCollation_IsValid(value));
  _impl_._has_bits_[1] |= 0x00000002u;
  _impl_.null_collation_ = value;
}

// optional bool null_plus_non_null_equals_null = 33;
inline bool ServerMeta::has_null_plus_non_null_equals_null() const {
  bool value = (_impl_._has_bits_[0] & 0x40000000u) != 0;
  return value;
}
inline void ServerMeta::clear_null_plus_non_null_equals_null() {
  _impl_.null_plus_non_null_equals_null_ = false;
  _impl_._has_bits_[0] &= ~0x40000000u;
}
inline bool ServerMeta::null_plus_non_null_equals_null() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.null_plus_non_null_equals_null)
  return _internal_null_plus_non_null_equals_null();
}
inline void ServerMeta::set_null_plus_non_null_equals_null(bool value) {
  _internal_set_null_plus_non_null_equals_null(value);
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.null_plus_non_null_equals_null)
}
inline bool ServerMeta::_internal_null_plus_non_null_equals_null() const {
  return _impl_.null_plus_non_null_equals_null_;
}
inline void ServerMeta::_internal_set_null_plus_non_null_equals_null(bool value) {
  _impl_._has_bits_[0] |= 0x40000000u;
  _impl_.null_plus_non_null_equals_null_ = value;
}

// repeated string numeric_functions = 34;
inline int ServerMeta::_internal_numeric_functions_size() const {
  return _impl_.numeric_functions_.size();
}
inline int ServerMeta::numeric_functions_size() const {
  return _internal_numeric_functions_size();
}
inline void ServerMeta::clear_numeric_functions() {
  _impl_.numeric_functions_.Clear();
}
inline std::string* ServerMeta::add_numeric_functions() {
  std::string* _s = _internal_add_numeric_functions();
  // @@protoc_insertion_point(field_add_mutable:exec.user.ServerMeta.numeric_functions)
  return _s;
}
inline const std::string& ServerMeta::_internal_numeric_functions(int index) const {
  return _impl_.numeric_functions_.Get(index);
}
inline const std::string& ServerMeta::numeric_functions(int index) const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.numeric_functions)
  return _internal_numeric_functions(index);
}
inline std::string* ServerMeta::mutable_numeric_functions(int index) {
  // @@protoc_insertion_point(field_mutable:exec.user.ServerMeta.numeric_functions)
  return _impl_.numeric_functions_.Mutable(index);
}
inline void ServerMeta::set_numeric_functions(int index, const std::string& value) {
  _impl_.numeric_functions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.numeric_functions)
}
inline void ServerMeta::set_numeric_functions(int index, std::string&& value) {
  _impl_.numeric_functions_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.numeric_functions)
}
inline void ServerMeta::set_numeric_functions(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _impl_.numeric_functions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:exec.user.ServerMeta.numeric_functions)
}
inline void ServerMeta::set_numeric_functions(int index, const char* value,
                              std::size_t size) {
  _impl_.numeric_functions_.Mutable(index)->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:exec.user.ServerMeta.numeric_functions)
}
inline void ServerMeta::set_numeric_functions(int index, absl::string_view value) {
  _impl_.numeric_functions_.Mutable(index)->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:exec.user.ServerMeta.numeric_functions)
}
inline std::string* ServerMeta::_internal_add_numeric_functions() { return _impl_.numeric_functions_.Add(); }
inline void ServerMeta::add_numeric_functions(const std::string& value) {
  _impl_.numeric_functions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:exec.user.ServerMeta.numeric_functions)
}
inline void ServerMeta::add_numeric_functions(std::string&& value) {
  _impl_.numeric_functions_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:exec.user.ServerMeta.numeric_functions)
}
inline void ServerMeta::add_numeric_functions(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _impl_.numeric_functions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:exec.user.ServerMeta.numeric_functions)
}
inline void ServerMeta::add_numeric_functions(const char* value, std::size_t size) {
  _impl_.numeric_functions_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:exec.user.ServerMeta.numeric_functions)
}
inline void ServerMeta::add_numeric_functions(absl::string_view value) {
  _impl_.numeric_functions_.Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:exec.user.ServerMeta.numeric_functions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ServerMeta::numeric_functions() const {
  // @@protoc_insertion_point(field_list:exec.user.ServerMeta.numeric_functions)
  return _impl_.numeric_functions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* ServerMeta::mutable_numeric_functions() {
  // @@protoc_insertion_point(field_mutable_list:exec.user.ServerMeta.numeric_functions)
  return &_impl_.numeric_functions_;
}

// repeated .exec.user.OrderBySupport order_by_support = 35;
inline int ServerMeta::_internal_order_by_support_size() const {
  return _impl_.order_by_support_.size();
}
inline int ServerMeta::order_by_support_size() const {
  return _internal_order_by_support_size();
}
inline void ServerMeta::clear_order_by_support() {
  _impl_.order_by_support_.Clear();
}
inline ::exec::user::OrderBySupport ServerMeta::order_by_support(int index) const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.order_by_support)
  return _internal_order_by_support(index);
}
inline void ServerMeta::set_order_by_support(int index, ::exec::user::OrderBySupport value) {
  assert(::exec::user::OrderBySupport_IsValid(value));
  _impl_.order_by_support_.Set(index, value);
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.order_by_support)
}
inline void ServerMeta::add_order_by_support(::exec::user::OrderBySupport value) {
  _internal_add_order_by_support(value);
  // @@protoc_insertion_point(field_add:exec.user.ServerMeta.order_by_support)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& ServerMeta::order_by_support() const {
  // @@protoc_insertion_point(field_list:exec.user.ServerMeta.order_by_support)
  return _impl_.order_by_support_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* ServerMeta::mutable_order_by_support() {
  // @@protoc_insertion_point(field_mutable_list:exec.user.ServerMeta.order_by_support)
  return _internal_mutable_order_by_support();
}
inline ::exec::user::OrderBySupport ServerMeta::_internal_order_by_support(int index) const {
  return static_cast<::exec::user::OrderBySupport>(_impl_.order_by_support_.Get(index));
}
inline void ServerMeta::_internal_add_order_by_support(::exec::user::OrderBySupport value) {
  assert(::exec::user::OrderBySupport_IsValid(value));
  _impl_.order_by_support_.Add(value);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* ServerMeta::_internal_mutable_order_by_support() {
  return &_impl_.order_by_support_;
}

// repeated .exec.user.OuterJoinSupport outer_join_support = 36;
inline int ServerMeta::_internal_outer_join_support_size() const {
  return _impl_.outer_join_support_.size();
}
inline int ServerMeta::outer_join_support_size() const {
  return _internal_outer_join_support_size();
}
inline void ServerMeta::clear_outer_join_support() {
  _impl_.outer_join_support_.Clear();
}
inline ::exec::user::OuterJoinSupport ServerMeta::outer_join_support(int index) const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.outer_join_support)
  return _internal_outer_join_support(index);
}
inline void ServerMeta::set_outer_join_support(int index, ::exec::user::OuterJoinSupport value) {
  assert(::exec::user::OuterJoinSupport_IsValid(value));
  _impl_.outer_join_support_.Set(index, value);
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.outer_join_support)
}
inline void ServerMeta::add_outer_join_support(::exec::user::OuterJoinSupport value) {
  _internal_add_outer_join_support(value);
  // @@protoc_insertion_point(field_add:exec.user.ServerMeta.outer_join_support)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& ServerMeta::outer_join_support() const {
  // @@protoc_insertion_point(field_list:exec.user.ServerMeta.outer_join_support)
  return _impl_.outer_join_support_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* ServerMeta::mutable_outer_join_support() {
  // @@protoc_insertion_point(field_mutable_list:exec.user.ServerMeta.outer_join_support)
  return _internal_mutable_outer_join_support();
}
inline ::exec::user::OuterJoinSupport ServerMeta::_internal_outer_join_support(int index) const {
  return static_cast<::exec::user::OuterJoinSupport>(_impl_.outer_join_support_.Get(index));
}
inline void ServerMeta::_internal_add_outer_join_support(::exec::user::OuterJoinSupport value) {
  assert(::exec::user::OuterJoinSupport_IsValid(value));
  _impl_.outer_join_support_.Add(value);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* ServerMeta::_internal_mutable_outer_join_support() {
  return &_impl_.outer_join_support_;
}

// optional .exec.user.IdentifierCasing quoted_identifier_casing = 37;
inline bool ServerMeta::has_quoted_identifier_casing() const {
  bool value = (_impl_._has_bits_[1] & 0x00000004u) != 0;
  return value;
}
inline void ServerMeta::clear_quoted_identifier_casing() {
  _impl_.quoted_identifier_casing_ = 0;
  _impl_._has_bits_[1] &= ~0x00000004u;
}
inline ::exec::user::IdentifierCasing ServerMeta::quoted_identifier_casing() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.quoted_identifier_casing)
  return _internal_quoted_identifier_casing();
}
inline void ServerMeta::set_quoted_identifier_casing(::exec::user::IdentifierCasing value) {
   _internal_set_quoted_identifier_casing(value);
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.quoted_identifier_casing)
}
inline ::exec::user::IdentifierCasing ServerMeta::_internal_quoted_identifier_casing() const {
  return static_cast<::exec::user::IdentifierCasing>(_impl_.quoted_identifier_casing_);
}
inline void ServerMeta::_internal_set_quoted_identifier_casing(::exec::user::IdentifierCasing value) {
  assert(::exec::user::IdentifierCasing_IsValid(value));
  _impl_._has_bits_[1] |= 0x00000004u;
  _impl_.quoted_identifier_casing_ = value;
}

// optional bool read_only = 38;
inline bool ServerMeta::has_read_only() const {
  bool value = (_impl_._has_bits_[0] & 0x80000000u) != 0;
  return value;
}
inline void ServerMeta::clear_read_only() {
  _impl_.read_only_ = false;
  _impl_._has_bits_[0] &= ~0x80000000u;
}
inline bool ServerMeta::read_only() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.read_only)
  return _internal_read_only();
}
inline void ServerMeta::set_read_only(bool value) {
  _internal_set_read_only(value);
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.read_only)
}
inline bool ServerMeta::_internal_read_only() const {
  return _impl_.read_only_;
}
inline void ServerMeta::_internal_set_read_only(bool value) {
  _impl_._has_bits_[0] |= 0x80000000u;
  _impl_.read_only_ = value;
}

// optional string schema_term = 39;
inline bool ServerMeta::has_schema_term() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void ServerMeta::clear_schema_term() {
  _impl_.schema_term_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ServerMeta::schema_term() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.schema_term)
  return _internal_schema_term();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ServerMeta::set_schema_term(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.schema_term_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.schema_term)
}
inline std::string* ServerMeta::mutable_schema_term() {
  std::string* _s = _internal_mutable_schema_term();
  // @@protoc_insertion_point(field_mutable:exec.user.ServerMeta.schema_term)
  return _s;
}
inline const std::string& ServerMeta::_internal_schema_term() const {
  return _impl_.schema_term_.Get();
}
inline void ServerMeta::_internal_set_schema_term(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;


  _impl_.schema_term_.Set(value, GetArenaForAllocation());
}
inline std::string* ServerMeta::_internal_mutable_schema_term() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.schema_term_.Mutable( GetArenaForAllocation());
}
inline std::string* ServerMeta::release_schema_term() {
  // @@protoc_insertion_point(field_release:exec.user.ServerMeta.schema_term)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.schema_term_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.schema_term_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ServerMeta::set_allocated_schema_term(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.schema_term_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.schema_term_.IsDefault()) {
          _impl_.schema_term_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.user.ServerMeta.schema_term)
}

// optional string search_escape_string = 40;
inline bool ServerMeta::has_search_escape_string() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void ServerMeta::clear_search_escape_string() {
  _impl_.search_escape_string_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& ServerMeta::search_escape_string() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.search_escape_string)
  return _internal_search_escape_string();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ServerMeta::set_search_escape_string(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.search_escape_string_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.search_escape_string)
}
inline std::string* ServerMeta::mutable_search_escape_string() {
  std::string* _s = _internal_mutable_search_escape_string();
  // @@protoc_insertion_point(field_mutable:exec.user.ServerMeta.search_escape_string)
  return _s;
}
inline const std::string& ServerMeta::_internal_search_escape_string() const {
  return _impl_.search_escape_string_.Get();
}
inline void ServerMeta::_internal_set_search_escape_string(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000010u;


  _impl_.search_escape_string_.Set(value, GetArenaForAllocation());
}
inline std::string* ServerMeta::_internal_mutable_search_escape_string() {
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.search_escape_string_.Mutable( GetArenaForAllocation());
}
inline std::string* ServerMeta::release_search_escape_string() {
  // @@protoc_insertion_point(field_release:exec.user.ServerMeta.search_escape_string)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.search_escape_string_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.search_escape_string_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ServerMeta::set_allocated_search_escape_string(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.search_escape_string_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.search_escape_string_.IsDefault()) {
          _impl_.search_escape_string_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.user.ServerMeta.search_escape_string)
}

// optional bool select_for_update_supported = 41;
inline bool ServerMeta::has_select_for_update_supported() const {
  bool value = (_impl_._has_bits_[1] & 0x00000001u) != 0;
  return value;
}
inline void ServerMeta::clear_select_for_update_supported() {
  _impl_.select_for_update_supported_ = false;
  _impl_._has_bits_[1] &= ~0x00000001u;
}
inline bool ServerMeta::select_for_update_supported() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.select_for_update_supported)
  return _internal_select_for_update_supported();
}
inline void ServerMeta::set_select_for_update_supported(bool value) {
  _internal_set_select_for_update_supported(value);
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.select_for_update_supported)
}
inline bool ServerMeta::_internal_select_for_update_supported() const {
  return _impl_.select_for_update_supported_;
}
inline void ServerMeta::_internal_set_select_for_update_supported(bool value) {
  _impl_._has_bits_[1] |= 0x00000001u;
  _impl_.select_for_update_supported_ = value;
}

// optional string special_characters = 42;
inline bool ServerMeta::has_special_characters() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void ServerMeta::clear_special_characters() {
  _impl_.special_characters_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& ServerMeta::special_characters() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.special_characters)
  return _internal_special_characters();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ServerMeta::set_special_characters(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.special_characters_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.special_characters)
}
inline std::string* ServerMeta::mutable_special_characters() {
  std::string* _s = _internal_mutable_special_characters();
  // @@protoc_insertion_point(field_mutable:exec.user.ServerMeta.special_characters)
  return _s;
}
inline const std::string& ServerMeta::_internal_special_characters() const {
  return _impl_.special_characters_.Get();
}
inline void ServerMeta::_internal_set_special_characters(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000020u;


  _impl_.special_characters_.Set(value, GetArenaForAllocation());
}
inline std::string* ServerMeta::_internal_mutable_special_characters() {
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.special_characters_.Mutable( GetArenaForAllocation());
}
inline std::string* ServerMeta::release_special_characters() {
  // @@protoc_insertion_point(field_release:exec.user.ServerMeta.special_characters)
  if ((_impl_._has_bits_[0] & 0x00000020u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* released = _impl_.special_characters_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.special_characters_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ServerMeta::set_allocated_special_characters(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.special_characters_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.special_characters_.IsDefault()) {
          _impl_.special_characters_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.user.ServerMeta.special_characters)
}

// repeated string sql_keywords = 43;
inline int ServerMeta::_internal_sql_keywords_size() const {
  return _impl_.sql_keywords_.size();
}
inline int ServerMeta::sql_keywords_size() const {
  return _internal_sql_keywords_size();
}
inline void ServerMeta::clear_sql_keywords() {
  _impl_.sql_keywords_.Clear();
}
inline std::string* ServerMeta::add_sql_keywords() {
  std::string* _s = _internal_add_sql_keywords();
  // @@protoc_insertion_point(field_add_mutable:exec.user.ServerMeta.sql_keywords)
  return _s;
}
inline const std::string& ServerMeta::_internal_sql_keywords(int index) const {
  return _impl_.sql_keywords_.Get(index);
}
inline const std::string& ServerMeta::sql_keywords(int index) const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.sql_keywords)
  return _internal_sql_keywords(index);
}
inline std::string* ServerMeta::mutable_sql_keywords(int index) {
  // @@protoc_insertion_point(field_mutable:exec.user.ServerMeta.sql_keywords)
  return _impl_.sql_keywords_.Mutable(index);
}
inline void ServerMeta::set_sql_keywords(int index, const std::string& value) {
  _impl_.sql_keywords_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.sql_keywords)
}
inline void ServerMeta::set_sql_keywords(int index, std::string&& value) {
  _impl_.sql_keywords_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.sql_keywords)
}
inline void ServerMeta::set_sql_keywords(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _impl_.sql_keywords_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:exec.user.ServerMeta.sql_keywords)
}
inline void ServerMeta::set_sql_keywords(int index, const char* value,
                              std::size_t size) {
  _impl_.sql_keywords_.Mutable(index)->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:exec.user.ServerMeta.sql_keywords)
}
inline void ServerMeta::set_sql_keywords(int index, absl::string_view value) {
  _impl_.sql_keywords_.Mutable(index)->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:exec.user.ServerMeta.sql_keywords)
}
inline std::string* ServerMeta::_internal_add_sql_keywords() { return _impl_.sql_keywords_.Add(); }
inline void ServerMeta::add_sql_keywords(const std::string& value) {
  _impl_.sql_keywords_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:exec.user.ServerMeta.sql_keywords)
}
inline void ServerMeta::add_sql_keywords(std::string&& value) {
  _impl_.sql_keywords_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:exec.user.ServerMeta.sql_keywords)
}
inline void ServerMeta::add_sql_keywords(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _impl_.sql_keywords_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:exec.user.ServerMeta.sql_keywords)
}
inline void ServerMeta::add_sql_keywords(const char* value, std::size_t size) {
  _impl_.sql_keywords_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:exec.user.ServerMeta.sql_keywords)
}
inline void ServerMeta::add_sql_keywords(absl::string_view value) {
  _impl_.sql_keywords_.Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:exec.user.ServerMeta.sql_keywords)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ServerMeta::sql_keywords() const {
  // @@protoc_insertion_point(field_list:exec.user.ServerMeta.sql_keywords)
  return _impl_.sql_keywords_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* ServerMeta::mutable_sql_keywords() {
  // @@protoc_insertion_point(field_mutable_list:exec.user.ServerMeta.sql_keywords)
  return &_impl_.sql_keywords_;
}

// repeated string string_functions = 44;
inline int ServerMeta::_internal_string_functions_size() const {
  return _impl_.string_functions_.size();
}
inline int ServerMeta::string_functions_size() const {
  return _internal_string_functions_size();
}
inline void ServerMeta::clear_string_functions() {
  _impl_.string_functions_.Clear();
}
inline std::string* ServerMeta::add_string_functions() {
  std::string* _s = _internal_add_string_functions();
  // @@protoc_insertion_point(field_add_mutable:exec.user.ServerMeta.string_functions)
  return _s;
}
inline const std::string& ServerMeta::_internal_string_functions(int index) const {
  return _impl_.string_functions_.Get(index);
}
inline const std::string& ServerMeta::string_functions(int index) const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.string_functions)
  return _internal_string_functions(index);
}
inline std::string* ServerMeta::mutable_string_functions(int index) {
  // @@protoc_insertion_point(field_mutable:exec.user.ServerMeta.string_functions)
  return _impl_.string_functions_.Mutable(index);
}
inline void ServerMeta::set_string_functions(int index, const std::string& value) {
  _impl_.string_functions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.string_functions)
}
inline void ServerMeta::set_string_functions(int index, std::string&& value) {
  _impl_.string_functions_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.string_functions)
}
inline void ServerMeta::set_string_functions(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _impl_.string_functions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:exec.user.ServerMeta.string_functions)
}
inline void ServerMeta::set_string_functions(int index, const char* value,
                              std::size_t size) {
  _impl_.string_functions_.Mutable(index)->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:exec.user.ServerMeta.string_functions)
}
inline void ServerMeta::set_string_functions(int index, absl::string_view value) {
  _impl_.string_functions_.Mutable(index)->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:exec.user.ServerMeta.string_functions)
}
inline std::string* ServerMeta::_internal_add_string_functions() { return _impl_.string_functions_.Add(); }
inline void ServerMeta::add_string_functions(const std::string& value) {
  _impl_.string_functions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:exec.user.ServerMeta.string_functions)
}
inline void ServerMeta::add_string_functions(std::string&& value) {
  _impl_.string_functions_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:exec.user.ServerMeta.string_functions)
}
inline void ServerMeta::add_string_functions(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _impl_.string_functions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:exec.user.ServerMeta.string_functions)
}
inline void ServerMeta::add_string_functions(const char* value, std::size_t size) {
  _impl_.string_functions_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:exec.user.ServerMeta.string_functions)
}
inline void ServerMeta::add_string_functions(absl::string_view value) {
  _impl_.string_functions_.Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:exec.user.ServerMeta.string_functions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ServerMeta::string_functions() const {
  // @@protoc_insertion_point(field_list:exec.user.ServerMeta.string_functions)
  return _impl_.string_functions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* ServerMeta::mutable_string_functions() {
  // @@protoc_insertion_point(field_mutable_list:exec.user.ServerMeta.string_functions)
  return &_impl_.string_functions_;
}

// repeated .exec.user.SubQuerySupport subquery_support = 45;
inline int ServerMeta::_internal_subquery_support_size() const {
  return _impl_.subquery_support_.size();
}
inline int ServerMeta::subquery_support_size() const {
  return _internal_subquery_support_size();
}
inline void ServerMeta::clear_subquery_support() {
  _impl_.subquery_support_.Clear();
}
inline ::exec::user::SubQuerySupport ServerMeta::subquery_support(int index) const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.subquery_support)
  return _internal_subquery_support(index);
}
inline void ServerMeta::set_subquery_support(int index, ::exec::user::SubQuerySupport value) {
  assert(::exec::user::SubQuerySupport_IsValid(value));
  _impl_.subquery_support_.Set(index, value);
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.subquery_support)
}
inline void ServerMeta::add_subquery_support(::exec::user::SubQuerySupport value) {
  _internal_add_subquery_support(value);
  // @@protoc_insertion_point(field_add:exec.user.ServerMeta.subquery_support)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& ServerMeta::subquery_support() const {
  // @@protoc_insertion_point(field_list:exec.user.ServerMeta.subquery_support)
  return _impl_.subquery_support_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* ServerMeta::mutable_subquery_support() {
  // @@protoc_insertion_point(field_mutable_list:exec.user.ServerMeta.subquery_support)
  return _internal_mutable_subquery_support();
}
inline ::exec::user::SubQuerySupport ServerMeta::_internal_subquery_support(int index) const {
  return static_cast<::exec::user::SubQuerySupport>(_impl_.subquery_support_.Get(index));
}
inline void ServerMeta::_internal_add_subquery_support(::exec::user::SubQuerySupport value) {
  assert(::exec::user::SubQuerySupport_IsValid(value));
  _impl_.subquery_support_.Add(value);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* ServerMeta::_internal_mutable_subquery_support() {
  return &_impl_.subquery_support_;
}

// repeated string system_functions = 46;
inline int ServerMeta::_internal_system_functions_size() const {
  return _impl_.system_functions_.size();
}
inline int ServerMeta::system_functions_size() const {
  return _internal_system_functions_size();
}
inline void ServerMeta::clear_system_functions() {
  _impl_.system_functions_.Clear();
}
inline std::string* ServerMeta::add_system_functions() {
  std::string* _s = _internal_add_system_functions();
  // @@protoc_insertion_point(field_add_mutable:exec.user.ServerMeta.system_functions)
  return _s;
}
inline const std::string& ServerMeta::_internal_system_functions(int index) const {
  return _impl_.system_functions_.Get(index);
}
inline const std::string& ServerMeta::system_functions(int index) const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.system_functions)
  return _internal_system_functions(index);
}
inline std::string* ServerMeta::mutable_system_functions(int index) {
  // @@protoc_insertion_point(field_mutable:exec.user.ServerMeta.system_functions)
  return _impl_.system_functions_.Mutable(index);
}
inline void ServerMeta::set_system_functions(int index, const std::string& value) {
  _impl_.system_functions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.system_functions)
}
inline void ServerMeta::set_system_functions(int index, std::string&& value) {
  _impl_.system_functions_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.system_functions)
}
inline void ServerMeta::set_system_functions(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _impl_.system_functions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:exec.user.ServerMeta.system_functions)
}
inline void ServerMeta::set_system_functions(int index, const char* value,
                              std::size_t size) {
  _impl_.system_functions_.Mutable(index)->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:exec.user.ServerMeta.system_functions)
}
inline void ServerMeta::set_system_functions(int index, absl::string_view value) {
  _impl_.system_functions_.Mutable(index)->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:exec.user.ServerMeta.system_functions)
}
inline std::string* ServerMeta::_internal_add_system_functions() { return _impl_.system_functions_.Add(); }
inline void ServerMeta::add_system_functions(const std::string& value) {
  _impl_.system_functions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:exec.user.ServerMeta.system_functions)
}
inline void ServerMeta::add_system_functions(std::string&& value) {
  _impl_.system_functions_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:exec.user.ServerMeta.system_functions)
}
inline void ServerMeta::add_system_functions(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _impl_.system_functions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:exec.user.ServerMeta.system_functions)
}
inline void ServerMeta::add_system_functions(const char* value, std::size_t size) {
  _impl_.system_functions_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:exec.user.ServerMeta.system_functions)
}
inline void ServerMeta::add_system_functions(absl::string_view value) {
  _impl_.system_functions_.Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:exec.user.ServerMeta.system_functions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ServerMeta::system_functions() const {
  // @@protoc_insertion_point(field_list:exec.user.ServerMeta.system_functions)
  return _impl_.system_functions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* ServerMeta::mutable_system_functions() {
  // @@protoc_insertion_point(field_mutable_list:exec.user.ServerMeta.system_functions)
  return &_impl_.system_functions_;
}

// optional string table_term = 47;
inline bool ServerMeta::has_table_term() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void ServerMeta::clear_table_term() {
  _impl_.table_term_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& ServerMeta::table_term() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.table_term)
  return _internal_table_term();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ServerMeta::set_table_term(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.table_term_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.table_term)
}
inline std::string* ServerMeta::mutable_table_term() {
  std::string* _s = _internal_mutable_table_term();
  // @@protoc_insertion_point(field_mutable:exec.user.ServerMeta.table_term)
  return _s;
}
inline const std::string& ServerMeta::_internal_table_term() const {
  return _impl_.table_term_.Get();
}
inline void ServerMeta::_internal_set_table_term(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000040u;


  _impl_.table_term_.Set(value, GetArenaForAllocation());
}
inline std::string* ServerMeta::_internal_mutable_table_term() {
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.table_term_.Mutable( GetArenaForAllocation());
}
inline std::string* ServerMeta::release_table_term() {
  // @@protoc_insertion_point(field_release:exec.user.ServerMeta.table_term)
  if ((_impl_._has_bits_[0] & 0x00000040u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* released = _impl_.table_term_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.table_term_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ServerMeta::set_allocated_table_term(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.table_term_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.table_term_.IsDefault()) {
          _impl_.table_term_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.user.ServerMeta.table_term)
}

// optional bool transaction_supported = 48;
inline bool ServerMeta::has_transaction_supported() const {
  bool value = (_impl_._has_bits_[1] & 0x00000008u) != 0;
  return value;
}
inline void ServerMeta::clear_transaction_supported() {
  _impl_.transaction_supported_ = false;
  _impl_._has_bits_[1] &= ~0x00000008u;
}
inline bool ServerMeta::transaction_supported() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.transaction_supported)
  return _internal_transaction_supported();
}
inline void ServerMeta::set_transaction_supported(bool value) {
  _internal_set_transaction_supported(value);
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.transaction_supported)
}
inline bool ServerMeta::_internal_transaction_supported() const {
  return _impl_.transaction_supported_;
}
inline void ServerMeta::_internal_set_transaction_supported(bool value) {
  _impl_._has_bits_[1] |= 0x00000008u;
  _impl_.transaction_supported_ = value;
}

// repeated .exec.user.UnionSupport union_support = 49;
inline int ServerMeta::_internal_union_support_size() const {
  return _impl_.union_support_.size();
}
inline int ServerMeta::union_support_size() const {
  return _internal_union_support_size();
}
inline void ServerMeta::clear_union_support() {
  _impl_.union_support_.Clear();
}
inline ::exec::user::UnionSupport ServerMeta::union_support(int index) const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.union_support)
  return _internal_union_support(index);
}
inline void ServerMeta::set_union_support(int index, ::exec::user::UnionSupport value) {
  assert(::exec::user::UnionSupport_IsValid(value));
  _impl_.union_support_.Set(index, value);
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.union_support)
}
inline void ServerMeta::add_union_support(::exec::user::UnionSupport value) {
  _internal_add_union_support(value);
  // @@protoc_insertion_point(field_add:exec.user.ServerMeta.union_support)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& ServerMeta::union_support() const {
  // @@protoc_insertion_point(field_list:exec.user.ServerMeta.union_support)
  return _impl_.union_support_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* ServerMeta::mutable_union_support() {
  // @@protoc_insertion_point(field_mutable_list:exec.user.ServerMeta.union_support)
  return _internal_mutable_union_support();
}
inline ::exec::user::UnionSupport ServerMeta::_internal_union_support(int index) const {
  return static_cast<::exec::user::UnionSupport>(_impl_.union_support_.Get(index));
}
inline void ServerMeta::_internal_add_union_support(::exec::user::UnionSupport value) {
  assert(::exec::user::UnionSupport_IsValid(value));
  _impl_.union_support_.Add(value);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* ServerMeta::_internal_mutable_union_support() {
  return &_impl_.union_support_;
}

// optional string current_schema = 50;
inline bool ServerMeta::has_current_schema() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void ServerMeta::clear_current_schema() {
  _impl_.current_schema_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const std::string& ServerMeta::current_schema() const {
  // @@protoc_insertion_point(field_get:exec.user.ServerMeta.current_schema)
  return _internal_current_schema();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ServerMeta::set_current_schema(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.current_schema_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.user.ServerMeta.current_schema)
}
inline std::string* ServerMeta::mutable_current_schema() {
  std::string* _s = _internal_mutable_current_schema();
  // @@protoc_insertion_point(field_mutable:exec.user.ServerMeta.current_schema)
  return _s;
}
inline const std::string& ServerMeta::_internal_current_schema() const {
  return _impl_.current_schema_.Get();
}
inline void ServerMeta::_internal_set_current_schema(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000080u;


  _impl_.current_schema_.Set(value, GetArenaForAllocation());
}
inline std::string* ServerMeta::_internal_mutable_current_schema() {
  _impl_._has_bits_[0] |= 0x00000080u;
  return _impl_.current_schema_.Mutable( GetArenaForAllocation());
}
inline std::string* ServerMeta::release_current_schema() {
  // @@protoc_insertion_point(field_release:exec.user.ServerMeta.current_schema)
  if ((_impl_._has_bits_[0] & 0x00000080u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000080u;
  auto* released = _impl_.current_schema_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.current_schema_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ServerMeta::set_allocated_current_schema(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.current_schema_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.current_schema_.IsDefault()) {
          _impl_.current_schema_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.user.ServerMeta.current_schema)
}

// -------------------------------------------------------------------

// RunQuery

// optional .exec.user.QueryResultsMode results_mode = 1;
inline bool RunQuery::has_results_mode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void RunQuery::clear_results_mode() {
  _impl_.results_mode_ = 1;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::exec::user::QueryResultsMode RunQuery::results_mode() const {
  // @@protoc_insertion_point(field_get:exec.user.RunQuery.results_mode)
  return _internal_results_mode();
}
inline void RunQuery::set_results_mode(::exec::user::QueryResultsMode value) {
   _internal_set_results_mode(value);
  // @@protoc_insertion_point(field_set:exec.user.RunQuery.results_mode)
}
inline ::exec::user::QueryResultsMode RunQuery::_internal_results_mode() const {
  return static_cast<::exec::user::QueryResultsMode>(_impl_.results_mode_);
}
inline void RunQuery::_internal_set_results_mode(::exec::user::QueryResultsMode value) {
  assert(::exec::user::QueryResultsMode_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.results_mode_ = value;
}

// optional .exec.shared.QueryType type = 2;
inline bool RunQuery::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void RunQuery::clear_type() {
  _impl_.type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::exec::shared::QueryType RunQuery::type() const {
  // @@protoc_insertion_point(field_get:exec.user.RunQuery.type)
  return _internal_type();
}
inline void RunQuery::set_type(::exec::shared::QueryType value) {
   _internal_set_type(value);
  // @@protoc_insertion_point(field_set:exec.user.RunQuery.type)
}
inline ::exec::shared::QueryType RunQuery::_internal_type() const {
  return static_cast<::exec::shared::QueryType>(_impl_.type_);
}
inline void RunQuery::_internal_set_type(::exec::shared::QueryType value) {
  assert(::exec::shared::QueryType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.type_ = value;
}

// optional string plan = 3;
inline bool RunQuery::has_plan() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RunQuery::clear_plan() {
  _impl_.plan_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RunQuery::plan() const {
  // @@protoc_insertion_point(field_get:exec.user.RunQuery.plan)
  return _internal_plan();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RunQuery::set_plan(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.plan_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.user.RunQuery.plan)
}
inline std::string* RunQuery::mutable_plan() {
  std::string* _s = _internal_mutable_plan();
  // @@protoc_insertion_point(field_mutable:exec.user.RunQuery.plan)
  return _s;
}
inline const std::string& RunQuery::_internal_plan() const {
  return _impl_.plan_.Get();
}
inline void RunQuery::_internal_set_plan(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.plan_.Set(value, GetArenaForAllocation());
}
inline std::string* RunQuery::_internal_mutable_plan() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.plan_.Mutable( GetArenaForAllocation());
}
inline std::string* RunQuery::release_plan() {
  // @@protoc_insertion_point(field_release:exec.user.RunQuery.plan)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.plan_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.plan_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RunQuery::set_allocated_plan(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.plan_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.plan_.IsDefault()) {
          _impl_.plan_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.user.RunQuery.plan)
}

// repeated .exec.bit.control.PlanFragment fragments = 4;
inline int RunQuery::_internal_fragments_size() const {
  return _impl_.fragments_.size();
}
inline int RunQuery::fragments_size() const {
  return _internal_fragments_size();
}
inline ::exec::bit::control::PlanFragment* RunQuery::mutable_fragments(int index) {
  // @@protoc_insertion_point(field_mutable:exec.user.RunQuery.fragments)
  return _impl_.fragments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::bit::control::PlanFragment >*
RunQuery::mutable_fragments() {
  // @@protoc_insertion_point(field_mutable_list:exec.user.RunQuery.fragments)
  return &_impl_.fragments_;
}
inline const ::exec::bit::control::PlanFragment& RunQuery::_internal_fragments(int index) const {
  return _impl_.fragments_.Get(index);
}
inline const ::exec::bit::control::PlanFragment& RunQuery::fragments(int index) const {
  // @@protoc_insertion_point(field_get:exec.user.RunQuery.fragments)
  return _internal_fragments(index);
}
inline ::exec::bit::control::PlanFragment* RunQuery::_internal_add_fragments() {
  return _impl_.fragments_.Add();
}
inline ::exec::bit::control::PlanFragment* RunQuery::add_fragments() {
  ::exec::bit::control::PlanFragment* _add = _internal_add_fragments();
  // @@protoc_insertion_point(field_add:exec.user.RunQuery.fragments)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::bit::control::PlanFragment >&
RunQuery::fragments() const {
  // @@protoc_insertion_point(field_list:exec.user.RunQuery.fragments)
  return _impl_.fragments_;
}

// optional .exec.user.PreparedStatementHandle prepared_statement_handle = 5;
inline bool RunQuery::has_prepared_statement_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.prepared_statement_handle_ != nullptr);
  return value;
}
inline void RunQuery::clear_prepared_statement_handle() {
  if (_impl_.prepared_statement_handle_ != nullptr) _impl_.prepared_statement_handle_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::exec::user::PreparedStatementHandle& RunQuery::_internal_prepared_statement_handle() const {
  const ::exec::user::PreparedStatementHandle* p = _impl_.prepared_statement_handle_;
  return p != nullptr ? *p : reinterpret_cast<const ::exec::user::PreparedStatementHandle&>(
      ::exec::user::_PreparedStatementHandle_default_instance_);
}
inline const ::exec::user::PreparedStatementHandle& RunQuery::prepared_statement_handle() const {
  // @@protoc_insertion_point(field_get:exec.user.RunQuery.prepared_statement_handle)
  return _internal_prepared_statement_handle();
}
inline void RunQuery::unsafe_arena_set_allocated_prepared_statement_handle(
    ::exec::user::PreparedStatementHandle* prepared_statement_handle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.prepared_statement_handle_);
  }
  _impl_.prepared_statement_handle_ = prepared_statement_handle;
  if (prepared_statement_handle) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:exec.user.RunQuery.prepared_statement_handle)
}
inline ::exec::user::PreparedStatementHandle* RunQuery::release_prepared_statement_handle() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::exec::user::PreparedStatementHandle* temp = _impl_.prepared_statement_handle_;
  _impl_.prepared_statement_handle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exec::user::PreparedStatementHandle* RunQuery::unsafe_arena_release_prepared_statement_handle() {
  // @@protoc_insertion_point(field_release:exec.user.RunQuery.prepared_statement_handle)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::exec::user::PreparedStatementHandle* temp = _impl_.prepared_statement_handle_;
  _impl_.prepared_statement_handle_ = nullptr;
  return temp;
}
inline ::exec::user::PreparedStatementHandle* RunQuery::_internal_mutable_prepared_statement_handle() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.prepared_statement_handle_ == nullptr) {
    auto* p = CreateMaybeMessage<::exec::user::PreparedStatementHandle>(GetArenaForAllocation());
    _impl_.prepared_statement_handle_ = p;
  }
  return _impl_.prepared_statement_handle_;
}
inline ::exec::user::PreparedStatementHandle* RunQuery::mutable_prepared_statement_handle() {
  ::exec::user::PreparedStatementHandle* _msg = _internal_mutable_prepared_statement_handle();
  // @@protoc_insertion_point(field_mutable:exec.user.RunQuery.prepared_statement_handle)
  return _msg;
}
inline void RunQuery::set_allocated_prepared_statement_handle(::exec::user::PreparedStatementHandle* prepared_statement_handle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.prepared_statement_handle_;
  }
  if (prepared_statement_handle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(prepared_statement_handle);
    if (message_arena != submessage_arena) {
      prepared_statement_handle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, prepared_statement_handle, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.prepared_statement_handle_ = prepared_statement_handle;
  // @@protoc_insertion_point(field_set_allocated:exec.user.RunQuery.prepared_statement_handle)
}

// optional int32 autolimit_rowcount = 6;
inline bool RunQuery::has_autolimit_rowcount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void RunQuery::clear_autolimit_rowcount() {
  _impl_.autolimit_rowcount_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t RunQuery::autolimit_rowcount() const {
  // @@protoc_insertion_point(field_get:exec.user.RunQuery.autolimit_rowcount)
  return _internal_autolimit_rowcount();
}
inline void RunQuery::set_autolimit_rowcount(::int32_t value) {
  _internal_set_autolimit_rowcount(value);
  // @@protoc_insertion_point(field_set:exec.user.RunQuery.autolimit_rowcount)
}
inline ::int32_t RunQuery::_internal_autolimit_rowcount() const {
  return _impl_.autolimit_rowcount_;
}
inline void RunQuery::_internal_set_autolimit_rowcount(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.autolimit_rowcount_ = value;
}

// -------------------------------------------------------------------

// NewSessionRequest

// optional .exec.user.UserProperties properties = 1;
inline bool NewSessionRequest::has_properties() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.properties_ != nullptr);
  return value;
}
inline void NewSessionRequest::clear_properties() {
  if (_impl_.properties_ != nullptr) _impl_.properties_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::exec::user::UserProperties& NewSessionRequest::_internal_properties() const {
  const ::exec::user::UserProperties* p = _impl_.properties_;
  return p != nullptr ? *p : reinterpret_cast<const ::exec::user::UserProperties&>(
      ::exec::user::_UserProperties_default_instance_);
}
inline const ::exec::user::UserProperties& NewSessionRequest::properties() const {
  // @@protoc_insertion_point(field_get:exec.user.NewSessionRequest.properties)
  return _internal_properties();
}
inline void NewSessionRequest::unsafe_arena_set_allocated_properties(
    ::exec::user::UserProperties* properties) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.properties_);
  }
  _impl_.properties_ = properties;
  if (properties) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:exec.user.NewSessionRequest.properties)
}
inline ::exec::user::UserProperties* NewSessionRequest::release_properties() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::exec::user::UserProperties* temp = _impl_.properties_;
  _impl_.properties_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exec::user::UserProperties* NewSessionRequest::unsafe_arena_release_properties() {
  // @@protoc_insertion_point(field_release:exec.user.NewSessionRequest.properties)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::exec::user::UserProperties* temp = _impl_.properties_;
  _impl_.properties_ = nullptr;
  return temp;
}
inline ::exec::user::UserProperties* NewSessionRequest::_internal_mutable_properties() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.properties_ == nullptr) {
    auto* p = CreateMaybeMessage<::exec::user::UserProperties>(GetArenaForAllocation());
    _impl_.properties_ = p;
  }
  return _impl_.properties_;
}
inline ::exec::user::UserProperties* NewSessionRequest::mutable_properties() {
  ::exec::user::UserProperties* _msg = _internal_mutable_properties();
  // @@protoc_insertion_point(field_mutable:exec.user.NewSessionRequest.properties)
  return _msg;
}
inline void NewSessionRequest::set_allocated_properties(::exec::user::UserProperties* properties) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.properties_;
  }
  if (properties) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(properties);
    if (message_arena != submessage_arena) {
      properties = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, properties, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.properties_ = properties;
  // @@protoc_insertion_point(field_set_allocated:exec.user.NewSessionRequest.properties)
}

// -------------------------------------------------------------------

// SessionHandle

// optional string session_id = 1;
inline bool SessionHandle::has_session_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SessionHandle::clear_session_id() {
  _impl_.session_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SessionHandle::session_id() const {
  // @@protoc_insertion_point(field_get:exec.user.SessionHandle.session_id)
  return _internal_session_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SessionHandle::set_session_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.session_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.user.SessionHandle.session_id)
}
inline std::string* SessionHandle::mutable_session_id() {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:exec.user.SessionHandle.session_id)
  return _s;
}
inline const std::string& SessionHandle::_internal_session_id() const {
  return _impl_.session_id_.Get();
}
inline void SessionHandle::_internal_set_session_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.session_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SessionHandle::_internal_mutable_session_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.session_id_.Mutable( GetArenaForAllocation());
}
inline std::string* SessionHandle::release_session_id() {
  // @@protoc_insertion_point(field_release:exec.user.SessionHandle.session_id)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.session_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.session_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SessionHandle::set_allocated_session_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.session_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.session_id_.IsDefault()) {
          _impl_.session_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.user.SessionHandle.session_id)
}

// -------------------------------------------------------------------

// RunQueryWithSessionHandle

// optional .exec.user.RunQuery runQuery = 1;
inline bool RunQueryWithSessionHandle::has_runquery() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.runquery_ != nullptr);
  return value;
}
inline void RunQueryWithSessionHandle::clear_runquery() {
  if (_impl_.runquery_ != nullptr) _impl_.runquery_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::exec::user::RunQuery& RunQueryWithSessionHandle::_internal_runquery() const {
  const ::exec::user::RunQuery* p = _impl_.runquery_;
  return p != nullptr ? *p : reinterpret_cast<const ::exec::user::RunQuery&>(
      ::exec::user::_RunQuery_default_instance_);
}
inline const ::exec::user::RunQuery& RunQueryWithSessionHandle::runquery() const {
  // @@protoc_insertion_point(field_get:exec.user.RunQueryWithSessionHandle.runQuery)
  return _internal_runquery();
}
inline void RunQueryWithSessionHandle::unsafe_arena_set_allocated_runquery(
    ::exec::user::RunQuery* runquery) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.runquery_);
  }
  _impl_.runquery_ = runquery;
  if (runquery) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:exec.user.RunQueryWithSessionHandle.runQuery)
}
inline ::exec::user::RunQuery* RunQueryWithSessionHandle::release_runquery() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::exec::user::RunQuery* temp = _impl_.runquery_;
  _impl_.runquery_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exec::user::RunQuery* RunQueryWithSessionHandle::unsafe_arena_release_runquery() {
  // @@protoc_insertion_point(field_release:exec.user.RunQueryWithSessionHandle.runQuery)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::exec::user::RunQuery* temp = _impl_.runquery_;
  _impl_.runquery_ = nullptr;
  return temp;
}
inline ::exec::user::RunQuery* RunQueryWithSessionHandle::_internal_mutable_runquery() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.runquery_ == nullptr) {
    auto* p = CreateMaybeMessage<::exec::user::RunQuery>(GetArenaForAllocation());
    _impl_.runquery_ = p;
  }
  return _impl_.runquery_;
}
inline ::exec::user::RunQuery* RunQueryWithSessionHandle::mutable_runquery() {
  ::exec::user::RunQuery* _msg = _internal_mutable_runquery();
  // @@protoc_insertion_point(field_mutable:exec.user.RunQueryWithSessionHandle.runQuery)
  return _msg;
}
inline void RunQueryWithSessionHandle::set_allocated_runquery(::exec::user::RunQuery* runquery) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.runquery_;
  }
  if (runquery) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(runquery);
    if (message_arena != submessage_arena) {
      runquery = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, runquery, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.runquery_ = runquery;
  // @@protoc_insertion_point(field_set_allocated:exec.user.RunQueryWithSessionHandle.runQuery)
}

// optional .exec.user.SessionHandle sessionHandle = 2;
inline bool RunQueryWithSessionHandle::has_sessionhandle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sessionhandle_ != nullptr);
  return value;
}
inline void RunQueryWithSessionHandle::clear_sessionhandle() {
  if (_impl_.sessionhandle_ != nullptr) _impl_.sessionhandle_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::exec::user::SessionHandle& RunQueryWithSessionHandle::_internal_sessionhandle() const {
  const ::exec::user::SessionHandle* p = _impl_.sessionhandle_;
  return p != nullptr ? *p : reinterpret_cast<const ::exec::user::SessionHandle&>(
      ::exec::user::_SessionHandle_default_instance_);
}
inline const ::exec::user::SessionHandle& RunQueryWithSessionHandle::sessionhandle() const {
  // @@protoc_insertion_point(field_get:exec.user.RunQueryWithSessionHandle.sessionHandle)
  return _internal_sessionhandle();
}
inline void RunQueryWithSessionHandle::unsafe_arena_set_allocated_sessionhandle(
    ::exec::user::SessionHandle* sessionhandle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sessionhandle_);
  }
  _impl_.sessionhandle_ = sessionhandle;
  if (sessionhandle) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:exec.user.RunQueryWithSessionHandle.sessionHandle)
}
inline ::exec::user::SessionHandle* RunQueryWithSessionHandle::release_sessionhandle() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::exec::user::SessionHandle* temp = _impl_.sessionhandle_;
  _impl_.sessionhandle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exec::user::SessionHandle* RunQueryWithSessionHandle::unsafe_arena_release_sessionhandle() {
  // @@protoc_insertion_point(field_release:exec.user.RunQueryWithSessionHandle.sessionHandle)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::exec::user::SessionHandle* temp = _impl_.sessionhandle_;
  _impl_.sessionhandle_ = nullptr;
  return temp;
}
inline ::exec::user::SessionHandle* RunQueryWithSessionHandle::_internal_mutable_sessionhandle() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.sessionhandle_ == nullptr) {
    auto* p = CreateMaybeMessage<::exec::user::SessionHandle>(GetArenaForAllocation());
    _impl_.sessionhandle_ = p;
  }
  return _impl_.sessionhandle_;
}
inline ::exec::user::SessionHandle* RunQueryWithSessionHandle::mutable_sessionhandle() {
  ::exec::user::SessionHandle* _msg = _internal_mutable_sessionhandle();
  // @@protoc_insertion_point(field_mutable:exec.user.RunQueryWithSessionHandle.sessionHandle)
  return _msg;
}
inline void RunQueryWithSessionHandle::set_allocated_sessionhandle(::exec::user::SessionHandle* sessionhandle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.sessionhandle_;
  }
  if (sessionhandle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sessionhandle);
    if (message_arena != submessage_arena) {
      sessionhandle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sessionhandle, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.sessionhandle_ = sessionhandle;
  // @@protoc_insertion_point(field_set_allocated:exec.user.RunQueryWithSessionHandle.sessionHandle)
}

// -------------------------------------------------------------------

// CancelQueryWithSessionHandle

// optional .exec.shared.QueryId query_id = 1;
inline bool CancelQueryWithSessionHandle::has_query_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.query_id_ != nullptr);
  return value;
}
inline const ::exec::shared::QueryId& CancelQueryWithSessionHandle::_internal_query_id() const {
  const ::exec::shared::QueryId* p = _impl_.query_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::exec::shared::QueryId&>(
      ::exec::shared::_QueryId_default_instance_);
}
inline const ::exec::shared::QueryId& CancelQueryWithSessionHandle::query_id() const {
  // @@protoc_insertion_point(field_get:exec.user.CancelQueryWithSessionHandle.query_id)
  return _internal_query_id();
}
inline void CancelQueryWithSessionHandle::unsafe_arena_set_allocated_query_id(
    ::exec::shared::QueryId* query_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.query_id_);
  }
  _impl_.query_id_ = query_id;
  if (query_id) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:exec.user.CancelQueryWithSessionHandle.query_id)
}
inline ::exec::shared::QueryId* CancelQueryWithSessionHandle::release_query_id() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::exec::shared::QueryId* temp = _impl_.query_id_;
  _impl_.query_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exec::shared::QueryId* CancelQueryWithSessionHandle::unsafe_arena_release_query_id() {
  // @@protoc_insertion_point(field_release:exec.user.CancelQueryWithSessionHandle.query_id)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::exec::shared::QueryId* temp = _impl_.query_id_;
  _impl_.query_id_ = nullptr;
  return temp;
}
inline ::exec::shared::QueryId* CancelQueryWithSessionHandle::_internal_mutable_query_id() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.query_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::exec::shared::QueryId>(GetArenaForAllocation());
    _impl_.query_id_ = p;
  }
  return _impl_.query_id_;
}
inline ::exec::shared::QueryId* CancelQueryWithSessionHandle::mutable_query_id() {
  ::exec::shared::QueryId* _msg = _internal_mutable_query_id();
  // @@protoc_insertion_point(field_mutable:exec.user.CancelQueryWithSessionHandle.query_id)
  return _msg;
}
inline void CancelQueryWithSessionHandle::set_allocated_query_id(::exec::shared::QueryId* query_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.query_id_);
  }
  if (query_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(query_id));
    if (message_arena != submessage_arena) {
      query_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, query_id, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.query_id_ = query_id;
  // @@protoc_insertion_point(field_set_allocated:exec.user.CancelQueryWithSessionHandle.query_id)
}

// optional .exec.user.SessionHandle session_handle = 2;
inline bool CancelQueryWithSessionHandle::has_session_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.session_handle_ != nullptr);
  return value;
}
inline void CancelQueryWithSessionHandle::clear_session_handle() {
  if (_impl_.session_handle_ != nullptr) _impl_.session_handle_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::exec::user::SessionHandle& CancelQueryWithSessionHandle::_internal_session_handle() const {
  const ::exec::user::SessionHandle* p = _impl_.session_handle_;
  return p != nullptr ? *p : reinterpret_cast<const ::exec::user::SessionHandle&>(
      ::exec::user::_SessionHandle_default_instance_);
}
inline const ::exec::user::SessionHandle& CancelQueryWithSessionHandle::session_handle() const {
  // @@protoc_insertion_point(field_get:exec.user.CancelQueryWithSessionHandle.session_handle)
  return _internal_session_handle();
}
inline void CancelQueryWithSessionHandle::unsafe_arena_set_allocated_session_handle(
    ::exec::user::SessionHandle* session_handle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.session_handle_);
  }
  _impl_.session_handle_ = session_handle;
  if (session_handle) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:exec.user.CancelQueryWithSessionHandle.session_handle)
}
inline ::exec::user::SessionHandle* CancelQueryWithSessionHandle::release_session_handle() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::exec::user::SessionHandle* temp = _impl_.session_handle_;
  _impl_.session_handle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exec::user::SessionHandle* CancelQueryWithSessionHandle::unsafe_arena_release_session_handle() {
  // @@protoc_insertion_point(field_release:exec.user.CancelQueryWithSessionHandle.session_handle)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::exec::user::SessionHandle* temp = _impl_.session_handle_;
  _impl_.session_handle_ = nullptr;
  return temp;
}
inline ::exec::user::SessionHandle* CancelQueryWithSessionHandle::_internal_mutable_session_handle() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.session_handle_ == nullptr) {
    auto* p = CreateMaybeMessage<::exec::user::SessionHandle>(GetArenaForAllocation());
    _impl_.session_handle_ = p;
  }
  return _impl_.session_handle_;
}
inline ::exec::user::SessionHandle* CancelQueryWithSessionHandle::mutable_session_handle() {
  ::exec::user::SessionHandle* _msg = _internal_mutable_session_handle();
  // @@protoc_insertion_point(field_mutable:exec.user.CancelQueryWithSessionHandle.session_handle)
  return _msg;
}
inline void CancelQueryWithSessionHandle::set_allocated_session_handle(::exec::user::SessionHandle* session_handle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.session_handle_;
  }
  if (session_handle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(session_handle);
    if (message_arena != submessage_arena) {
      session_handle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, session_handle, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.session_handle_ = session_handle;
  // @@protoc_insertion_point(field_set_allocated:exec.user.CancelQueryWithSessionHandle.session_handle)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace user
}  // namespace exec


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::exec::user::RpcType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::exec::user::RpcType>() {
  return ::exec::user::RpcType_descriptor();
}
template <>
struct is_proto_enum<::exec::user::SaslSupport> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::exec::user::SaslSupport>() {
  return ::exec::user::SaslSupport_descriptor();
}
template <>
struct is_proto_enum<::exec::user::QueryResultsMode> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::exec::user::QueryResultsMode>() {
  return ::exec::user::QueryResultsMode_descriptor();
}
template <>
struct is_proto_enum<::exec::user::HandshakeStatus> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::exec::user::HandshakeStatus>() {
  return ::exec::user::HandshakeStatus_descriptor();
}
template <>
struct is_proto_enum<::exec::user::RequestStatus> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::exec::user::RequestStatus>() {
  return ::exec::user::RequestStatus_descriptor();
}
template <>
struct is_proto_enum<::exec::user::ColumnSearchability> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::exec::user::ColumnSearchability>() {
  return ::exec::user::ColumnSearchability_descriptor();
}
template <>
struct is_proto_enum<::exec::user::ColumnUpdatability> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::exec::user::ColumnUpdatability>() {
  return ::exec::user::ColumnUpdatability_descriptor();
}
template <>
struct is_proto_enum<::exec::user::CollateSupport> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::exec::user::CollateSupport>() {
  return ::exec::user::CollateSupport_descriptor();
}
template <>
struct is_proto_enum<::exec::user::CorrelationNamesSupport> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::exec::user::CorrelationNamesSupport>() {
  return ::exec::user::CorrelationNamesSupport_descriptor();
}
template <>
struct is_proto_enum<::exec::user::DateTimeLiteralsSupport> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::exec::user::DateTimeLiteralsSupport>() {
  return ::exec::user::DateTimeLiteralsSupport_descriptor();
}
template <>
struct is_proto_enum<::exec::user::GroupBySupport> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::exec::user::GroupBySupport>() {
  return ::exec::user::GroupBySupport_descriptor();
}
template <>
struct is_proto_enum<::exec::user::IdentifierCasing> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::exec::user::IdentifierCasing>() {
  return ::exec::user::IdentifierCasing_descriptor();
}
template <>
struct is_proto_enum<::exec::user::NullCollation> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::exec::user::NullCollation>() {
  return ::exec::user::NullCollation_descriptor();
}
template <>
struct is_proto_enum<::exec::user::OrderBySupport> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::exec::user::OrderBySupport>() {
  return ::exec::user::OrderBySupport_descriptor();
}
template <>
struct is_proto_enum<::exec::user::OuterJoinSupport> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::exec::user::OuterJoinSupport>() {
  return ::exec::user::OuterJoinSupport_descriptor();
}
template <>
struct is_proto_enum<::exec::user::SubQuerySupport> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::exec::user::SubQuerySupport>() {
  return ::exec::user::SubQuerySupport_descriptor();
}
template <>
struct is_proto_enum<::exec::user::UnionSupport> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::exec::user::UnionSupport>() {
  return ::exec::user::UnionSupport_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_User_2eproto_2epb_2eh
