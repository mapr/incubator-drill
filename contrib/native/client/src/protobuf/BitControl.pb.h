// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: BitControl.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_BitControl_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_BitControl_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4022000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4022002 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "ExecutionProtos.pb.h"
#include "Coordination.pb.h"
#include "UserBitShared.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_BitControl_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_BitControl_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_BitControl_2eproto;
namespace exec {
namespace bit {
namespace control {
class BitControlHandshake;
struct BitControlHandshakeDefaultTypeInternal;
extern BitControlHandshakeDefaultTypeInternal _BitControlHandshake_default_instance_;
class BitStatus;
struct BitStatusDefaultTypeInternal;
extern BitStatusDefaultTypeInternal _BitStatus_default_instance_;
class Collector;
struct CollectorDefaultTypeInternal;
extern CollectorDefaultTypeInternal _Collector_default_instance_;
class CustomMessage;
struct CustomMessageDefaultTypeInternal;
extern CustomMessageDefaultTypeInternal _CustomMessage_default_instance_;
class FinishedReceiver;
struct FinishedReceiverDefaultTypeInternal;
extern FinishedReceiverDefaultTypeInternal _FinishedReceiver_default_instance_;
class FragmentStatus;
struct FragmentStatusDefaultTypeInternal;
extern FragmentStatusDefaultTypeInternal _FragmentStatus_default_instance_;
class InitializeFragments;
struct InitializeFragmentsDefaultTypeInternal;
extern InitializeFragmentsDefaultTypeInternal _InitializeFragments_default_instance_;
class PlanFragment;
struct PlanFragmentDefaultTypeInternal;
extern PlanFragmentDefaultTypeInternal _PlanFragment_default_instance_;
class QueryContextInformation;
struct QueryContextInformationDefaultTypeInternal;
extern QueryContextInformationDefaultTypeInternal _QueryContextInformation_default_instance_;
class WorkQueueStatus;
struct WorkQueueStatusDefaultTypeInternal;
extern WorkQueueStatusDefaultTypeInternal _WorkQueueStatus_default_instance_;
}  // namespace control
}  // namespace bit
}  // namespace exec
PROTOBUF_NAMESPACE_OPEN
template <>
::exec::bit::control::BitControlHandshake* Arena::CreateMaybeMessage<::exec::bit::control::BitControlHandshake>(Arena*);
template <>
::exec::bit::control::BitStatus* Arena::CreateMaybeMessage<::exec::bit::control::BitStatus>(Arena*);
template <>
::exec::bit::control::Collector* Arena::CreateMaybeMessage<::exec::bit::control::Collector>(Arena*);
template <>
::exec::bit::control::CustomMessage* Arena::CreateMaybeMessage<::exec::bit::control::CustomMessage>(Arena*);
template <>
::exec::bit::control::FinishedReceiver* Arena::CreateMaybeMessage<::exec::bit::control::FinishedReceiver>(Arena*);
template <>
::exec::bit::control::FragmentStatus* Arena::CreateMaybeMessage<::exec::bit::control::FragmentStatus>(Arena*);
template <>
::exec::bit::control::InitializeFragments* Arena::CreateMaybeMessage<::exec::bit::control::InitializeFragments>(Arena*);
template <>
::exec::bit::control::PlanFragment* Arena::CreateMaybeMessage<::exec::bit::control::PlanFragment>(Arena*);
template <>
::exec::bit::control::QueryContextInformation* Arena::CreateMaybeMessage<::exec::bit::control::QueryContextInformation>(Arena*);
template <>
::exec::bit::control::WorkQueueStatus* Arena::CreateMaybeMessage<::exec::bit::control::WorkQueueStatus>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

namespace exec {
namespace bit {
namespace control {
enum RpcType : int {
  HANDSHAKE = 0,
  ACK = 1,
  GOODBYE = 2,
  REQ_INITIALIZE_FRAGMENTS = 3,
  REQ_CANCEL_FRAGMENT = 6,
  REQ_RECEIVER_FINISHED = 7,
  REQ_FRAGMENT_STATUS = 8,
  REQ_BIT_STATUS = 9,
  REQ_QUERY_STATUS = 10,
  REQ_QUERY_CANCEL = 15,
  REQ_UNPAUSE_FRAGMENT = 16,
  REQ_CUSTOM = 17,
  RESP_FRAGMENT_HANDLE = 11,
  RESP_FRAGMENT_STATUS = 12,
  RESP_BIT_STATUS = 13,
  RESP_QUERY_STATUS = 14,
  RESP_CUSTOM = 18,
  SASL_MESSAGE = 19,
};

bool RpcType_IsValid(int value);
constexpr RpcType RpcType_MIN = static_cast<RpcType>(0);
constexpr RpcType RpcType_MAX = static_cast<RpcType>(19);
constexpr int RpcType_ARRAYSIZE = 19 + 1;
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
RpcType_descriptor();
template <typename T>
const std::string& RpcType_Name(T value) {
  static_assert(std::is_same<T, RpcType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to RpcType_Name().");
  return RpcType_Name(static_cast<RpcType>(value));
}
template <>
inline const std::string& RpcType_Name(RpcType value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfDenseEnum<RpcType_descriptor,
                                                 0, 19>(
      static_cast<int>(value));
}
inline bool RpcType_Parse(absl::string_view name, RpcType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RpcType>(
      RpcType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class BitControlHandshake final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.bit.control.BitControlHandshake) */ {
 public:
  inline BitControlHandshake() : BitControlHandshake(nullptr) {}
  ~BitControlHandshake() override;
  explicit PROTOBUF_CONSTEXPR BitControlHandshake(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BitControlHandshake(const BitControlHandshake& from);
  BitControlHandshake(BitControlHandshake&& from) noexcept
    : BitControlHandshake() {
    *this = ::std::move(from);
  }

  inline BitControlHandshake& operator=(const BitControlHandshake& from) {
    CopyFrom(from);
    return *this;
  }
  inline BitControlHandshake& operator=(BitControlHandshake&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BitControlHandshake& default_instance() {
    return *internal_default_instance();
  }
  static inline const BitControlHandshake* internal_default_instance() {
    return reinterpret_cast<const BitControlHandshake*>(
               &_BitControlHandshake_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(BitControlHandshake& a, BitControlHandshake& b) {
    a.Swap(&b);
  }
  inline void Swap(BitControlHandshake* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BitControlHandshake* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BitControlHandshake* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BitControlHandshake>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BitControlHandshake& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BitControlHandshake& from) {
    BitControlHandshake::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BitControlHandshake* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.bit.control.BitControlHandshake";
  }
  protected:
  explicit BitControlHandshake(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthenticationMechanismsFieldNumber = 4,
    kEndpointFieldNumber = 3,
    kRpcVersionFieldNumber = 1,
    kChannelFieldNumber = 2,
  };
  // repeated string authenticationMechanisms = 4;
  int authenticationmechanisms_size() const;
  private:
  int _internal_authenticationmechanisms_size() const;

  public:
  void clear_authenticationmechanisms() ;
  const std::string& authenticationmechanisms(int index) const;
  std::string* mutable_authenticationmechanisms(int index);
  void set_authenticationmechanisms(int index, const std::string& value);
  void set_authenticationmechanisms(int index, std::string&& value);
  void set_authenticationmechanisms(int index, const char* value);
  void set_authenticationmechanisms(int index, const char* value, std::size_t size);
  void set_authenticationmechanisms(int index, absl::string_view value);
  std::string* add_authenticationmechanisms();
  void add_authenticationmechanisms(const std::string& value);
  void add_authenticationmechanisms(std::string&& value);
  void add_authenticationmechanisms(const char* value);
  void add_authenticationmechanisms(const char* value, std::size_t size);
  void add_authenticationmechanisms(absl::string_view value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& authenticationmechanisms() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_authenticationmechanisms();

  private:
  const std::string& _internal_authenticationmechanisms(int index) const;
  std::string* _internal_add_authenticationmechanisms();

  public:
  // optional .exec.DrillbitEndpoint endpoint = 3;
  bool has_endpoint() const;
  void clear_endpoint() ;
  const ::exec::DrillbitEndpoint& endpoint() const;
  PROTOBUF_NODISCARD ::exec::DrillbitEndpoint* release_endpoint();
  ::exec::DrillbitEndpoint* mutable_endpoint();
  void set_allocated_endpoint(::exec::DrillbitEndpoint* endpoint);
  private:
  const ::exec::DrillbitEndpoint& _internal_endpoint() const;
  ::exec::DrillbitEndpoint* _internal_mutable_endpoint();
  public:
  void unsafe_arena_set_allocated_endpoint(
      ::exec::DrillbitEndpoint* endpoint);
  ::exec::DrillbitEndpoint* unsafe_arena_release_endpoint();
  // optional int32 rpc_version = 1;
  bool has_rpc_version() const;
  void clear_rpc_version() ;
  ::int32_t rpc_version() const;
  void set_rpc_version(::int32_t value);

  private:
  ::int32_t _internal_rpc_version() const;
  void _internal_set_rpc_version(::int32_t value);

  public:
  // optional .exec.shared.RpcChannel channel = 2 [default = BIT_CONTROL];
  bool has_channel() const;
  void clear_channel() ;
  ::exec::shared::RpcChannel channel() const;
  void set_channel(::exec::shared::RpcChannel value);

  private:
  ::exec::shared::RpcChannel _internal_channel() const;
  void _internal_set_channel(::exec::shared::RpcChannel value);

  public:
  // @@protoc_insertion_point(class_scope:exec.bit.control.BitControlHandshake)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> authenticationmechanisms_;
    ::exec::DrillbitEndpoint* endpoint_;
    ::int32_t rpc_version_;
    int channel_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_BitControl_2eproto;
};// -------------------------------------------------------------------

class BitStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.bit.control.BitStatus) */ {
 public:
  inline BitStatus() : BitStatus(nullptr) {}
  ~BitStatus() override;
  explicit PROTOBUF_CONSTEXPR BitStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BitStatus(const BitStatus& from);
  BitStatus(BitStatus&& from) noexcept
    : BitStatus() {
    *this = ::std::move(from);
  }

  inline BitStatus& operator=(const BitStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline BitStatus& operator=(BitStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BitStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const BitStatus* internal_default_instance() {
    return reinterpret_cast<const BitStatus*>(
               &_BitStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(BitStatus& a, BitStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(BitStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BitStatus* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BitStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BitStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BitStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BitStatus& from) {
    BitStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BitStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.bit.control.BitStatus";
  }
  protected:
  explicit BitStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFragmentStatusFieldNumber = 1,
  };
  // repeated .exec.bit.control.FragmentStatus fragment_status = 1;
  int fragment_status_size() const;
  private:
  int _internal_fragment_status_size() const;

  public:
  void clear_fragment_status() ;
  ::exec::bit::control::FragmentStatus* mutable_fragment_status(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::bit::control::FragmentStatus >*
      mutable_fragment_status();
  private:
  const ::exec::bit::control::FragmentStatus& _internal_fragment_status(int index) const;
  ::exec::bit::control::FragmentStatus* _internal_add_fragment_status();
  public:
  const ::exec::bit::control::FragmentStatus& fragment_status(int index) const;
  ::exec::bit::control::FragmentStatus* add_fragment_status();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::bit::control::FragmentStatus >&
      fragment_status() const;
  // @@protoc_insertion_point(class_scope:exec.bit.control.BitStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::bit::control::FragmentStatus > fragment_status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_BitControl_2eproto;
};// -------------------------------------------------------------------

class FragmentStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.bit.control.FragmentStatus) */ {
 public:
  inline FragmentStatus() : FragmentStatus(nullptr) {}
  ~FragmentStatus() override;
  explicit PROTOBUF_CONSTEXPR FragmentStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FragmentStatus(const FragmentStatus& from);
  FragmentStatus(FragmentStatus&& from) noexcept
    : FragmentStatus() {
    *this = ::std::move(from);
  }

  inline FragmentStatus& operator=(const FragmentStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline FragmentStatus& operator=(FragmentStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FragmentStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const FragmentStatus* internal_default_instance() {
    return reinterpret_cast<const FragmentStatus*>(
               &_FragmentStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(FragmentStatus& a, FragmentStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(FragmentStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FragmentStatus* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FragmentStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FragmentStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FragmentStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FragmentStatus& from) {
    FragmentStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FragmentStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.bit.control.FragmentStatus";
  }
  protected:
  explicit FragmentStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProfileFieldNumber = 1,
    kHandleFieldNumber = 2,
  };
  // optional .exec.shared.MinorFragmentProfile profile = 1;
  bool has_profile() const;
  void clear_profile() ;
  const ::exec::shared::MinorFragmentProfile& profile() const;
  PROTOBUF_NODISCARD ::exec::shared::MinorFragmentProfile* release_profile();
  ::exec::shared::MinorFragmentProfile* mutable_profile();
  void set_allocated_profile(::exec::shared::MinorFragmentProfile* profile);
  private:
  const ::exec::shared::MinorFragmentProfile& _internal_profile() const;
  ::exec::shared::MinorFragmentProfile* _internal_mutable_profile();
  public:
  void unsafe_arena_set_allocated_profile(
      ::exec::shared::MinorFragmentProfile* profile);
  ::exec::shared::MinorFragmentProfile* unsafe_arena_release_profile();
  // optional .exec.bit.FragmentHandle handle = 2;
  bool has_handle() const;
  void clear_handle() ;
  const ::exec::bit::FragmentHandle& handle() const;
  PROTOBUF_NODISCARD ::exec::bit::FragmentHandle* release_handle();
  ::exec::bit::FragmentHandle* mutable_handle();
  void set_allocated_handle(::exec::bit::FragmentHandle* handle);
  private:
  const ::exec::bit::FragmentHandle& _internal_handle() const;
  ::exec::bit::FragmentHandle* _internal_mutable_handle();
  public:
  void unsafe_arena_set_allocated_handle(
      ::exec::bit::FragmentHandle* handle);
  ::exec::bit::FragmentHandle* unsafe_arena_release_handle();
  // @@protoc_insertion_point(class_scope:exec.bit.control.FragmentStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::exec::shared::MinorFragmentProfile* profile_;
    ::exec::bit::FragmentHandle* handle_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_BitControl_2eproto;
};// -------------------------------------------------------------------

class InitializeFragments final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.bit.control.InitializeFragments) */ {
 public:
  inline InitializeFragments() : InitializeFragments(nullptr) {}
  ~InitializeFragments() override;
  explicit PROTOBUF_CONSTEXPR InitializeFragments(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InitializeFragments(const InitializeFragments& from);
  InitializeFragments(InitializeFragments&& from) noexcept
    : InitializeFragments() {
    *this = ::std::move(from);
  }

  inline InitializeFragments& operator=(const InitializeFragments& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitializeFragments& operator=(InitializeFragments&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InitializeFragments& default_instance() {
    return *internal_default_instance();
  }
  static inline const InitializeFragments* internal_default_instance() {
    return reinterpret_cast<const InitializeFragments*>(
               &_InitializeFragments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(InitializeFragments& a, InitializeFragments& b) {
    a.Swap(&b);
  }
  inline void Swap(InitializeFragments* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitializeFragments* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitializeFragments* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InitializeFragments>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InitializeFragments& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InitializeFragments& from) {
    InitializeFragments::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitializeFragments* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.bit.control.InitializeFragments";
  }
  protected:
  explicit InitializeFragments(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFragmentFieldNumber = 1,
  };
  // repeated .exec.bit.control.PlanFragment fragment = 1;
  int fragment_size() const;
  private:
  int _internal_fragment_size() const;

  public:
  void clear_fragment() ;
  ::exec::bit::control::PlanFragment* mutable_fragment(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::bit::control::PlanFragment >*
      mutable_fragment();
  private:
  const ::exec::bit::control::PlanFragment& _internal_fragment(int index) const;
  ::exec::bit::control::PlanFragment* _internal_add_fragment();
  public:
  const ::exec::bit::control::PlanFragment& fragment(int index) const;
  ::exec::bit::control::PlanFragment* add_fragment();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::bit::control::PlanFragment >&
      fragment() const;
  // @@protoc_insertion_point(class_scope:exec.bit.control.InitializeFragments)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::bit::control::PlanFragment > fragment_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_BitControl_2eproto;
};// -------------------------------------------------------------------

class CustomMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.bit.control.CustomMessage) */ {
 public:
  inline CustomMessage() : CustomMessage(nullptr) {}
  ~CustomMessage() override;
  explicit PROTOBUF_CONSTEXPR CustomMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CustomMessage(const CustomMessage& from);
  CustomMessage(CustomMessage&& from) noexcept
    : CustomMessage() {
    *this = ::std::move(from);
  }

  inline CustomMessage& operator=(const CustomMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomMessage& operator=(CustomMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CustomMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const CustomMessage* internal_default_instance() {
    return reinterpret_cast<const CustomMessage*>(
               &_CustomMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CustomMessage& a, CustomMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CustomMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CustomMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CustomMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CustomMessage& from) {
    CustomMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CustomMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.bit.control.CustomMessage";
  }
  protected:
  explicit CustomMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // optional bytes message = 2;
  bool has_message() const;
  void clear_message() ;
  const std::string& message() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* ptr);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // optional int32 type = 1;
  bool has_type() const;
  void clear_type() ;
  ::int32_t type() const;
  void set_type(::int32_t value);

  private:
  ::int32_t _internal_type() const;
  void _internal_set_type(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:exec.bit.control.CustomMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::int32_t type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_BitControl_2eproto;
};// -------------------------------------------------------------------

class PlanFragment final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.bit.control.PlanFragment) */ {
 public:
  inline PlanFragment() : PlanFragment(nullptr) {}
  ~PlanFragment() override;
  explicit PROTOBUF_CONSTEXPR PlanFragment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlanFragment(const PlanFragment& from);
  PlanFragment(PlanFragment&& from) noexcept
    : PlanFragment() {
    *this = ::std::move(from);
  }

  inline PlanFragment& operator=(const PlanFragment& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlanFragment& operator=(PlanFragment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlanFragment& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlanFragment* internal_default_instance() {
    return reinterpret_cast<const PlanFragment*>(
               &_PlanFragment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PlanFragment& a, PlanFragment& b) {
    a.Swap(&b);
  }
  inline void Swap(PlanFragment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlanFragment* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlanFragment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlanFragment>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlanFragment& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PlanFragment& from) {
    PlanFragment::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlanFragment* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.bit.control.PlanFragment";
  }
  protected:
  explicit PlanFragment(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCollectorFieldNumber = 17,
    kFragmentJsonFieldNumber = 8,
    kOptionsJsonFieldNumber = 15,
    kHandleFieldNumber = 1,
    kAssignmentFieldNumber = 10,
    kForemanFieldNumber = 11,
    kCredentialsFieldNumber = 14,
    kContextFieldNumber = 16,
    kNetworkCostFieldNumber = 4,
    kCpuCostFieldNumber = 5,
    kDiskCostFieldNumber = 6,
    kMemoryCostFieldNumber = 7,
    kLeafFragmentFieldNumber = 9,
    kMemInitialFieldNumber = 12,
    kMemMaxFieldNumber = 13,
  };
  // repeated .exec.bit.control.Collector collector = 17;
  int collector_size() const;
  private:
  int _internal_collector_size() const;

  public:
  void clear_collector() ;
  ::exec::bit::control::Collector* mutable_collector(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::bit::control::Collector >*
      mutable_collector();
  private:
  const ::exec::bit::control::Collector& _internal_collector(int index) const;
  ::exec::bit::control::Collector* _internal_add_collector();
  public:
  const ::exec::bit::control::Collector& collector(int index) const;
  ::exec::bit::control::Collector* add_collector();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::bit::control::Collector >&
      collector() const;
  // optional string fragment_json = 8;
  bool has_fragment_json() const;
  void clear_fragment_json() ;
  const std::string& fragment_json() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fragment_json(Arg_&& arg, Args_... args);
  std::string* mutable_fragment_json();
  PROTOBUF_NODISCARD std::string* release_fragment_json();
  void set_allocated_fragment_json(std::string* ptr);

  private:
  const std::string& _internal_fragment_json() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fragment_json(
      const std::string& value);
  std::string* _internal_mutable_fragment_json();

  public:
  // optional string options_json = 15;
  bool has_options_json() const;
  void clear_options_json() ;
  const std::string& options_json() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_options_json(Arg_&& arg, Args_... args);
  std::string* mutable_options_json();
  PROTOBUF_NODISCARD std::string* release_options_json();
  void set_allocated_options_json(std::string* ptr);

  private:
  const std::string& _internal_options_json() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_options_json(
      const std::string& value);
  std::string* _internal_mutable_options_json();

  public:
  // optional .exec.bit.FragmentHandle handle = 1;
  bool has_handle() const;
  void clear_handle() ;
  const ::exec::bit::FragmentHandle& handle() const;
  PROTOBUF_NODISCARD ::exec::bit::FragmentHandle* release_handle();
  ::exec::bit::FragmentHandle* mutable_handle();
  void set_allocated_handle(::exec::bit::FragmentHandle* handle);
  private:
  const ::exec::bit::FragmentHandle& _internal_handle() const;
  ::exec::bit::FragmentHandle* _internal_mutable_handle();
  public:
  void unsafe_arena_set_allocated_handle(
      ::exec::bit::FragmentHandle* handle);
  ::exec::bit::FragmentHandle* unsafe_arena_release_handle();
  // optional .exec.DrillbitEndpoint assignment = 10;
  bool has_assignment() const;
  void clear_assignment() ;
  const ::exec::DrillbitEndpoint& assignment() const;
  PROTOBUF_NODISCARD ::exec::DrillbitEndpoint* release_assignment();
  ::exec::DrillbitEndpoint* mutable_assignment();
  void set_allocated_assignment(::exec::DrillbitEndpoint* assignment);
  private:
  const ::exec::DrillbitEndpoint& _internal_assignment() const;
  ::exec::DrillbitEndpoint* _internal_mutable_assignment();
  public:
  void unsafe_arena_set_allocated_assignment(
      ::exec::DrillbitEndpoint* assignment);
  ::exec::DrillbitEndpoint* unsafe_arena_release_assignment();
  // optional .exec.DrillbitEndpoint foreman = 11;
  bool has_foreman() const;
  void clear_foreman() ;
  const ::exec::DrillbitEndpoint& foreman() const;
  PROTOBUF_NODISCARD ::exec::DrillbitEndpoint* release_foreman();
  ::exec::DrillbitEndpoint* mutable_foreman();
  void set_allocated_foreman(::exec::DrillbitEndpoint* foreman);
  private:
  const ::exec::DrillbitEndpoint& _internal_foreman() const;
  ::exec::DrillbitEndpoint* _internal_mutable_foreman();
  public:
  void unsafe_arena_set_allocated_foreman(
      ::exec::DrillbitEndpoint* foreman);
  ::exec::DrillbitEndpoint* unsafe_arena_release_foreman();
  // optional .exec.shared.UserCredentials credentials = 14;
  bool has_credentials() const;
  void clear_credentials() ;
  const ::exec::shared::UserCredentials& credentials() const;
  PROTOBUF_NODISCARD ::exec::shared::UserCredentials* release_credentials();
  ::exec::shared::UserCredentials* mutable_credentials();
  void set_allocated_credentials(::exec::shared::UserCredentials* credentials);
  private:
  const ::exec::shared::UserCredentials& _internal_credentials() const;
  ::exec::shared::UserCredentials* _internal_mutable_credentials();
  public:
  void unsafe_arena_set_allocated_credentials(
      ::exec::shared::UserCredentials* credentials);
  ::exec::shared::UserCredentials* unsafe_arena_release_credentials();
  // optional .exec.bit.control.QueryContextInformation context = 16;
  bool has_context() const;
  void clear_context() ;
  const ::exec::bit::control::QueryContextInformation& context() const;
  PROTOBUF_NODISCARD ::exec::bit::control::QueryContextInformation* release_context();
  ::exec::bit::control::QueryContextInformation* mutable_context();
  void set_allocated_context(::exec::bit::control::QueryContextInformation* context);
  private:
  const ::exec::bit::control::QueryContextInformation& _internal_context() const;
  ::exec::bit::control::QueryContextInformation* _internal_mutable_context();
  public:
  void unsafe_arena_set_allocated_context(
      ::exec::bit::control::QueryContextInformation* context);
  ::exec::bit::control::QueryContextInformation* unsafe_arena_release_context();
  // optional float network_cost = 4;
  bool has_network_cost() const;
  void clear_network_cost() ;
  float network_cost() const;
  void set_network_cost(float value);

  private:
  float _internal_network_cost() const;
  void _internal_set_network_cost(float value);

  public:
  // optional float cpu_cost = 5;
  bool has_cpu_cost() const;
  void clear_cpu_cost() ;
  float cpu_cost() const;
  void set_cpu_cost(float value);

  private:
  float _internal_cpu_cost() const;
  void _internal_set_cpu_cost(float value);

  public:
  // optional float disk_cost = 6;
  bool has_disk_cost() const;
  void clear_disk_cost() ;
  float disk_cost() const;
  void set_disk_cost(float value);

  private:
  float _internal_disk_cost() const;
  void _internal_set_disk_cost(float value);

  public:
  // optional float memory_cost = 7;
  bool has_memory_cost() const;
  void clear_memory_cost() ;
  float memory_cost() const;
  void set_memory_cost(float value);

  private:
  float _internal_memory_cost() const;
  void _internal_set_memory_cost(float value);

  public:
  // optional bool leaf_fragment = 9;
  bool has_leaf_fragment() const;
  void clear_leaf_fragment() ;
  bool leaf_fragment() const;
  void set_leaf_fragment(bool value);

  private:
  bool _internal_leaf_fragment() const;
  void _internal_set_leaf_fragment(bool value);

  public:
  // optional int64 mem_initial = 12 [default = 20000000];
  bool has_mem_initial() const;
  void clear_mem_initial() ;
  ::int64_t mem_initial() const;
  void set_mem_initial(::int64_t value);

  private:
  ::int64_t _internal_mem_initial() const;
  void _internal_set_mem_initial(::int64_t value);

  public:
  // optional int64 mem_max = 13 [default = 2000000000];
  bool has_mem_max() const;
  void clear_mem_max() ;
  ::int64_t mem_max() const;
  void set_mem_max(::int64_t value);

  private:
  ::int64_t _internal_mem_max() const;
  void _internal_set_mem_max(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:exec.bit.control.PlanFragment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::bit::control::Collector > collector_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fragment_json_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr options_json_;
    ::exec::bit::FragmentHandle* handle_;
    ::exec::DrillbitEndpoint* assignment_;
    ::exec::DrillbitEndpoint* foreman_;
    ::exec::shared::UserCredentials* credentials_;
    ::exec::bit::control::QueryContextInformation* context_;
    float network_cost_;
    float cpu_cost_;
    float disk_cost_;
    float memory_cost_;
    bool leaf_fragment_;
    ::int64_t mem_initial_;
    ::int64_t mem_max_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_BitControl_2eproto;
};// -------------------------------------------------------------------

class Collector final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.bit.control.Collector) */ {
 public:
  inline Collector() : Collector(nullptr) {}
  ~Collector() override;
  explicit PROTOBUF_CONSTEXPR Collector(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Collector(const Collector& from);
  Collector(Collector&& from) noexcept
    : Collector() {
    *this = ::std::move(from);
  }

  inline Collector& operator=(const Collector& from) {
    CopyFrom(from);
    return *this;
  }
  inline Collector& operator=(Collector&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Collector& default_instance() {
    return *internal_default_instance();
  }
  static inline const Collector* internal_default_instance() {
    return reinterpret_cast<const Collector*>(
               &_Collector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Collector& a, Collector& b) {
    a.Swap(&b);
  }
  inline void Swap(Collector* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Collector* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Collector* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Collector>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Collector& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Collector& from) {
    Collector::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Collector* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.bit.control.Collector";
  }
  protected:
  explicit Collector(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIncomingMinorFragmentFieldNumber = 2,
    kOppositeMajorFragmentIdFieldNumber = 1,
    kSupportsOutOfOrderFieldNumber = 3,
    kIsSpoolingFieldNumber = 4,
    kEnableDynamicFcFieldNumber = 5,
  };
  // repeated int32 incoming_minor_fragment = 2 [packed = true];
  int incoming_minor_fragment_size() const;
  private:
  int _internal_incoming_minor_fragment_size() const;

  public:
  void clear_incoming_minor_fragment() ;
  ::int32_t incoming_minor_fragment(int index) const;
  void set_incoming_minor_fragment(int index, ::int32_t value);
  void add_incoming_minor_fragment(::int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>& incoming_minor_fragment() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>* mutable_incoming_minor_fragment();

  private:
  ::int32_t _internal_incoming_minor_fragment(int index) const;
  void _internal_add_incoming_minor_fragment(::int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>& _internal_incoming_minor_fragment() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>* _internal_mutable_incoming_minor_fragment();

  public:
  // optional int32 opposite_major_fragment_id = 1;
  bool has_opposite_major_fragment_id() const;
  void clear_opposite_major_fragment_id() ;
  ::int32_t opposite_major_fragment_id() const;
  void set_opposite_major_fragment_id(::int32_t value);

  private:
  ::int32_t _internal_opposite_major_fragment_id() const;
  void _internal_set_opposite_major_fragment_id(::int32_t value);

  public:
  // optional bool supports_out_of_order = 3;
  bool has_supports_out_of_order() const;
  void clear_supports_out_of_order() ;
  bool supports_out_of_order() const;
  void set_supports_out_of_order(bool value);

  private:
  bool _internal_supports_out_of_order() const;
  void _internal_set_supports_out_of_order(bool value);

  public:
  // optional bool is_spooling = 4;
  bool has_is_spooling() const;
  void clear_is_spooling() ;
  bool is_spooling() const;
  void set_is_spooling(bool value);

  private:
  bool _internal_is_spooling() const;
  void _internal_set_is_spooling(bool value);

  public:
  // optional bool enable_dynamic_fc = 5;
  bool has_enable_dynamic_fc() const;
  void clear_enable_dynamic_fc() ;
  bool enable_dynamic_fc() const;
  void set_enable_dynamic_fc(bool value);

  private:
  bool _internal_enable_dynamic_fc() const;
  void _internal_set_enable_dynamic_fc(bool value);

  public:
  // @@protoc_insertion_point(class_scope:exec.bit.control.Collector)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t> incoming_minor_fragment_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _incoming_minor_fragment_cached_byte_size_;
    ::int32_t opposite_major_fragment_id_;
    bool supports_out_of_order_;
    bool is_spooling_;
    bool enable_dynamic_fc_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_BitControl_2eproto;
};// -------------------------------------------------------------------

class QueryContextInformation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.bit.control.QueryContextInformation) */ {
 public:
  inline QueryContextInformation() : QueryContextInformation(nullptr) {}
  ~QueryContextInformation() override;
  explicit PROTOBUF_CONSTEXPR QueryContextInformation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryContextInformation(const QueryContextInformation& from);
  QueryContextInformation(QueryContextInformation&& from) noexcept
    : QueryContextInformation() {
    *this = ::std::move(from);
  }

  inline QueryContextInformation& operator=(const QueryContextInformation& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryContextInformation& operator=(QueryContextInformation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryContextInformation& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryContextInformation* internal_default_instance() {
    return reinterpret_cast<const QueryContextInformation*>(
               &_QueryContextInformation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(QueryContextInformation& a, QueryContextInformation& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryContextInformation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryContextInformation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryContextInformation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryContextInformation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryContextInformation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryContextInformation& from) {
    QueryContextInformation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryContextInformation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.bit.control.QueryContextInformation";
  }
  protected:
  explicit QueryContextInformation(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDefaultSchemaNameFieldNumber = 3,
    kSessionIdFieldNumber = 4,
    kQueryStartTimeFieldNumber = 1,
    kTimeZoneFieldNumber = 2,
  };
  // optional string default_schema_name = 3;
  bool has_default_schema_name() const;
  void clear_default_schema_name() ;
  const std::string& default_schema_name() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_default_schema_name(Arg_&& arg, Args_... args);
  std::string* mutable_default_schema_name();
  PROTOBUF_NODISCARD std::string* release_default_schema_name();
  void set_allocated_default_schema_name(std::string* ptr);

  private:
  const std::string& _internal_default_schema_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_default_schema_name(
      const std::string& value);
  std::string* _internal_mutable_default_schema_name();

  public:
  // optional string session_id = 4;
  bool has_session_id() const;
  void clear_session_id() ;
  const std::string& session_id() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_session_id(Arg_&& arg, Args_... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* ptr);

  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(
      const std::string& value);
  std::string* _internal_mutable_session_id();

  public:
  // optional int64 query_start_time = 1;
  bool has_query_start_time() const;
  void clear_query_start_time() ;
  ::int64_t query_start_time() const;
  void set_query_start_time(::int64_t value);

  private:
  ::int64_t _internal_query_start_time() const;
  void _internal_set_query_start_time(::int64_t value);

  public:
  // optional int32 time_zone = 2;
  bool has_time_zone() const;
  void clear_time_zone() ;
  ::int32_t time_zone() const;
  void set_time_zone(::int32_t value);

  private:
  ::int32_t _internal_time_zone() const;
  void _internal_set_time_zone(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:exec.bit.control.QueryContextInformation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr default_schema_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_id_;
    ::int64_t query_start_time_;
    ::int32_t time_zone_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_BitControl_2eproto;
};// -------------------------------------------------------------------

class WorkQueueStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.bit.control.WorkQueueStatus) */ {
 public:
  inline WorkQueueStatus() : WorkQueueStatus(nullptr) {}
  ~WorkQueueStatus() override;
  explicit PROTOBUF_CONSTEXPR WorkQueueStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WorkQueueStatus(const WorkQueueStatus& from);
  WorkQueueStatus(WorkQueueStatus&& from) noexcept
    : WorkQueueStatus() {
    *this = ::std::move(from);
  }

  inline WorkQueueStatus& operator=(const WorkQueueStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorkQueueStatus& operator=(WorkQueueStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WorkQueueStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const WorkQueueStatus* internal_default_instance() {
    return reinterpret_cast<const WorkQueueStatus*>(
               &_WorkQueueStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(WorkQueueStatus& a, WorkQueueStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(WorkQueueStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorkQueueStatus* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WorkQueueStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WorkQueueStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WorkQueueStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WorkQueueStatus& from) {
    WorkQueueStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkQueueStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.bit.control.WorkQueueStatus";
  }
  protected:
  explicit WorkQueueStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEndpointFieldNumber = 1,
    kReportTimeFieldNumber = 3,
    kQueueLengthFieldNumber = 2,
  };
  // optional .exec.DrillbitEndpoint endpoint = 1;
  bool has_endpoint() const;
  void clear_endpoint() ;
  const ::exec::DrillbitEndpoint& endpoint() const;
  PROTOBUF_NODISCARD ::exec::DrillbitEndpoint* release_endpoint();
  ::exec::DrillbitEndpoint* mutable_endpoint();
  void set_allocated_endpoint(::exec::DrillbitEndpoint* endpoint);
  private:
  const ::exec::DrillbitEndpoint& _internal_endpoint() const;
  ::exec::DrillbitEndpoint* _internal_mutable_endpoint();
  public:
  void unsafe_arena_set_allocated_endpoint(
      ::exec::DrillbitEndpoint* endpoint);
  ::exec::DrillbitEndpoint* unsafe_arena_release_endpoint();
  // optional int64 report_time = 3;
  bool has_report_time() const;
  void clear_report_time() ;
  ::int64_t report_time() const;
  void set_report_time(::int64_t value);

  private:
  ::int64_t _internal_report_time() const;
  void _internal_set_report_time(::int64_t value);

  public:
  // optional int32 queue_length = 2;
  bool has_queue_length() const;
  void clear_queue_length() ;
  ::int32_t queue_length() const;
  void set_queue_length(::int32_t value);

  private:
  ::int32_t _internal_queue_length() const;
  void _internal_set_queue_length(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:exec.bit.control.WorkQueueStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::exec::DrillbitEndpoint* endpoint_;
    ::int64_t report_time_;
    ::int32_t queue_length_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_BitControl_2eproto;
};// -------------------------------------------------------------------

class FinishedReceiver final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:exec.bit.control.FinishedReceiver) */ {
 public:
  inline FinishedReceiver() : FinishedReceiver(nullptr) {}
  ~FinishedReceiver() override;
  explicit PROTOBUF_CONSTEXPR FinishedReceiver(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FinishedReceiver(const FinishedReceiver& from);
  FinishedReceiver(FinishedReceiver&& from) noexcept
    : FinishedReceiver() {
    *this = ::std::move(from);
  }

  inline FinishedReceiver& operator=(const FinishedReceiver& from) {
    CopyFrom(from);
    return *this;
  }
  inline FinishedReceiver& operator=(FinishedReceiver&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FinishedReceiver& default_instance() {
    return *internal_default_instance();
  }
  static inline const FinishedReceiver* internal_default_instance() {
    return reinterpret_cast<const FinishedReceiver*>(
               &_FinishedReceiver_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(FinishedReceiver& a, FinishedReceiver& b) {
    a.Swap(&b);
  }
  inline void Swap(FinishedReceiver* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FinishedReceiver* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FinishedReceiver* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FinishedReceiver>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FinishedReceiver& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FinishedReceiver& from) {
    FinishedReceiver::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FinishedReceiver* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "exec.bit.control.FinishedReceiver";
  }
  protected:
  explicit FinishedReceiver(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReceiverFieldNumber = 1,
    kSenderFieldNumber = 2,
  };
  // optional .exec.bit.FragmentHandle receiver = 1;
  bool has_receiver() const;
  void clear_receiver() ;
  const ::exec::bit::FragmentHandle& receiver() const;
  PROTOBUF_NODISCARD ::exec::bit::FragmentHandle* release_receiver();
  ::exec::bit::FragmentHandle* mutable_receiver();
  void set_allocated_receiver(::exec::bit::FragmentHandle* receiver);
  private:
  const ::exec::bit::FragmentHandle& _internal_receiver() const;
  ::exec::bit::FragmentHandle* _internal_mutable_receiver();
  public:
  void unsafe_arena_set_allocated_receiver(
      ::exec::bit::FragmentHandle* receiver);
  ::exec::bit::FragmentHandle* unsafe_arena_release_receiver();
  // optional .exec.bit.FragmentHandle sender = 2;
  bool has_sender() const;
  void clear_sender() ;
  const ::exec::bit::FragmentHandle& sender() const;
  PROTOBUF_NODISCARD ::exec::bit::FragmentHandle* release_sender();
  ::exec::bit::FragmentHandle* mutable_sender();
  void set_allocated_sender(::exec::bit::FragmentHandle* sender);
  private:
  const ::exec::bit::FragmentHandle& _internal_sender() const;
  ::exec::bit::FragmentHandle* _internal_mutable_sender();
  public:
  void unsafe_arena_set_allocated_sender(
      ::exec::bit::FragmentHandle* sender);
  ::exec::bit::FragmentHandle* unsafe_arena_release_sender();
  // @@protoc_insertion_point(class_scope:exec.bit.control.FinishedReceiver)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::exec::bit::FragmentHandle* receiver_;
    ::exec::bit::FragmentHandle* sender_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_BitControl_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// BitControlHandshake

// optional int32 rpc_version = 1;
inline bool BitControlHandshake::has_rpc_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BitControlHandshake::clear_rpc_version() {
  _impl_.rpc_version_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t BitControlHandshake::rpc_version() const {
  // @@protoc_insertion_point(field_get:exec.bit.control.BitControlHandshake.rpc_version)
  return _internal_rpc_version();
}
inline void BitControlHandshake::set_rpc_version(::int32_t value) {
  _internal_set_rpc_version(value);
  // @@protoc_insertion_point(field_set:exec.bit.control.BitControlHandshake.rpc_version)
}
inline ::int32_t BitControlHandshake::_internal_rpc_version() const {
  return _impl_.rpc_version_;
}
inline void BitControlHandshake::_internal_set_rpc_version(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.rpc_version_ = value;
}

// optional .exec.shared.RpcChannel channel = 2 [default = BIT_CONTROL];
inline bool BitControlHandshake::has_channel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void BitControlHandshake::clear_channel() {
  _impl_.channel_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::exec::shared::RpcChannel BitControlHandshake::channel() const {
  // @@protoc_insertion_point(field_get:exec.bit.control.BitControlHandshake.channel)
  return _internal_channel();
}
inline void BitControlHandshake::set_channel(::exec::shared::RpcChannel value) {
   _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:exec.bit.control.BitControlHandshake.channel)
}
inline ::exec::shared::RpcChannel BitControlHandshake::_internal_channel() const {
  return static_cast<::exec::shared::RpcChannel>(_impl_.channel_);
}
inline void BitControlHandshake::_internal_set_channel(::exec::shared::RpcChannel value) {
  assert(::exec::shared::RpcChannel_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.channel_ = value;
}

// optional .exec.DrillbitEndpoint endpoint = 3;
inline bool BitControlHandshake::has_endpoint() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.endpoint_ != nullptr);
  return value;
}
inline const ::exec::DrillbitEndpoint& BitControlHandshake::_internal_endpoint() const {
  const ::exec::DrillbitEndpoint* p = _impl_.endpoint_;
  return p != nullptr ? *p : reinterpret_cast<const ::exec::DrillbitEndpoint&>(
      ::exec::_DrillbitEndpoint_default_instance_);
}
inline const ::exec::DrillbitEndpoint& BitControlHandshake::endpoint() const {
  // @@protoc_insertion_point(field_get:exec.bit.control.BitControlHandshake.endpoint)
  return _internal_endpoint();
}
inline void BitControlHandshake::unsafe_arena_set_allocated_endpoint(
    ::exec::DrillbitEndpoint* endpoint) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.endpoint_);
  }
  _impl_.endpoint_ = endpoint;
  if (endpoint) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:exec.bit.control.BitControlHandshake.endpoint)
}
inline ::exec::DrillbitEndpoint* BitControlHandshake::release_endpoint() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::exec::DrillbitEndpoint* temp = _impl_.endpoint_;
  _impl_.endpoint_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exec::DrillbitEndpoint* BitControlHandshake::unsafe_arena_release_endpoint() {
  // @@protoc_insertion_point(field_release:exec.bit.control.BitControlHandshake.endpoint)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::exec::DrillbitEndpoint* temp = _impl_.endpoint_;
  _impl_.endpoint_ = nullptr;
  return temp;
}
inline ::exec::DrillbitEndpoint* BitControlHandshake::_internal_mutable_endpoint() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.endpoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::exec::DrillbitEndpoint>(GetArenaForAllocation());
    _impl_.endpoint_ = p;
  }
  return _impl_.endpoint_;
}
inline ::exec::DrillbitEndpoint* BitControlHandshake::mutable_endpoint() {
  ::exec::DrillbitEndpoint* _msg = _internal_mutable_endpoint();
  // @@protoc_insertion_point(field_mutable:exec.bit.control.BitControlHandshake.endpoint)
  return _msg;
}
inline void BitControlHandshake::set_allocated_endpoint(::exec::DrillbitEndpoint* endpoint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.endpoint_);
  }
  if (endpoint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(endpoint));
    if (message_arena != submessage_arena) {
      endpoint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, endpoint, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.endpoint_ = endpoint;
  // @@protoc_insertion_point(field_set_allocated:exec.bit.control.BitControlHandshake.endpoint)
}

// repeated string authenticationMechanisms = 4;
inline int BitControlHandshake::_internal_authenticationmechanisms_size() const {
  return _impl_.authenticationmechanisms_.size();
}
inline int BitControlHandshake::authenticationmechanisms_size() const {
  return _internal_authenticationmechanisms_size();
}
inline void BitControlHandshake::clear_authenticationmechanisms() {
  _impl_.authenticationmechanisms_.Clear();
}
inline std::string* BitControlHandshake::add_authenticationmechanisms() {
  std::string* _s = _internal_add_authenticationmechanisms();
  // @@protoc_insertion_point(field_add_mutable:exec.bit.control.BitControlHandshake.authenticationMechanisms)
  return _s;
}
inline const std::string& BitControlHandshake::_internal_authenticationmechanisms(int index) const {
  return _impl_.authenticationmechanisms_.Get(index);
}
inline const std::string& BitControlHandshake::authenticationmechanisms(int index) const {
  // @@protoc_insertion_point(field_get:exec.bit.control.BitControlHandshake.authenticationMechanisms)
  return _internal_authenticationmechanisms(index);
}
inline std::string* BitControlHandshake::mutable_authenticationmechanisms(int index) {
  // @@protoc_insertion_point(field_mutable:exec.bit.control.BitControlHandshake.authenticationMechanisms)
  return _impl_.authenticationmechanisms_.Mutable(index);
}
inline void BitControlHandshake::set_authenticationmechanisms(int index, const std::string& value) {
  _impl_.authenticationmechanisms_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:exec.bit.control.BitControlHandshake.authenticationMechanisms)
}
inline void BitControlHandshake::set_authenticationmechanisms(int index, std::string&& value) {
  _impl_.authenticationmechanisms_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:exec.bit.control.BitControlHandshake.authenticationMechanisms)
}
inline void BitControlHandshake::set_authenticationmechanisms(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _impl_.authenticationmechanisms_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:exec.bit.control.BitControlHandshake.authenticationMechanisms)
}
inline void BitControlHandshake::set_authenticationmechanisms(int index, const char* value,
                              std::size_t size) {
  _impl_.authenticationmechanisms_.Mutable(index)->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:exec.bit.control.BitControlHandshake.authenticationMechanisms)
}
inline void BitControlHandshake::set_authenticationmechanisms(int index, absl::string_view value) {
  _impl_.authenticationmechanisms_.Mutable(index)->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:exec.bit.control.BitControlHandshake.authenticationMechanisms)
}
inline std::string* BitControlHandshake::_internal_add_authenticationmechanisms() { return _impl_.authenticationmechanisms_.Add(); }
inline void BitControlHandshake::add_authenticationmechanisms(const std::string& value) {
  _impl_.authenticationmechanisms_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:exec.bit.control.BitControlHandshake.authenticationMechanisms)
}
inline void BitControlHandshake::add_authenticationmechanisms(std::string&& value) {
  _impl_.authenticationmechanisms_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:exec.bit.control.BitControlHandshake.authenticationMechanisms)
}
inline void BitControlHandshake::add_authenticationmechanisms(const char* value) {
  ABSL_DCHECK(value != nullptr);
  _impl_.authenticationmechanisms_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:exec.bit.control.BitControlHandshake.authenticationMechanisms)
}
inline void BitControlHandshake::add_authenticationmechanisms(const char* value, std::size_t size) {
  _impl_.authenticationmechanisms_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:exec.bit.control.BitControlHandshake.authenticationMechanisms)
}
inline void BitControlHandshake::add_authenticationmechanisms(absl::string_view value) {
  _impl_.authenticationmechanisms_.Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:exec.bit.control.BitControlHandshake.authenticationMechanisms)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BitControlHandshake::authenticationmechanisms() const {
  // @@protoc_insertion_point(field_list:exec.bit.control.BitControlHandshake.authenticationMechanisms)
  return _impl_.authenticationmechanisms_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* BitControlHandshake::mutable_authenticationmechanisms() {
  // @@protoc_insertion_point(field_mutable_list:exec.bit.control.BitControlHandshake.authenticationMechanisms)
  return &_impl_.authenticationmechanisms_;
}

// -------------------------------------------------------------------

// BitStatus

// repeated .exec.bit.control.FragmentStatus fragment_status = 1;
inline int BitStatus::_internal_fragment_status_size() const {
  return _impl_.fragment_status_.size();
}
inline int BitStatus::fragment_status_size() const {
  return _internal_fragment_status_size();
}
inline void BitStatus::clear_fragment_status() {
  _impl_.fragment_status_.Clear();
}
inline ::exec::bit::control::FragmentStatus* BitStatus::mutable_fragment_status(int index) {
  // @@protoc_insertion_point(field_mutable:exec.bit.control.BitStatus.fragment_status)
  return _impl_.fragment_status_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::bit::control::FragmentStatus >*
BitStatus::mutable_fragment_status() {
  // @@protoc_insertion_point(field_mutable_list:exec.bit.control.BitStatus.fragment_status)
  return &_impl_.fragment_status_;
}
inline const ::exec::bit::control::FragmentStatus& BitStatus::_internal_fragment_status(int index) const {
  return _impl_.fragment_status_.Get(index);
}
inline const ::exec::bit::control::FragmentStatus& BitStatus::fragment_status(int index) const {
  // @@protoc_insertion_point(field_get:exec.bit.control.BitStatus.fragment_status)
  return _internal_fragment_status(index);
}
inline ::exec::bit::control::FragmentStatus* BitStatus::_internal_add_fragment_status() {
  return _impl_.fragment_status_.Add();
}
inline ::exec::bit::control::FragmentStatus* BitStatus::add_fragment_status() {
  ::exec::bit::control::FragmentStatus* _add = _internal_add_fragment_status();
  // @@protoc_insertion_point(field_add:exec.bit.control.BitStatus.fragment_status)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::bit::control::FragmentStatus >&
BitStatus::fragment_status() const {
  // @@protoc_insertion_point(field_list:exec.bit.control.BitStatus.fragment_status)
  return _impl_.fragment_status_;
}

// -------------------------------------------------------------------

// FragmentStatus

// optional .exec.shared.MinorFragmentProfile profile = 1;
inline bool FragmentStatus::has_profile() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.profile_ != nullptr);
  return value;
}
inline const ::exec::shared::MinorFragmentProfile& FragmentStatus::_internal_profile() const {
  const ::exec::shared::MinorFragmentProfile* p = _impl_.profile_;
  return p != nullptr ? *p : reinterpret_cast<const ::exec::shared::MinorFragmentProfile&>(
      ::exec::shared::_MinorFragmentProfile_default_instance_);
}
inline const ::exec::shared::MinorFragmentProfile& FragmentStatus::profile() const {
  // @@protoc_insertion_point(field_get:exec.bit.control.FragmentStatus.profile)
  return _internal_profile();
}
inline void FragmentStatus::unsafe_arena_set_allocated_profile(
    ::exec::shared::MinorFragmentProfile* profile) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.profile_);
  }
  _impl_.profile_ = profile;
  if (profile) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:exec.bit.control.FragmentStatus.profile)
}
inline ::exec::shared::MinorFragmentProfile* FragmentStatus::release_profile() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::exec::shared::MinorFragmentProfile* temp = _impl_.profile_;
  _impl_.profile_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exec::shared::MinorFragmentProfile* FragmentStatus::unsafe_arena_release_profile() {
  // @@protoc_insertion_point(field_release:exec.bit.control.FragmentStatus.profile)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::exec::shared::MinorFragmentProfile* temp = _impl_.profile_;
  _impl_.profile_ = nullptr;
  return temp;
}
inline ::exec::shared::MinorFragmentProfile* FragmentStatus::_internal_mutable_profile() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.profile_ == nullptr) {
    auto* p = CreateMaybeMessage<::exec::shared::MinorFragmentProfile>(GetArenaForAllocation());
    _impl_.profile_ = p;
  }
  return _impl_.profile_;
}
inline ::exec::shared::MinorFragmentProfile* FragmentStatus::mutable_profile() {
  ::exec::shared::MinorFragmentProfile* _msg = _internal_mutable_profile();
  // @@protoc_insertion_point(field_mutable:exec.bit.control.FragmentStatus.profile)
  return _msg;
}
inline void FragmentStatus::set_allocated_profile(::exec::shared::MinorFragmentProfile* profile) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.profile_);
  }
  if (profile) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(profile));
    if (message_arena != submessage_arena) {
      profile = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, profile, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.profile_ = profile;
  // @@protoc_insertion_point(field_set_allocated:exec.bit.control.FragmentStatus.profile)
}

// optional .exec.bit.FragmentHandle handle = 2;
inline bool FragmentStatus::has_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.handle_ != nullptr);
  return value;
}
inline const ::exec::bit::FragmentHandle& FragmentStatus::_internal_handle() const {
  const ::exec::bit::FragmentHandle* p = _impl_.handle_;
  return p != nullptr ? *p : reinterpret_cast<const ::exec::bit::FragmentHandle&>(
      ::exec::bit::_FragmentHandle_default_instance_);
}
inline const ::exec::bit::FragmentHandle& FragmentStatus::handle() const {
  // @@protoc_insertion_point(field_get:exec.bit.control.FragmentStatus.handle)
  return _internal_handle();
}
inline void FragmentStatus::unsafe_arena_set_allocated_handle(
    ::exec::bit::FragmentHandle* handle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.handle_);
  }
  _impl_.handle_ = handle;
  if (handle) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:exec.bit.control.FragmentStatus.handle)
}
inline ::exec::bit::FragmentHandle* FragmentStatus::release_handle() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::exec::bit::FragmentHandle* temp = _impl_.handle_;
  _impl_.handle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exec::bit::FragmentHandle* FragmentStatus::unsafe_arena_release_handle() {
  // @@protoc_insertion_point(field_release:exec.bit.control.FragmentStatus.handle)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::exec::bit::FragmentHandle* temp = _impl_.handle_;
  _impl_.handle_ = nullptr;
  return temp;
}
inline ::exec::bit::FragmentHandle* FragmentStatus::_internal_mutable_handle() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.handle_ == nullptr) {
    auto* p = CreateMaybeMessage<::exec::bit::FragmentHandle>(GetArenaForAllocation());
    _impl_.handle_ = p;
  }
  return _impl_.handle_;
}
inline ::exec::bit::FragmentHandle* FragmentStatus::mutable_handle() {
  ::exec::bit::FragmentHandle* _msg = _internal_mutable_handle();
  // @@protoc_insertion_point(field_mutable:exec.bit.control.FragmentStatus.handle)
  return _msg;
}
inline void FragmentStatus::set_allocated_handle(::exec::bit::FragmentHandle* handle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.handle_);
  }
  if (handle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(handle));
    if (message_arena != submessage_arena) {
      handle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, handle, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.handle_ = handle;
  // @@protoc_insertion_point(field_set_allocated:exec.bit.control.FragmentStatus.handle)
}

// -------------------------------------------------------------------

// InitializeFragments

// repeated .exec.bit.control.PlanFragment fragment = 1;
inline int InitializeFragments::_internal_fragment_size() const {
  return _impl_.fragment_.size();
}
inline int InitializeFragments::fragment_size() const {
  return _internal_fragment_size();
}
inline void InitializeFragments::clear_fragment() {
  _impl_.fragment_.Clear();
}
inline ::exec::bit::control::PlanFragment* InitializeFragments::mutable_fragment(int index) {
  // @@protoc_insertion_point(field_mutable:exec.bit.control.InitializeFragments.fragment)
  return _impl_.fragment_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::bit::control::PlanFragment >*
InitializeFragments::mutable_fragment() {
  // @@protoc_insertion_point(field_mutable_list:exec.bit.control.InitializeFragments.fragment)
  return &_impl_.fragment_;
}
inline const ::exec::bit::control::PlanFragment& InitializeFragments::_internal_fragment(int index) const {
  return _impl_.fragment_.Get(index);
}
inline const ::exec::bit::control::PlanFragment& InitializeFragments::fragment(int index) const {
  // @@protoc_insertion_point(field_get:exec.bit.control.InitializeFragments.fragment)
  return _internal_fragment(index);
}
inline ::exec::bit::control::PlanFragment* InitializeFragments::_internal_add_fragment() {
  return _impl_.fragment_.Add();
}
inline ::exec::bit::control::PlanFragment* InitializeFragments::add_fragment() {
  ::exec::bit::control::PlanFragment* _add = _internal_add_fragment();
  // @@protoc_insertion_point(field_add:exec.bit.control.InitializeFragments.fragment)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::bit::control::PlanFragment >&
InitializeFragments::fragment() const {
  // @@protoc_insertion_point(field_list:exec.bit.control.InitializeFragments.fragment)
  return _impl_.fragment_;
}

// -------------------------------------------------------------------

// CustomMessage

// optional int32 type = 1;
inline bool CustomMessage::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CustomMessage::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t CustomMessage::type() const {
  // @@protoc_insertion_point(field_get:exec.bit.control.CustomMessage.type)
  return _internal_type();
}
inline void CustomMessage::set_type(::int32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:exec.bit.control.CustomMessage.type)
}
inline ::int32_t CustomMessage::_internal_type() const {
  return _impl_.type_;
}
inline void CustomMessage::_internal_set_type(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.type_ = value;
}

// optional bytes message = 2;
inline bool CustomMessage::has_message() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CustomMessage::clear_message() {
  _impl_.message_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CustomMessage::message() const {
  // @@protoc_insertion_point(field_get:exec.bit.control.CustomMessage.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CustomMessage::set_message(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.message_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.bit.control.CustomMessage.message)
}
inline std::string* CustomMessage::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:exec.bit.control.CustomMessage.message)
  return _s;
}
inline const std::string& CustomMessage::_internal_message() const {
  return _impl_.message_.Get();
}
inline void CustomMessage::_internal_set_message(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* CustomMessage::_internal_mutable_message() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.message_.Mutable( GetArenaForAllocation());
}
inline std::string* CustomMessage::release_message() {
  // @@protoc_insertion_point(field_release:exec.bit.control.CustomMessage.message)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.message_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.message_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CustomMessage::set_allocated_message(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.message_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.bit.control.CustomMessage.message)
}

// -------------------------------------------------------------------

// PlanFragment

// optional .exec.bit.FragmentHandle handle = 1;
inline bool PlanFragment::has_handle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.handle_ != nullptr);
  return value;
}
inline const ::exec::bit::FragmentHandle& PlanFragment::_internal_handle() const {
  const ::exec::bit::FragmentHandle* p = _impl_.handle_;
  return p != nullptr ? *p : reinterpret_cast<const ::exec::bit::FragmentHandle&>(
      ::exec::bit::_FragmentHandle_default_instance_);
}
inline const ::exec::bit::FragmentHandle& PlanFragment::handle() const {
  // @@protoc_insertion_point(field_get:exec.bit.control.PlanFragment.handle)
  return _internal_handle();
}
inline void PlanFragment::unsafe_arena_set_allocated_handle(
    ::exec::bit::FragmentHandle* handle) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.handle_);
  }
  _impl_.handle_ = handle;
  if (handle) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:exec.bit.control.PlanFragment.handle)
}
inline ::exec::bit::FragmentHandle* PlanFragment::release_handle() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::exec::bit::FragmentHandle* temp = _impl_.handle_;
  _impl_.handle_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exec::bit::FragmentHandle* PlanFragment::unsafe_arena_release_handle() {
  // @@protoc_insertion_point(field_release:exec.bit.control.PlanFragment.handle)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::exec::bit::FragmentHandle* temp = _impl_.handle_;
  _impl_.handle_ = nullptr;
  return temp;
}
inline ::exec::bit::FragmentHandle* PlanFragment::_internal_mutable_handle() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.handle_ == nullptr) {
    auto* p = CreateMaybeMessage<::exec::bit::FragmentHandle>(GetArenaForAllocation());
    _impl_.handle_ = p;
  }
  return _impl_.handle_;
}
inline ::exec::bit::FragmentHandle* PlanFragment::mutable_handle() {
  ::exec::bit::FragmentHandle* _msg = _internal_mutable_handle();
  // @@protoc_insertion_point(field_mutable:exec.bit.control.PlanFragment.handle)
  return _msg;
}
inline void PlanFragment::set_allocated_handle(::exec::bit::FragmentHandle* handle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.handle_);
  }
  if (handle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(handle));
    if (message_arena != submessage_arena) {
      handle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, handle, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.handle_ = handle;
  // @@protoc_insertion_point(field_set_allocated:exec.bit.control.PlanFragment.handle)
}

// optional float network_cost = 4;
inline bool PlanFragment::has_network_cost() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void PlanFragment::clear_network_cost() {
  _impl_.network_cost_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline float PlanFragment::network_cost() const {
  // @@protoc_insertion_point(field_get:exec.bit.control.PlanFragment.network_cost)
  return _internal_network_cost();
}
inline void PlanFragment::set_network_cost(float value) {
  _internal_set_network_cost(value);
  // @@protoc_insertion_point(field_set:exec.bit.control.PlanFragment.network_cost)
}
inline float PlanFragment::_internal_network_cost() const {
  return _impl_.network_cost_;
}
inline void PlanFragment::_internal_set_network_cost(float value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.network_cost_ = value;
}

// optional float cpu_cost = 5;
inline bool PlanFragment::has_cpu_cost() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void PlanFragment::clear_cpu_cost() {
  _impl_.cpu_cost_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline float PlanFragment::cpu_cost() const {
  // @@protoc_insertion_point(field_get:exec.bit.control.PlanFragment.cpu_cost)
  return _internal_cpu_cost();
}
inline void PlanFragment::set_cpu_cost(float value) {
  _internal_set_cpu_cost(value);
  // @@protoc_insertion_point(field_set:exec.bit.control.PlanFragment.cpu_cost)
}
inline float PlanFragment::_internal_cpu_cost() const {
  return _impl_.cpu_cost_;
}
inline void PlanFragment::_internal_set_cpu_cost(float value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.cpu_cost_ = value;
}

// optional float disk_cost = 6;
inline bool PlanFragment::has_disk_cost() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void PlanFragment::clear_disk_cost() {
  _impl_.disk_cost_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline float PlanFragment::disk_cost() const {
  // @@protoc_insertion_point(field_get:exec.bit.control.PlanFragment.disk_cost)
  return _internal_disk_cost();
}
inline void PlanFragment::set_disk_cost(float value) {
  _internal_set_disk_cost(value);
  // @@protoc_insertion_point(field_set:exec.bit.control.PlanFragment.disk_cost)
}
inline float PlanFragment::_internal_disk_cost() const {
  return _impl_.disk_cost_;
}
inline void PlanFragment::_internal_set_disk_cost(float value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.disk_cost_ = value;
}

// optional float memory_cost = 7;
inline bool PlanFragment::has_memory_cost() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void PlanFragment::clear_memory_cost() {
  _impl_.memory_cost_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline float PlanFragment::memory_cost() const {
  // @@protoc_insertion_point(field_get:exec.bit.control.PlanFragment.memory_cost)
  return _internal_memory_cost();
}
inline void PlanFragment::set_memory_cost(float value) {
  _internal_set_memory_cost(value);
  // @@protoc_insertion_point(field_set:exec.bit.control.PlanFragment.memory_cost)
}
inline float PlanFragment::_internal_memory_cost() const {
  return _impl_.memory_cost_;
}
inline void PlanFragment::_internal_set_memory_cost(float value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.memory_cost_ = value;
}

// optional string fragment_json = 8;
inline bool PlanFragment::has_fragment_json() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PlanFragment::clear_fragment_json() {
  _impl_.fragment_json_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PlanFragment::fragment_json() const {
  // @@protoc_insertion_point(field_get:exec.bit.control.PlanFragment.fragment_json)
  return _internal_fragment_json();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PlanFragment::set_fragment_json(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.fragment_json_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.bit.control.PlanFragment.fragment_json)
}
inline std::string* PlanFragment::mutable_fragment_json() {
  std::string* _s = _internal_mutable_fragment_json();
  // @@protoc_insertion_point(field_mutable:exec.bit.control.PlanFragment.fragment_json)
  return _s;
}
inline const std::string& PlanFragment::_internal_fragment_json() const {
  return _impl_.fragment_json_.Get();
}
inline void PlanFragment::_internal_set_fragment_json(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.fragment_json_.Set(value, GetArenaForAllocation());
}
inline std::string* PlanFragment::_internal_mutable_fragment_json() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.fragment_json_.Mutable( GetArenaForAllocation());
}
inline std::string* PlanFragment::release_fragment_json() {
  // @@protoc_insertion_point(field_release:exec.bit.control.PlanFragment.fragment_json)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.fragment_json_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.fragment_json_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void PlanFragment::set_allocated_fragment_json(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.fragment_json_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.fragment_json_.IsDefault()) {
          _impl_.fragment_json_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.bit.control.PlanFragment.fragment_json)
}

// optional bool leaf_fragment = 9;
inline bool PlanFragment::has_leaf_fragment() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void PlanFragment::clear_leaf_fragment() {
  _impl_.leaf_fragment_ = false;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline bool PlanFragment::leaf_fragment() const {
  // @@protoc_insertion_point(field_get:exec.bit.control.PlanFragment.leaf_fragment)
  return _internal_leaf_fragment();
}
inline void PlanFragment::set_leaf_fragment(bool value) {
  _internal_set_leaf_fragment(value);
  // @@protoc_insertion_point(field_set:exec.bit.control.PlanFragment.leaf_fragment)
}
inline bool PlanFragment::_internal_leaf_fragment() const {
  return _impl_.leaf_fragment_;
}
inline void PlanFragment::_internal_set_leaf_fragment(bool value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.leaf_fragment_ = value;
}

// optional .exec.DrillbitEndpoint assignment = 10;
inline bool PlanFragment::has_assignment() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.assignment_ != nullptr);
  return value;
}
inline const ::exec::DrillbitEndpoint& PlanFragment::_internal_assignment() const {
  const ::exec::DrillbitEndpoint* p = _impl_.assignment_;
  return p != nullptr ? *p : reinterpret_cast<const ::exec::DrillbitEndpoint&>(
      ::exec::_DrillbitEndpoint_default_instance_);
}
inline const ::exec::DrillbitEndpoint& PlanFragment::assignment() const {
  // @@protoc_insertion_point(field_get:exec.bit.control.PlanFragment.assignment)
  return _internal_assignment();
}
inline void PlanFragment::unsafe_arena_set_allocated_assignment(
    ::exec::DrillbitEndpoint* assignment) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.assignment_);
  }
  _impl_.assignment_ = assignment;
  if (assignment) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:exec.bit.control.PlanFragment.assignment)
}
inline ::exec::DrillbitEndpoint* PlanFragment::release_assignment() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::exec::DrillbitEndpoint* temp = _impl_.assignment_;
  _impl_.assignment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exec::DrillbitEndpoint* PlanFragment::unsafe_arena_release_assignment() {
  // @@protoc_insertion_point(field_release:exec.bit.control.PlanFragment.assignment)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::exec::DrillbitEndpoint* temp = _impl_.assignment_;
  _impl_.assignment_ = nullptr;
  return temp;
}
inline ::exec::DrillbitEndpoint* PlanFragment::_internal_mutable_assignment() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.assignment_ == nullptr) {
    auto* p = CreateMaybeMessage<::exec::DrillbitEndpoint>(GetArenaForAllocation());
    _impl_.assignment_ = p;
  }
  return _impl_.assignment_;
}
inline ::exec::DrillbitEndpoint* PlanFragment::mutable_assignment() {
  ::exec::DrillbitEndpoint* _msg = _internal_mutable_assignment();
  // @@protoc_insertion_point(field_mutable:exec.bit.control.PlanFragment.assignment)
  return _msg;
}
inline void PlanFragment::set_allocated_assignment(::exec::DrillbitEndpoint* assignment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.assignment_);
  }
  if (assignment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(assignment));
    if (message_arena != submessage_arena) {
      assignment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, assignment, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.assignment_ = assignment;
  // @@protoc_insertion_point(field_set_allocated:exec.bit.control.PlanFragment.assignment)
}

// optional .exec.DrillbitEndpoint foreman = 11;
inline bool PlanFragment::has_foreman() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.foreman_ != nullptr);
  return value;
}
inline const ::exec::DrillbitEndpoint& PlanFragment::_internal_foreman() const {
  const ::exec::DrillbitEndpoint* p = _impl_.foreman_;
  return p != nullptr ? *p : reinterpret_cast<const ::exec::DrillbitEndpoint&>(
      ::exec::_DrillbitEndpoint_default_instance_);
}
inline const ::exec::DrillbitEndpoint& PlanFragment::foreman() const {
  // @@protoc_insertion_point(field_get:exec.bit.control.PlanFragment.foreman)
  return _internal_foreman();
}
inline void PlanFragment::unsafe_arena_set_allocated_foreman(
    ::exec::DrillbitEndpoint* foreman) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.foreman_);
  }
  _impl_.foreman_ = foreman;
  if (foreman) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:exec.bit.control.PlanFragment.foreman)
}
inline ::exec::DrillbitEndpoint* PlanFragment::release_foreman() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::exec::DrillbitEndpoint* temp = _impl_.foreman_;
  _impl_.foreman_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exec::DrillbitEndpoint* PlanFragment::unsafe_arena_release_foreman() {
  // @@protoc_insertion_point(field_release:exec.bit.control.PlanFragment.foreman)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::exec::DrillbitEndpoint* temp = _impl_.foreman_;
  _impl_.foreman_ = nullptr;
  return temp;
}
inline ::exec::DrillbitEndpoint* PlanFragment::_internal_mutable_foreman() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.foreman_ == nullptr) {
    auto* p = CreateMaybeMessage<::exec::DrillbitEndpoint>(GetArenaForAllocation());
    _impl_.foreman_ = p;
  }
  return _impl_.foreman_;
}
inline ::exec::DrillbitEndpoint* PlanFragment::mutable_foreman() {
  ::exec::DrillbitEndpoint* _msg = _internal_mutable_foreman();
  // @@protoc_insertion_point(field_mutable:exec.bit.control.PlanFragment.foreman)
  return _msg;
}
inline void PlanFragment::set_allocated_foreman(::exec::DrillbitEndpoint* foreman) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.foreman_);
  }
  if (foreman) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(foreman));
    if (message_arena != submessage_arena) {
      foreman = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, foreman, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.foreman_ = foreman;
  // @@protoc_insertion_point(field_set_allocated:exec.bit.control.PlanFragment.foreman)
}

// optional int64 mem_initial = 12 [default = 20000000];
inline bool PlanFragment::has_mem_initial() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline void PlanFragment::clear_mem_initial() {
  _impl_.mem_initial_ = ::int64_t{20000000};
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline ::int64_t PlanFragment::mem_initial() const {
  // @@protoc_insertion_point(field_get:exec.bit.control.PlanFragment.mem_initial)
  return _internal_mem_initial();
}
inline void PlanFragment::set_mem_initial(::int64_t value) {
  _internal_set_mem_initial(value);
  // @@protoc_insertion_point(field_set:exec.bit.control.PlanFragment.mem_initial)
}
inline ::int64_t PlanFragment::_internal_mem_initial() const {
  return _impl_.mem_initial_;
}
inline void PlanFragment::_internal_set_mem_initial(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.mem_initial_ = value;
}

// optional int64 mem_max = 13 [default = 2000000000];
inline bool PlanFragment::has_mem_max() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline void PlanFragment::clear_mem_max() {
  _impl_.mem_max_ = ::int64_t{2000000000};
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline ::int64_t PlanFragment::mem_max() const {
  // @@protoc_insertion_point(field_get:exec.bit.control.PlanFragment.mem_max)
  return _internal_mem_max();
}
inline void PlanFragment::set_mem_max(::int64_t value) {
  _internal_set_mem_max(value);
  // @@protoc_insertion_point(field_set:exec.bit.control.PlanFragment.mem_max)
}
inline ::int64_t PlanFragment::_internal_mem_max() const {
  return _impl_.mem_max_;
}
inline void PlanFragment::_internal_set_mem_max(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.mem_max_ = value;
}

// optional .exec.shared.UserCredentials credentials = 14;
inline bool PlanFragment::has_credentials() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.credentials_ != nullptr);
  return value;
}
inline const ::exec::shared::UserCredentials& PlanFragment::_internal_credentials() const {
  const ::exec::shared::UserCredentials* p = _impl_.credentials_;
  return p != nullptr ? *p : reinterpret_cast<const ::exec::shared::UserCredentials&>(
      ::exec::shared::_UserCredentials_default_instance_);
}
inline const ::exec::shared::UserCredentials& PlanFragment::credentials() const {
  // @@protoc_insertion_point(field_get:exec.bit.control.PlanFragment.credentials)
  return _internal_credentials();
}
inline void PlanFragment::unsafe_arena_set_allocated_credentials(
    ::exec::shared::UserCredentials* credentials) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.credentials_);
  }
  _impl_.credentials_ = credentials;
  if (credentials) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:exec.bit.control.PlanFragment.credentials)
}
inline ::exec::shared::UserCredentials* PlanFragment::release_credentials() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::exec::shared::UserCredentials* temp = _impl_.credentials_;
  _impl_.credentials_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exec::shared::UserCredentials* PlanFragment::unsafe_arena_release_credentials() {
  // @@protoc_insertion_point(field_release:exec.bit.control.PlanFragment.credentials)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::exec::shared::UserCredentials* temp = _impl_.credentials_;
  _impl_.credentials_ = nullptr;
  return temp;
}
inline ::exec::shared::UserCredentials* PlanFragment::_internal_mutable_credentials() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.credentials_ == nullptr) {
    auto* p = CreateMaybeMessage<::exec::shared::UserCredentials>(GetArenaForAllocation());
    _impl_.credentials_ = p;
  }
  return _impl_.credentials_;
}
inline ::exec::shared::UserCredentials* PlanFragment::mutable_credentials() {
  ::exec::shared::UserCredentials* _msg = _internal_mutable_credentials();
  // @@protoc_insertion_point(field_mutable:exec.bit.control.PlanFragment.credentials)
  return _msg;
}
inline void PlanFragment::set_allocated_credentials(::exec::shared::UserCredentials* credentials) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.credentials_);
  }
  if (credentials) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(credentials));
    if (message_arena != submessage_arena) {
      credentials = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, credentials, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.credentials_ = credentials;
  // @@protoc_insertion_point(field_set_allocated:exec.bit.control.PlanFragment.credentials)
}

// optional string options_json = 15;
inline bool PlanFragment::has_options_json() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void PlanFragment::clear_options_json() {
  _impl_.options_json_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PlanFragment::options_json() const {
  // @@protoc_insertion_point(field_get:exec.bit.control.PlanFragment.options_json)
  return _internal_options_json();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PlanFragment::set_options_json(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.options_json_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.bit.control.PlanFragment.options_json)
}
inline std::string* PlanFragment::mutable_options_json() {
  std::string* _s = _internal_mutable_options_json();
  // @@protoc_insertion_point(field_mutable:exec.bit.control.PlanFragment.options_json)
  return _s;
}
inline const std::string& PlanFragment::_internal_options_json() const {
  return _impl_.options_json_.Get();
}
inline void PlanFragment::_internal_set_options_json(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.options_json_.Set(value, GetArenaForAllocation());
}
inline std::string* PlanFragment::_internal_mutable_options_json() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.options_json_.Mutable( GetArenaForAllocation());
}
inline std::string* PlanFragment::release_options_json() {
  // @@protoc_insertion_point(field_release:exec.bit.control.PlanFragment.options_json)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.options_json_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.options_json_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void PlanFragment::set_allocated_options_json(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.options_json_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.options_json_.IsDefault()) {
          _impl_.options_json_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.bit.control.PlanFragment.options_json)
}

// optional .exec.bit.control.QueryContextInformation context = 16;
inline bool PlanFragment::has_context() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.context_ != nullptr);
  return value;
}
inline void PlanFragment::clear_context() {
  if (_impl_.context_ != nullptr) _impl_.context_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::exec::bit::control::QueryContextInformation& PlanFragment::_internal_context() const {
  const ::exec::bit::control::QueryContextInformation* p = _impl_.context_;
  return p != nullptr ? *p : reinterpret_cast<const ::exec::bit::control::QueryContextInformation&>(
      ::exec::bit::control::_QueryContextInformation_default_instance_);
}
inline const ::exec::bit::control::QueryContextInformation& PlanFragment::context() const {
  // @@protoc_insertion_point(field_get:exec.bit.control.PlanFragment.context)
  return _internal_context();
}
inline void PlanFragment::unsafe_arena_set_allocated_context(
    ::exec::bit::control::QueryContextInformation* context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.context_);
  }
  _impl_.context_ = context;
  if (context) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:exec.bit.control.PlanFragment.context)
}
inline ::exec::bit::control::QueryContextInformation* PlanFragment::release_context() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::exec::bit::control::QueryContextInformation* temp = _impl_.context_;
  _impl_.context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exec::bit::control::QueryContextInformation* PlanFragment::unsafe_arena_release_context() {
  // @@protoc_insertion_point(field_release:exec.bit.control.PlanFragment.context)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::exec::bit::control::QueryContextInformation* temp = _impl_.context_;
  _impl_.context_ = nullptr;
  return temp;
}
inline ::exec::bit::control::QueryContextInformation* PlanFragment::_internal_mutable_context() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.context_ == nullptr) {
    auto* p = CreateMaybeMessage<::exec::bit::control::QueryContextInformation>(GetArenaForAllocation());
    _impl_.context_ = p;
  }
  return _impl_.context_;
}
inline ::exec::bit::control::QueryContextInformation* PlanFragment::mutable_context() {
  ::exec::bit::control::QueryContextInformation* _msg = _internal_mutable_context();
  // @@protoc_insertion_point(field_mutable:exec.bit.control.PlanFragment.context)
  return _msg;
}
inline void PlanFragment::set_allocated_context(::exec::bit::control::QueryContextInformation* context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.context_;
  }
  if (context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(context);
    if (message_arena != submessage_arena) {
      context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.context_ = context;
  // @@protoc_insertion_point(field_set_allocated:exec.bit.control.PlanFragment.context)
}

// repeated .exec.bit.control.Collector collector = 17;
inline int PlanFragment::_internal_collector_size() const {
  return _impl_.collector_.size();
}
inline int PlanFragment::collector_size() const {
  return _internal_collector_size();
}
inline void PlanFragment::clear_collector() {
  _impl_.collector_.Clear();
}
inline ::exec::bit::control::Collector* PlanFragment::mutable_collector(int index) {
  // @@protoc_insertion_point(field_mutable:exec.bit.control.PlanFragment.collector)
  return _impl_.collector_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::bit::control::Collector >*
PlanFragment::mutable_collector() {
  // @@protoc_insertion_point(field_mutable_list:exec.bit.control.PlanFragment.collector)
  return &_impl_.collector_;
}
inline const ::exec::bit::control::Collector& PlanFragment::_internal_collector(int index) const {
  return _impl_.collector_.Get(index);
}
inline const ::exec::bit::control::Collector& PlanFragment::collector(int index) const {
  // @@protoc_insertion_point(field_get:exec.bit.control.PlanFragment.collector)
  return _internal_collector(index);
}
inline ::exec::bit::control::Collector* PlanFragment::_internal_add_collector() {
  return _impl_.collector_.Add();
}
inline ::exec::bit::control::Collector* PlanFragment::add_collector() {
  ::exec::bit::control::Collector* _add = _internal_add_collector();
  // @@protoc_insertion_point(field_add:exec.bit.control.PlanFragment.collector)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::exec::bit::control::Collector >&
PlanFragment::collector() const {
  // @@protoc_insertion_point(field_list:exec.bit.control.PlanFragment.collector)
  return _impl_.collector_;
}

// -------------------------------------------------------------------

// Collector

// optional int32 opposite_major_fragment_id = 1;
inline bool Collector::has_opposite_major_fragment_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Collector::clear_opposite_major_fragment_id() {
  _impl_.opposite_major_fragment_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t Collector::opposite_major_fragment_id() const {
  // @@protoc_insertion_point(field_get:exec.bit.control.Collector.opposite_major_fragment_id)
  return _internal_opposite_major_fragment_id();
}
inline void Collector::set_opposite_major_fragment_id(::int32_t value) {
  _internal_set_opposite_major_fragment_id(value);
  // @@protoc_insertion_point(field_set:exec.bit.control.Collector.opposite_major_fragment_id)
}
inline ::int32_t Collector::_internal_opposite_major_fragment_id() const {
  return _impl_.opposite_major_fragment_id_;
}
inline void Collector::_internal_set_opposite_major_fragment_id(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.opposite_major_fragment_id_ = value;
}

// repeated int32 incoming_minor_fragment = 2 [packed = true];
inline int Collector::_internal_incoming_minor_fragment_size() const {
  return _impl_.incoming_minor_fragment_.size();
}
inline int Collector::incoming_minor_fragment_size() const {
  return _internal_incoming_minor_fragment_size();
}
inline void Collector::clear_incoming_minor_fragment() {
  _impl_.incoming_minor_fragment_.Clear();
}
inline ::int32_t Collector::incoming_minor_fragment(int index) const {
  // @@protoc_insertion_point(field_get:exec.bit.control.Collector.incoming_minor_fragment)
  return _internal_incoming_minor_fragment(index);
}
inline void Collector::set_incoming_minor_fragment(int index, ::int32_t value) {
  _impl_.incoming_minor_fragment_.Set(index, value);
  // @@protoc_insertion_point(field_set:exec.bit.control.Collector.incoming_minor_fragment)
}
inline void Collector::add_incoming_minor_fragment(::int32_t value) {
  _internal_add_incoming_minor_fragment(value);
  // @@protoc_insertion_point(field_add:exec.bit.control.Collector.incoming_minor_fragment)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>& Collector::incoming_minor_fragment() const {
  // @@protoc_insertion_point(field_list:exec.bit.control.Collector.incoming_minor_fragment)
  return _internal_incoming_minor_fragment();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>* Collector::mutable_incoming_minor_fragment() {
  // @@protoc_insertion_point(field_mutable_list:exec.bit.control.Collector.incoming_minor_fragment)
  return _internal_mutable_incoming_minor_fragment();
}

inline ::int32_t Collector::_internal_incoming_minor_fragment(int index) const {
  return _impl_.incoming_minor_fragment_.Get(index);
}
inline void Collector::_internal_add_incoming_minor_fragment(::int32_t value) { _impl_.incoming_minor_fragment_.Add(value); }
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>& Collector::_internal_incoming_minor_fragment() const {
  return _impl_.incoming_minor_fragment_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<::int32_t>* Collector::_internal_mutable_incoming_minor_fragment() {
  return &_impl_.incoming_minor_fragment_;
}

// optional bool supports_out_of_order = 3;
inline bool Collector::has_supports_out_of_order() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Collector::clear_supports_out_of_order() {
  _impl_.supports_out_of_order_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool Collector::supports_out_of_order() const {
  // @@protoc_insertion_point(field_get:exec.bit.control.Collector.supports_out_of_order)
  return _internal_supports_out_of_order();
}
inline void Collector::set_supports_out_of_order(bool value) {
  _internal_set_supports_out_of_order(value);
  // @@protoc_insertion_point(field_set:exec.bit.control.Collector.supports_out_of_order)
}
inline bool Collector::_internal_supports_out_of_order() const {
  return _impl_.supports_out_of_order_;
}
inline void Collector::_internal_set_supports_out_of_order(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.supports_out_of_order_ = value;
}

// optional bool is_spooling = 4;
inline bool Collector::has_is_spooling() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Collector::clear_is_spooling() {
  _impl_.is_spooling_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool Collector::is_spooling() const {
  // @@protoc_insertion_point(field_get:exec.bit.control.Collector.is_spooling)
  return _internal_is_spooling();
}
inline void Collector::set_is_spooling(bool value) {
  _internal_set_is_spooling(value);
  // @@protoc_insertion_point(field_set:exec.bit.control.Collector.is_spooling)
}
inline bool Collector::_internal_is_spooling() const {
  return _impl_.is_spooling_;
}
inline void Collector::_internal_set_is_spooling(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.is_spooling_ = value;
}

// optional bool enable_dynamic_fc = 5;
inline bool Collector::has_enable_dynamic_fc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void Collector::clear_enable_dynamic_fc() {
  _impl_.enable_dynamic_fc_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool Collector::enable_dynamic_fc() const {
  // @@protoc_insertion_point(field_get:exec.bit.control.Collector.enable_dynamic_fc)
  return _internal_enable_dynamic_fc();
}
inline void Collector::set_enable_dynamic_fc(bool value) {
  _internal_set_enable_dynamic_fc(value);
  // @@protoc_insertion_point(field_set:exec.bit.control.Collector.enable_dynamic_fc)
}
inline bool Collector::_internal_enable_dynamic_fc() const {
  return _impl_.enable_dynamic_fc_;
}
inline void Collector::_internal_set_enable_dynamic_fc(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.enable_dynamic_fc_ = value;
}

// -------------------------------------------------------------------

// QueryContextInformation

// optional int64 query_start_time = 1;
inline bool QueryContextInformation::has_query_start_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void QueryContextInformation::clear_query_start_time() {
  _impl_.query_start_time_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int64_t QueryContextInformation::query_start_time() const {
  // @@protoc_insertion_point(field_get:exec.bit.control.QueryContextInformation.query_start_time)
  return _internal_query_start_time();
}
inline void QueryContextInformation::set_query_start_time(::int64_t value) {
  _internal_set_query_start_time(value);
  // @@protoc_insertion_point(field_set:exec.bit.control.QueryContextInformation.query_start_time)
}
inline ::int64_t QueryContextInformation::_internal_query_start_time() const {
  return _impl_.query_start_time_;
}
inline void QueryContextInformation::_internal_set_query_start_time(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.query_start_time_ = value;
}

// optional int32 time_zone = 2;
inline bool QueryContextInformation::has_time_zone() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void QueryContextInformation::clear_time_zone() {
  _impl_.time_zone_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t QueryContextInformation::time_zone() const {
  // @@protoc_insertion_point(field_get:exec.bit.control.QueryContextInformation.time_zone)
  return _internal_time_zone();
}
inline void QueryContextInformation::set_time_zone(::int32_t value) {
  _internal_set_time_zone(value);
  // @@protoc_insertion_point(field_set:exec.bit.control.QueryContextInformation.time_zone)
}
inline ::int32_t QueryContextInformation::_internal_time_zone() const {
  return _impl_.time_zone_;
}
inline void QueryContextInformation::_internal_set_time_zone(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.time_zone_ = value;
}

// optional string default_schema_name = 3;
inline bool QueryContextInformation::has_default_schema_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void QueryContextInformation::clear_default_schema_name() {
  _impl_.default_schema_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& QueryContextInformation::default_schema_name() const {
  // @@protoc_insertion_point(field_get:exec.bit.control.QueryContextInformation.default_schema_name)
  return _internal_default_schema_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryContextInformation::set_default_schema_name(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.default_schema_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.bit.control.QueryContextInformation.default_schema_name)
}
inline std::string* QueryContextInformation::mutable_default_schema_name() {
  std::string* _s = _internal_mutable_default_schema_name();
  // @@protoc_insertion_point(field_mutable:exec.bit.control.QueryContextInformation.default_schema_name)
  return _s;
}
inline const std::string& QueryContextInformation::_internal_default_schema_name() const {
  return _impl_.default_schema_name_.Get();
}
inline void QueryContextInformation::_internal_set_default_schema_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;


  _impl_.default_schema_name_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryContextInformation::_internal_mutable_default_schema_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.default_schema_name_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryContextInformation::release_default_schema_name() {
  // @@protoc_insertion_point(field_release:exec.bit.control.QueryContextInformation.default_schema_name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.default_schema_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.default_schema_name_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void QueryContextInformation::set_allocated_default_schema_name(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.default_schema_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.default_schema_name_.IsDefault()) {
          _impl_.default_schema_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.bit.control.QueryContextInformation.default_schema_name)
}

// optional string session_id = 4;
inline bool QueryContextInformation::has_session_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void QueryContextInformation::clear_session_id() {
  _impl_.session_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& QueryContextInformation::session_id() const {
  // @@protoc_insertion_point(field_get:exec.bit.control.QueryContextInformation.session_id)
  return _internal_session_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryContextInformation::set_session_id(Arg_&& arg,
                                                     Args_... args) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.session_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:exec.bit.control.QueryContextInformation.session_id)
}
inline std::string* QueryContextInformation::mutable_session_id() {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:exec.bit.control.QueryContextInformation.session_id)
  return _s;
}
inline const std::string& QueryContextInformation::_internal_session_id() const {
  return _impl_.session_id_.Get();
}
inline void QueryContextInformation::_internal_set_session_id(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;


  _impl_.session_id_.Set(value, GetArenaForAllocation());
}
inline std::string* QueryContextInformation::_internal_mutable_session_id() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.session_id_.Mutable( GetArenaForAllocation());
}
inline std::string* QueryContextInformation::release_session_id() {
  // @@protoc_insertion_point(field_release:exec.bit.control.QueryContextInformation.session_id)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.session_id_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.session_id_.Set("", GetArenaForAllocation());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void QueryContextInformation::set_allocated_session_id(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.session_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.session_id_.IsDefault()) {
          _impl_.session_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:exec.bit.control.QueryContextInformation.session_id)
}

// -------------------------------------------------------------------

// WorkQueueStatus

// optional .exec.DrillbitEndpoint endpoint = 1;
inline bool WorkQueueStatus::has_endpoint() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.endpoint_ != nullptr);
  return value;
}
inline const ::exec::DrillbitEndpoint& WorkQueueStatus::_internal_endpoint() const {
  const ::exec::DrillbitEndpoint* p = _impl_.endpoint_;
  return p != nullptr ? *p : reinterpret_cast<const ::exec::DrillbitEndpoint&>(
      ::exec::_DrillbitEndpoint_default_instance_);
}
inline const ::exec::DrillbitEndpoint& WorkQueueStatus::endpoint() const {
  // @@protoc_insertion_point(field_get:exec.bit.control.WorkQueueStatus.endpoint)
  return _internal_endpoint();
}
inline void WorkQueueStatus::unsafe_arena_set_allocated_endpoint(
    ::exec::DrillbitEndpoint* endpoint) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.endpoint_);
  }
  _impl_.endpoint_ = endpoint;
  if (endpoint) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:exec.bit.control.WorkQueueStatus.endpoint)
}
inline ::exec::DrillbitEndpoint* WorkQueueStatus::release_endpoint() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::exec::DrillbitEndpoint* temp = _impl_.endpoint_;
  _impl_.endpoint_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exec::DrillbitEndpoint* WorkQueueStatus::unsafe_arena_release_endpoint() {
  // @@protoc_insertion_point(field_release:exec.bit.control.WorkQueueStatus.endpoint)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::exec::DrillbitEndpoint* temp = _impl_.endpoint_;
  _impl_.endpoint_ = nullptr;
  return temp;
}
inline ::exec::DrillbitEndpoint* WorkQueueStatus::_internal_mutable_endpoint() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.endpoint_ == nullptr) {
    auto* p = CreateMaybeMessage<::exec::DrillbitEndpoint>(GetArenaForAllocation());
    _impl_.endpoint_ = p;
  }
  return _impl_.endpoint_;
}
inline ::exec::DrillbitEndpoint* WorkQueueStatus::mutable_endpoint() {
  ::exec::DrillbitEndpoint* _msg = _internal_mutable_endpoint();
  // @@protoc_insertion_point(field_mutable:exec.bit.control.WorkQueueStatus.endpoint)
  return _msg;
}
inline void WorkQueueStatus::set_allocated_endpoint(::exec::DrillbitEndpoint* endpoint) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.endpoint_);
  }
  if (endpoint) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(endpoint));
    if (message_arena != submessage_arena) {
      endpoint = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, endpoint, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.endpoint_ = endpoint;
  // @@protoc_insertion_point(field_set_allocated:exec.bit.control.WorkQueueStatus.endpoint)
}

// optional int32 queue_length = 2;
inline bool WorkQueueStatus::has_queue_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void WorkQueueStatus::clear_queue_length() {
  _impl_.queue_length_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t WorkQueueStatus::queue_length() const {
  // @@protoc_insertion_point(field_get:exec.bit.control.WorkQueueStatus.queue_length)
  return _internal_queue_length();
}
inline void WorkQueueStatus::set_queue_length(::int32_t value) {
  _internal_set_queue_length(value);
  // @@protoc_insertion_point(field_set:exec.bit.control.WorkQueueStatus.queue_length)
}
inline ::int32_t WorkQueueStatus::_internal_queue_length() const {
  return _impl_.queue_length_;
}
inline void WorkQueueStatus::_internal_set_queue_length(::int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.queue_length_ = value;
}

// optional int64 report_time = 3;
inline bool WorkQueueStatus::has_report_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void WorkQueueStatus::clear_report_time() {
  _impl_.report_time_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int64_t WorkQueueStatus::report_time() const {
  // @@protoc_insertion_point(field_get:exec.bit.control.WorkQueueStatus.report_time)
  return _internal_report_time();
}
inline void WorkQueueStatus::set_report_time(::int64_t value) {
  _internal_set_report_time(value);
  // @@protoc_insertion_point(field_set:exec.bit.control.WorkQueueStatus.report_time)
}
inline ::int64_t WorkQueueStatus::_internal_report_time() const {
  return _impl_.report_time_;
}
inline void WorkQueueStatus::_internal_set_report_time(::int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.report_time_ = value;
}

// -------------------------------------------------------------------

// FinishedReceiver

// optional .exec.bit.FragmentHandle receiver = 1;
inline bool FinishedReceiver::has_receiver() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.receiver_ != nullptr);
  return value;
}
inline const ::exec::bit::FragmentHandle& FinishedReceiver::_internal_receiver() const {
  const ::exec::bit::FragmentHandle* p = _impl_.receiver_;
  return p != nullptr ? *p : reinterpret_cast<const ::exec::bit::FragmentHandle&>(
      ::exec::bit::_FragmentHandle_default_instance_);
}
inline const ::exec::bit::FragmentHandle& FinishedReceiver::receiver() const {
  // @@protoc_insertion_point(field_get:exec.bit.control.FinishedReceiver.receiver)
  return _internal_receiver();
}
inline void FinishedReceiver::unsafe_arena_set_allocated_receiver(
    ::exec::bit::FragmentHandle* receiver) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.receiver_);
  }
  _impl_.receiver_ = receiver;
  if (receiver) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:exec.bit.control.FinishedReceiver.receiver)
}
inline ::exec::bit::FragmentHandle* FinishedReceiver::release_receiver() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::exec::bit::FragmentHandle* temp = _impl_.receiver_;
  _impl_.receiver_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exec::bit::FragmentHandle* FinishedReceiver::unsafe_arena_release_receiver() {
  // @@protoc_insertion_point(field_release:exec.bit.control.FinishedReceiver.receiver)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::exec::bit::FragmentHandle* temp = _impl_.receiver_;
  _impl_.receiver_ = nullptr;
  return temp;
}
inline ::exec::bit::FragmentHandle* FinishedReceiver::_internal_mutable_receiver() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.receiver_ == nullptr) {
    auto* p = CreateMaybeMessage<::exec::bit::FragmentHandle>(GetArenaForAllocation());
    _impl_.receiver_ = p;
  }
  return _impl_.receiver_;
}
inline ::exec::bit::FragmentHandle* FinishedReceiver::mutable_receiver() {
  ::exec::bit::FragmentHandle* _msg = _internal_mutable_receiver();
  // @@protoc_insertion_point(field_mutable:exec.bit.control.FinishedReceiver.receiver)
  return _msg;
}
inline void FinishedReceiver::set_allocated_receiver(::exec::bit::FragmentHandle* receiver) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.receiver_);
  }
  if (receiver) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(receiver));
    if (message_arena != submessage_arena) {
      receiver = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, receiver, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.receiver_ = receiver;
  // @@protoc_insertion_point(field_set_allocated:exec.bit.control.FinishedReceiver.receiver)
}

// optional .exec.bit.FragmentHandle sender = 2;
inline bool FinishedReceiver::has_sender() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sender_ != nullptr);
  return value;
}
inline const ::exec::bit::FragmentHandle& FinishedReceiver::_internal_sender() const {
  const ::exec::bit::FragmentHandle* p = _impl_.sender_;
  return p != nullptr ? *p : reinterpret_cast<const ::exec::bit::FragmentHandle&>(
      ::exec::bit::_FragmentHandle_default_instance_);
}
inline const ::exec::bit::FragmentHandle& FinishedReceiver::sender() const {
  // @@protoc_insertion_point(field_get:exec.bit.control.FinishedReceiver.sender)
  return _internal_sender();
}
inline void FinishedReceiver::unsafe_arena_set_allocated_sender(
    ::exec::bit::FragmentHandle* sender) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sender_);
  }
  _impl_.sender_ = sender;
  if (sender) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:exec.bit.control.FinishedReceiver.sender)
}
inline ::exec::bit::FragmentHandle* FinishedReceiver::release_sender() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::exec::bit::FragmentHandle* temp = _impl_.sender_;
  _impl_.sender_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::exec::bit::FragmentHandle* FinishedReceiver::unsafe_arena_release_sender() {
  // @@protoc_insertion_point(field_release:exec.bit.control.FinishedReceiver.sender)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::exec::bit::FragmentHandle* temp = _impl_.sender_;
  _impl_.sender_ = nullptr;
  return temp;
}
inline ::exec::bit::FragmentHandle* FinishedReceiver::_internal_mutable_sender() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.sender_ == nullptr) {
    auto* p = CreateMaybeMessage<::exec::bit::FragmentHandle>(GetArenaForAllocation());
    _impl_.sender_ = p;
  }
  return _impl_.sender_;
}
inline ::exec::bit::FragmentHandle* FinishedReceiver::mutable_sender() {
  ::exec::bit::FragmentHandle* _msg = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:exec.bit.control.FinishedReceiver.sender)
  return _msg;
}
inline void FinishedReceiver::set_allocated_sender(::exec::bit::FragmentHandle* sender) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sender_);
  }
  if (sender) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sender));
    if (message_arena != submessage_arena) {
      sender = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sender, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.sender_ = sender;
  // @@protoc_insertion_point(field_set_allocated:exec.bit.control.FinishedReceiver.sender)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace control
}  // namespace bit
}  // namespace exec


PROTOBUF_NAMESPACE_OPEN

template <>
struct is_proto_enum<::exec::bit::control::RpcType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::exec::bit::control::RpcType>() {
  return ::exec::bit::control::RpcType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_BitControl_2eproto_2epb_2eh
